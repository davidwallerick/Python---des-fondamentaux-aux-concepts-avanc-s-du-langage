# MOOC INRIA / UCA : Python 3 : des fondamentaux aux concepts avancés du langage

## Arnaud Legout et Thierry Parmentelat 

## Transcriptions des videos de la semaine 3 : Renforcement des notions de base, références partagées 

# W3-S1 Les fichiers : 1ère partie 

Bonjour !


Cette semaine, nous allons découvrir les fichiers et de nouveaux types built-in que sont les tuples, les dictionnaires et les sets. Nous parlerons également de la gestion d s erreurs avec les exceptions et nous parlerons d'un concept central en Python, le concept de références partagées. Pour finir, nous vous ferons une rapide introduction des classes pour vous montrer la puissance de Python et surtout que vous pouvez créer vos propres objets qui se manipulent exactement comme les types built-in.


Les **fichiers** sont, comme souvent en Python, simples et intuitifs à utiliser, cependant il faut maîtriser trois notions que sont **l'encodage, l'itération et la notion de context manager**. Ouvrons maintenant un interpréteur Python pour commencer à jouer avec ces différentes notions.


Je vous rappelle que lorsque nous avons parlé des chaînes de caractères, je vous avais dit qu'il était très important de maîtriser votre encodage, ce qui veut dire que vous devez maîtriser l'encodage pour **écrire** les chaînes de caractères mais également pour les **lire**. Nous allons voir qu'avec les fichiers, cette gestion de l'encodage est extrêmement simple puisque c'est l'objet fichier qui va se charger d'encoder et de décoder les chaînes de caractères pour nous. Regardons ça avec un exemple.

Nous allons créer un fichier avec l'instruction **built-in open**, avec la fonction built-in open. Créons un fichier donc je fais une variable f qui est égale à open et je vais ouvrir un fichier, alors je vais dire que mon fichier est dans le répertoire *c:\temp\spam.txt*.  Il y a un point très important à respecter que vous avez dû voir dans les compléments c'est que les chaînes de caractères avec des backslashes (\) vont interpréter les backslashes, notamment *\t* est un caractère de tabulation. Donc si je ne veux pas avoir d'interprétation soit je dois doubler tous les backslashes ou alors la manière recommandée, c'est de transformer votre chaîne en **rawstring** en mettant un petit *r* ce qui va désactiver tous les caractères *\.*

Maintenant que j'ai défini mon nom de fichier je vais donner un mode d'ouverture. Les modes d'ouverture les plus courants sont le mode *w*pour ouvrir le fichier en écriture ou le mode *r*pour ouvrir le fichier en lecture. Et ensuite, comme j'ai ouvert mon fichier en mode texte, nous verrons dans la deuxième partie de cette vidéo l'ouverture des fichiers en mode binaire, je vais spécifier un encodage. Je vais donc mettre un **paramètre encoding**et quel encoding je vais mettre ? je vous l'ai déjà expliqué, lorsque je ne sais pas quoi mettre, par défaut, je mets toujours de l'**utf8**. Je fais un retour chariot, j'ai donc ouvert un fichier en mode écriture ; si le fichier n'existe pas il vient d'être créé sur mon disque dur, avec un encodage utf8. Maintenant, je vais pouvoir manipuler le fichier de manière extrêmement simple, je n'ai plus à me préoccuper de l'encodage, je vais écrire dans mon fichier des chaînes de caractères Python de type *str*, et après, je  pourrai lire des chaînes de caractères de mon fichier. L'objet fichier va se charger pour nous de faire l'encodage et le décodage.

Maintenant, regardons comment écrire dans un fichier. Je vais simplement faire une boucle *for i in range de 100*: et je vais faire un **f.write(f"ligne {i+1}\n")**. Donc ici, nous voyons que je fais une boucle *for* qui va parcourir tous les entiers allant de 0 à 99, et je vais, avec l'instruction write, écrire dans mon fichier une chaîne de caractères. Donc ici ma chaîne de caractères est une *f-string*, mais c'est une chaîne de caractères de type *str*, une chaîne de caractères normale. Il est très important de ne pas oublier le backslash n, qui permet de faire le retour chariot. Si vous ne faites pas de *retour chariot*, tous vos *write* vont écrire à la suite de la ligne. Donc pour faire écrire sur une ligne différente à chaque fois, il faut obligatoirement mettre de manière explicite un *\n*. Donc je fais un retour chariot et maintenant, j'ai écrit dans mon objet fichier.

Pour finir, il ne faut pas oublier de fermer le fichier avec un **f.close**.  Nous allons revenir dans quelques instants sur l'importance de cette manière de fermer les fichiers, et surtout sur la manière moderne de manipuler les fichiers que l'on appelle les **context managers**.

Regardons maintenant le fichier qui a été créé. Si vous êtes dans un interpréteur IPython, vous pouvez très facilement lancer des commandes shell avec la commande !. Comme je suis sous Windows je vais taper  *type* pour voir mon fichier mais si vous êtes sous Linux ou sous macOS, vous pouvez très bien utiliser less ou cat. Je vais maintenant regarder mon fichier. Je regarde avec type, type, c'est juste pour regarder le contenu du fichier, mon fichier temp/spam.txt et je vois mon fichier  apparaître avec le mot ligne et le numéro qui va de 1 à 100. Vous avez remarqué qu'une fois que mon fichier a été ouvert, je n'ai plus à me préoccuper de l'encodage, mon fichier a bien été écrit correctement et a bien été décodé correctement.

Donc maintenant regardons comment lire un fichier et réécrire dans un nouveau fichier. Nous allons voir qu'en Python le parcours des fichiers est également extrêmement simple puisqu'en Python, **les fichiers sont des itérateurs**. Ça veut dire qu'on peut directement les mettre dans une boucle for . Regardons cela.

Je vais ouvrir un fichier f, je vais réouvrir le fichier que je viens de créer *c:\temp\spam.txt* ; je vérifie que c'est bien le fichier que j'ai créé voilà. Je n'oublie pas de spécifier le mode d'ouverture donc ici, je vais ouvrir mon fichier en mode lecture simple, c'est spécifié avec un petit *r*, et je n'oublie pas de spécifier l'encodage encoding égale utf8 puisque j'ai créé mon fichier en utf8, il faut que je le lise et que je l'écrive évidemment avec le même encodage. Je vais ensuite créer un deuxième fichier f2 avec **open**, je vais reprendre, ça va être plus simple, je vais reprendre ma ligne du dessus. Je vais ouvrir un fichier spam2, qui est le fichier sur lequel je vais écrire, j'ouvre ce fichier en mode écriture avec le mode d'ouverture *w* et je gère encore mon encodage utf8. Maintenant, je vais parcourir mon premier fichier f, je vais faire une petite manipulation des lignes, et je vais écrire dans mon fichier f2. Regardons cela. Pour cela, je vais faire une boucle for et je vais faire un *for line in f*: que va faire la boucle for sur un fichier ? Lorsque le fichier est ouvert, il va être parcouru ligne par ligne donc Python va être capable de détecter automatiquement les sauts de ligne, et il va me retourner à chaque tour de la boucle for, une nouvelle ligne. C'est donc une manière simple et extrêmement intuitive de parcourir les lignes d'un fichier.

Donc je fais for line in f et ensuite, supposons que je veuille simplement changer le formatage de mon fichier, c'est-à-dire, qu'en fait, au lieu d'avoir des espaces qui séparent mes deux colonnes, je souhaite avoir une virgule. Regardons comment faire ça. La première chose à faire lorsqu'on parcourt les lignes d'un fichier, très souvent, c'est de transformer cette chaîne de caractères en liste. Nous avons déjà vu qu'on pouvait transformer une chaîne de caractères en liste avec **la méthode split** sur les chaînes de caractères. Donc je fais un **line.split**, je transforme ma ligne en objet liste, où le premier élément va être le mot ligne, le deuxième élément va être le numéro de la ligne. Et ensuite, je vais faire, alors, je peux tout à fait transformer, pour vous montrer cette possibilité, ma première colonne ligne en mot majuscule. Je le mets en majuscule, mon objet line étant une liste, il est mutable, je peux donc le modifier en place, et ensuite, je vais écrire dans mon fichier f2 avec l'instruction write, je va s faire un join pour transformer ma liste en chaîne de caractères, je mets une virgule pour maintenant avoir une virgule qui sépare mes colonnes, .join de line Et je n'oublie pas de rajouter un \n pour avoir mon retour chariot à chaque ligne. Donc j'ai écrit simplement, j'ai fait un join de ma liste en la séparant par une virgule, et j'ai rajouté un \n à la fin de ma ligne. J'exécute cela. Je n'oublie pas de fermer mes fichiers f et f2, et maintenant, je peux regarder mes fichiers, comme tout à l'heure avec mon point d'exclamation parce que je suis sur IPython ; évidemment, si vous n'utilisez pas IPython vous regardez directement les fichiers avec votre éditeur de texte préféré sur votre disque dur. Je vais regarder mon fichier qui est dans le répertoire temp et qui s'appelle spam.txt, regardons ce fichier qui est le même fichier que tout à l'heure et je regarde mon fichier spam2 et je remarque que mon fichier a bien été modifié comme attendu, la première colonne est en majuscule et mes deux colonnes sont maintenant séparées par une virgule. Vous voyez donc qu'il est extrêmement simple d'ouvrir, de manipuler un fichier, de parcourir ses lignes, de modifier les lignes, et d'écrire dans un nouveau fichier.


# W3-S1 Les fichiers : 2ème partie 


Nous venons de voir qu'il était extrêmement important de bien fermer vos fichiers. Cependant, vous pouvez vous demander mais pourquoi est-ce tellement important de fermer les fichiers ? En fait, la raison est simple. Votre programme Python va discuter avec le système d'exploitation et c'est le système d'exploitation qui va effectivement ouvrir, fermer et écrire dans les fichiers. Lorsque vous faites un open, vous dites à votre système d'exploitation: attention, moi, je veux ouvrir ce fichier ; et lorsque vous faites un close, vous lui dites: je veux fermer ce fichier. Comme le nombre de fichiers simultanément ouverts est limité dans un système d'exploitation, si vous ne dites pas que vous faites un *close*, le système d'exploitation va croire que le fichier est toujours ouvert, et vous pouvez vous retrouver dans une situation dans laquelle votre ordinateur n'est plus capable d'ouvrir de nouveaux fichiers. Mais quand on y pense, on se dit mais pourquoi est-ce que c'est au programmeur de penser à fermer systématiquement le fichier, alors qu'en Python, tout est un objet et qu'un fichier est également un objet. On pourrait très bien se dire : en fait, on pourrait faire en sorte que l'objet soit suffisamment intelligent pour savoir que lorsqu'on n'en a plus besoin il fait toutes les opérations nécessaires à sa fermeture. Et bien en fait, ce mécanisme existe en Python. C'est quelque chose qu'on appelle un protocole qui s'appelle le **protocole de context manager**. En fait, un objet fichier implémente ce protocole de context manager, et, lorsque l'on n'a plus besoin de ce fichier, le fichier sera automatiquement fermé. Regardons comment cela fonctionne en Python.

Pour accéder à ce **protocole de context manager**, vous utilisez l'**instruction with**, ensuite, vous ouvrez votre fichier normalement, comme un fichier standard, on va ouvrir le fichier c:/temp/spam.txt. Ensuite, j'ouvre mon fichier en mode lecture et évidemment, je contrôle l'encodage avec *encoding égale utf8*. Ensuite, je vais donner un nom à cet objet fichier, *as f*, et je mets un *: *ça veut dire que je vais créer un bloc d'instructions. Dans mon context manager, j'ai un bloc d'instructions et ce bloc d'instructions va être exécuté ; lorsque je sors de ce bloc d'instructions, on va appeler une méthode qui s'appelle*exit *sur le context manager de l'objet fichier, nous verrons ça dans de prochaines vidéos, qui va avoir pour effet de fermer automatiquement le fichier. L'intérêt de ce *context manager*, c'est que vous n'avez plus à fermer explicitement le fichier, il sera automatiquement fermé en sortie de bloc de code, mais c'est aussi que si vous avez une exception dans ce bloc de code, le fichier sera quand même fermé. Cela simplifie énormément l'ouverture des fichiers puisque vous n'avez plus à gérer la fermeture et les erreurs d'exécution. Maintenant, parcourons mon fichier, *for line in f :*, et je vais simplement faire un *print(line)*. J'affiche les différentes lignes de mon fichier. J'exécute ce **context manager**, et je vois les différentes lignes s'afficher. En sortie du bloc de code, le fichier a été automatiquement fermé et encore une fois, si j'avais une exception le fichier aurait été fermé.



Regardons maintenant comment écrire dans un **fichier binaire**. Comme nous venons de découvrir les context managers, c'est ce que nous allons utiliser par la suite. Nous allons ouvrir notre fichier dans un context manager, *with* je mets la fonction built-in *open*, et je vais ouvrir mon fichier c:\temp\spam.bin. Ensuite, je vais spécifier le mode d'ouverture je veux ouvrir mon fichier en mode écriture, et pour dire à Python que je veux l'ouvrir en mode binaire, je n'ai qu'à rajouter un petit *b*au mode d'ouverture du fichier. Donc si je veux ouvrir un fichier en **mode binaire et écriture**, j'écris *bw*; si je veux l'ouvrir en **mode binaire et lecture**, je vais écrire *br*. Comme mon fichier est ouvert en mode binaire, je n'ai pas spécifié d'encodage, et ensuite j'écris*as f: *pour donner un nom à mon fichier. Ensuite, je vais faire une simple boucle : *for i in range de 100*, et je vais écrire dans mon fichier *f.write*. Comme mon fichier est ouvert en mode binaire, je ne peux écrire dans ce fichier que des objets de **type bytes**et je  ne pourrai lire que des objets de type bytes. Pour écrire un objet de type bytes, c'est très simple, j'écris une chaîne de caractères en écrivant un petit b juste avant. Ça, c'est une chaîne de caractères de type bytes, et dedans, je vais écrire un caractère hexadécimal qui est juste avant \x3d. J'exécute mon bloc de code, j'ai écrit dans mon fichier, en sortie du bloc de code, le context manager a fermé le fichier, et j'ai maintenant sur mon disque dur un fichier qui s'appelle spam.bin qui contient le caractère 3d écrit 100 fois. Donc pour résume  encore une fois, ouverture d'un fichier en mode texte: on manipule le fichier avec des objets de type **str**; ouverture d'un fichier en mode binaire: on manipule le fichier avec des objets de type **bytes**.

Nous venons de voir les fichiers en Python. Nous avons vu que ces objets fichiers sont des objets extrêmement puissants, qui permettent de manière naturelle et intuitive de parcourir des fichiers. On a également vu la notion de context manager, qui permet d'ouvrir un fichier et de garantir sa fermeture automatique lorsqu'on n'a plus besoin de cet objet fichier. Par la suite, nous vous recommandons d'utiliser systématiquement les context managers dès que vous aurez à ouvrir des fichiers en Python.  



À bientôt !


# W3-S2 Les tuples

 Dans cette vidéo, nous allons parler d'un nouveau type built-in qui s'appelle **le tuple**. Le tuple est très proche de la liste ; comme une liste, c'est une séquence, on peut donc appliquer les opérations comme le test d'appartenance avec *in*, accéder aux différents éléments avec un crochet, faire du *slicing*dessus, et également, un tuple peut référencer des objets complètement hétérogènes. C'est très, très proche de la liste, mais il y a une différence fondamentale entre la liste et le tuple, c'est que le tuple est un **objet immuable**. Ça veut dire qu'une fois qu'on a créé le tuple, on ne peut plus le modifier. Nous verrons la raison fondamentale de l'existence du tuple, pourquoi est-ce qu'on a besoin d'un objet liste qui est immuable, lorsque nous parlerons des dictionnaires dans une prochaine vidéo. Pour le moment, ouvrons un interpréteur Python pour commencer à jouer avec le tuple.


Commençons par créer **un tuple vide**. On crée un tuple en écrivant simplement des parenthèses ouvrante et fermante. Ça va donc me créer un objet de type tuple, je peux le vérifier avec type, voilà, c'est un objet tuple qui est simplement vide. Évidemment, comme le tuple est immuable, lorsque je crée un tuple vide, je ne peux rien ajouter donc ce tuple vide a assez peu d'intérêt.

Ensuite, je peux créer **un tuple avec un élément**, avec la notation suivante t = (4,). Vous remarquez que j'ai rajouté une virgule à la fin de mon premier élément. Vérifions que cet objet est bien un tuple. Si vous écrivez (t = 4) avec des parenthèses sans virgule, pour Python, les parenthèses vont simplement permettre de grouper des opérations, et par conséquent, il va considérer qu'en fait l'objet que vous avez créé est juste un entier qui vaut 4. Donc pour un **tuple singleton**, un tuple d'un seul élément, il ne faut pas oublier de mettre la virgule.

Ensuite, je peux créer un tuple de plusieurs éléments, qui contient des objets complètement hétérogènes, exactement comme une liste t = (true, 3.4, 18) J'ai donc mon objet tuple. Une caractéristique importante du tuple, c'est que les parenthèses sont facultatives. Regardez, j'enlève les parenthèses, et je vais bien encore obtenir mon objet tuple. Je peux également tout à fait écrire un singleton sans parenthèses, et j'obtiens toujours mon objet tuple. Nous allons voir dans quelques instants pourquoi ces parenthèses ne sont pas nécessaires pour définir un tuple.

Comme le tuple est un objet de type séquence, je peux évidemment faire toutes les opérations que je peux faire sur une séquence. Reprenons un tuple avec un peu plus d'éléments. Je peux regarder est-ce que 3.4 in t et je vois que cet objet de type *float*est bien dans mon tuple ; je peux accéder à des éléments de la manière suivante: t[1], c'est le deuxième élément donc ça va être 3.4, et je peux également faire un slice pour aller du début jusqu'à l'élément 2 exclu, je vous rappelle qu'il va me retourner le premier et le deuxième éléments de mon tuple. **Je peux convertir un tuple en liste**, j'ai mon tuple t, je peux faire a égale list de t, et mon tuple a été converti en liste, et je peux ensuite repasser de ma liste à un tuple si par exemple, je décide de modifier mon objet en cours d'exécution. Par exemple, je modifie le premier élément et maintenant je le mets égal à False. On voit que ma liste vaut False, 3.4, 18. Je reconvertis cette liste en tuple et je le réaffecte vers ma variable t, j'ai oublié le signe =, donc c'est pour ça que j'ai une erreur de syntaxe. Voilà, maintenant, je vois que j'ai bien le tuple qui vaut False, 3.4 et 18. C'est très important de comprendre cela, le tuple étant immuable, je n'ai pas modifié mon objet tuple ; j'avais un tuple que j'ai converti en objet liste j'ai modifié l'objet liste et j'ai créé un nouvel objet tuple.

Le tuple est très utilisé pour une opération qu'on appelle le **tuple unpacking**. Qu'est-ce que le tuple unpacking ? C'est quelque chose de très simple, vous avez dans un tuple deux variables, a et b, et vous dites que ces variables sont égales à une séquence qui doit avoir le même nombre d'éléments que le nombre d'éléments que vous avez dans votre tuple. Par exemple, je vais mettre une liste qui vaut 3, 4. J'exécute ça, et je vais voir que ma variable a référence l'entier 3, ma variable b référence l'entier 4. Je vous ai dit que dans le tuple on pouvait enlever les parenthèses. Une des raisons, c'est justement pour alléger cette notation ; vous voyez bien qu'il est beaucoup plus naturel d'écrire a, b égalent 3, 4 que d'écrire le tuple avec des parenthèses (a, b) égale un tuple ou une liste avec des parenthèses ou crochets (3, 4). Cette notation fonctionne parfaitement, ce sont deux tuples mais on a enlevé les parenthèses pour alléger la notation, et je vois bien que maintenant a vaut bien 3, et b vaut bien 4. En Python, il existe également la notion de extended tuple unpacking. C'est une manière simple de pouvoir isoler des éléments lorsque j'ai un grand nombre d'éléments dans une séquence. Prenons un exemple: je vais dire a égale une liste qui contient 10 éléments. J'écris list de range de 10, range, c'est un itérateur qui va me générer 10 éléments et list va convertir chacun de ces éléments dans une liste qui va de 0 jusqu'à 9. Je vois bien que j'ai une liste qui va de 0 jusqu'à 9. Maintenant, supposons que je veuille prendre uniquement le premier élément, et les autres éléments dans un autre objet. Je peux écrire: x, étoile y égalent a Quel va être le résultat de cette opération ? x est égal au premier élément et y va référencer une liste qui va référencer tous les éléments qu'il reste dans a, y va être une liste qui référence 1, 2, 3 jusqu'à 9. Vous pouvez bien évidemment utiliser la notation dans l'autre sens par exemple, faire un étoile de x, y pour obtenir un autre tuple unpacking dans lequel vous allez isoler uniquement le dernier élément. x me référence bien la liste de 0 à 8, et y uniquement 9. Dans cette vidéo, nous avons parlé du tuple. Le tuple est un objet séquence très proche de la liste, dont la principale différence est d'être immuable. Le tuple est utilisé notamment dans des opérations de tuple unpacking, comme nous venons de le voir, mais également par exemple, comme clé de dictionnaire. Nous reviendrons sur cette notion dans une prochaine vidéo.


À bientôt !

# W3-S3 Tables de hash 


Jusqu'à maintenant, nous avons couvert les types séquences, avec notamment les listes, les chaînes de caractères et les tuples. Dans cette vidéo, nous allons parler **des tables de hash**, une structure de données qui permet de répondre à certaines limitations des types séquences. Ouvrons un interpréteur Python pour commencer à découvrir ces limitations.

Les types séquences ont été optimisés pour l'accès, la modification et l'effacement en fonction d'un numéro de séquence. Cependant, ces types n'ont pas été optimisés pour **le test d'appartenance**. Regardons un exemple pour illustrer cela.

Je vais utiliser l'instruction *timeit*, qui me permet de calculer le temps d'exécution d'une expression, et je vais regarder si la chaîne de caractères 'x' est dans range de 100. En fait, range de 100 va produire des entiers allant de 0 à 99, x n'étant pas dedans, je vais être obligé de parcourir chaque élément pour vérifier que x n'est pas dans cet élément. Faisons le test, et on voit que le temps d'exécution est de l'ordre de 2,33 microsecondes. Évidemment, c'est rapide. Mais maintenant, prenons un range qui est plus grand et multiplions-le par 100. Donc au lieu de prendre 100, je vais prendre 10 000. J'utilise au passage la notation underscore dans les entiers qui me permet de découper mon entier pour faciliter sa lecture. Donc on voit que j'ai dix et mille, j'ai bien un entier qui vaut dix mille. Faisons le test d'appartenance et regardons combien de temps cela prend, cela prend 284 microsecondes. Donc c'est à peu près 100 fois plus lent. Multiplions encore par 100 cette séquence et prenons maintenant un million. Je réexécute mon timeit, et regardons le temps d'exécution: 28 millisecondes. C'est de nouveau 100 fois plus lent. On voit clairement que l'opération de test d'appartenance sur une séquence est linéaire en fonction du nombre d'éléments que j'ai dans ma séquence. Là, évidemment, j'ai pris le cas le plus défavorable mais c'est la complexité du test d'appartenance sur la liste qui est linéaire avec le nombre d'éléments. Ça, c'est un problème parce qu'en fait le test d'appartenance est quelque chose de tellement commode qu'on aimerait pouvoir faire un test d'appartenance qui est indépendant du nombre d'éléments.

Une deuxième limitation des séquences est la suivante: vous savez que si je prends une séquence *t*qui est une liste qui contient deux éléments, [1, 2], je peux accéder au premier élément en faisant *t[0]*. Mais maintenant, supposons que dans ma séquence, dans ma liste, j'ai des âges, et que par exemple j'écrive t égale 18 et 35. Je pourrais très bien vouloir au lieu de faire t de 0 égale 18 écrire t de Alice ; je reprends :  écrire *t['Alice'] = 35*pour lier un nom à un âge, donc "indicer" mes séquences non plus avec des entiers mais avec par exemple des chaînes de caractères. Et bien ça, je ne peux pas le faire ; j'ai donc une erreur qui me dit que les indices des listes doivent être des entiers ou des slices mais pas des chaînes de caractères. La structure de données table de hash permet de répondre à ces deux limitations.

Commençons par regarder comment fonctionne une table de hash et dans de prochaines vidéos, nous regarderons comment est-ce qu'elles sont implémentées en Python. Regardons maintenant le fonctionnement de ces tables de hash. Je vais vous présenter ici évidemment une version simplifiée du fonctionnement des tables de hash mais dont le but est de vous faire comprendre le fonctionnement de cette structure de données. Essentiellement, une table de hash est constituée d'un tableau ; nous avons ici un tableau avec 6 éléments, et d'une fonction dont le but est le suivant: lorsque je passe à ma fonction un objet elle va me calculer une valeur qui va être comprise entre 1 et 6. Essentiellement le but de cette fonction est de créer une correspondance entre un objet quelconque et une case dans mon tableau. Regardons maintenant ce fonctionnement, cet ensemble fonction de hash et tableau constitue ce qu'on appelle une table de hash. Maintenant supposons que je veuille ajouter la chaîne de caractères 'eve', que je veuille créer une correspondance entre 'eve' et l'âge 34. Comment ça va fonctionner ? Je vais passer ce qu'on appelle une clé, la clé étant ce que je spécifie entre crochets, et je vais associer cette clé à ce qu'on appelle une valeur. Ce que j'ai entre crochets s'appelle la clé ce que j'ai après le signe = s'appelle la valeur. Je vais passer 'eve' à ma fonction de hash, ma fonction de hash va faire un calcul sur cet objet, et va me retourner une case dans le tableau, ici la case 2. Et je vais écrire ici le couple 'eve', 34. Ensuite, je fais t de 'bob' ; t de 'bob', ça veut dire que la clé est 'bob' et la valeur est 27 ; je passe 'bob' à ma fonction de hash, ça va me retourner une nouvelle case la case 4, et je vais stocker le couple 'bob', 27 dans mon tableau. Ensuite, si je veux accéder à 'eve', je vais simplement faire t de 'eve', par exemple, un print t de 'eve' ; je vais repasser 'eve' à ma fonction de hash ; ma fonction de hash va faire le même calcul, elle va donc arriver à la même case, je vais obtenir la case 2 du tableau, et je vais pouvoir afficher 'eve', 34, je vais donc afficher la valeur correspondant à 'eve' qui est la valeur 34. On voit donc que dans une table de hash l'insertion, l'effacement, la recherche d'élément sont indépendants du nombre d'éléments, c'est conditionné par la vitesse de la fonction de hash. Je fais un calcul et j'obtiens directement la case où est stockée la valeur correspondant à la clé.

Maintenant, regardons le cas suivant: je fais t de 'jo' égale 46. En fait, vous comprenez bien que dans mon tableau, je n'ai que 6 cases disponibles ; dans une vraie table de hash, j'aurai évidemment plus d'éléments, mais le nombre d'éléments est limité. Au bout d'un moment, je vais avoir ma fonction de hash qui va retourner une case qui est déjà occupée. Regardons ce qu'il se passe. t de 'jo' égale 46, ma fonction de hash me retourne la case 2. Je vais donc stocker 'jo', 46 dans cette table de hash à la suite de l'autre clé 'eve' associée à sa valeur 34. Si maintenant je fais un t de 'jo', qu'est-ce qu'il va se passer ? Je vais aller chercher 'jo' avec ma fonction de hash qui va toujours me retourner la case n°2, et je vais regarder est-ce que 'jo' est la clé correspondant au premier couple non je vais donc passer au deuxième couple ; est-ce que 'jo' est la clé correspondant au deuxième couple ? oui Je retourne donc la valeur 46.

Vous voyez donc que l'efficacité d'une table de hash est conditionnée non seulement par la taille du tableau, si j'ai un tableau trop petit je vais avoir beaucoup de ce qu'on appelle des collisions, **une collision **, c'est lorsque deux clés correspondent à la même entrée dans le tableau, et l'efficacité de ma table de hash est également conditionnée à la capacité de ma fonction de hash à bien répartir les clés dans les différentes cases du tableau. Évidemment, cette efficacité de fonction de hash, cette capacité de la fonction de hash à bien répartir les clés, est une caractéristique majeure d'une table de hash efficace. En Python, il faut savoir que les tables de hash ont été implémentées de manière très efficace ; vous n'avez pas à vous préoccuper de cette fonction de hash, vous n'avez pas à vous préoccuper de la taille du tableau ; Python va automatiquement gérer ça pour vous de manière à ce que vous ayez une efficacité qui soit excellente. Donc, essentiellement, vous pouvez faire l'hypothèse qu'en Python, les tables de hash vous permettent d'avoir un temps d'accès, un temps d'insertion, un temps d'effacement et un temps de recherche qui soient indépendants du nombre d'éléments.

Les tables de hash vous permettent d'accéder, d'effacer, de modifier, mais également de faire des tests d'appartenance avec une complexité qu'on appelle O(1) qui veut essentiellement dire que c'est indépendant du nombre d'éléments dans notre table de hash. C'est donc une structure de données très intéressante et qui permet également d'indexer des valeurs non pas avec des entiers comme dans une séquence, mais avec par exemple des chaînes de caractères. En Python, nous avons deux implémentations de tables de hash que sont les sets et les dictionnaires que nous allons voir dans une prochaine vidéo.

À bientôt !

# W3-S4 Les dictionnaires


Dans cette vidéo, nous allons voir l'utilisation des **dictionnaires**en Python. Les dictionnaires sont des tables de hash, on a donc un temps d'accès, d'insertion d'effacement et un test d'appartenance qui sont indépendants du nombre d'éléments. De plus, les dictionnaires sont des objets mutables, ça veut dire qu'on peut les modifier en place avec donc une excellent efficacité mémoire. Dans un dictionnaire, on peut avoir comme clé n'importe quel objet qui est hashable. Qu'est-ce que c'est, **un objet hashable**? C'est un objet sur lequel on peut calculer cette fameuse fonction de hash. Pour l'instant, sachez qu'en Python **tous les objets immuables sont hashables**; et que **tous les objets mutables ne sont pas hashables**. Quelle est l'intuition derrière ça ? C'est que vous vous souvenez que la fonction de hash doit faire un calcul sur la clé. Or, si cette clé change en cours d'exécution, la fonction de hash va faire un calcul qui va être différent et par conséquent, votre table de hash va devenir inconsistante. C'est pourquoi en Python avec les types built-in, seuls les types immuables c'est-à-dire qui ne peuvent plus changer une fois qu'ils ont été créés, peuvent être utilisés comme **clés d'un dictionnaire**. Ouvrons maintenant un interpréteur Python pour commencer à jouer avec les dictionnaires.

Pour créer un dictionnaire, on utilise la notation accolades. Regardons cet exemple. Je vais écrire *age = {}*et j'ai bien créé un objet qui est de type *dict*, le type dictionnaire. Ensuite, je peux créer un dictionnaire en écrivant directement à la main des couples clé - valeur séparés par des : donc 'ana' : 35 virgule 'eve' : 30 virgule 'bob' : 38 Donc là, j'ai créé un dictionnaire qui a trois clés 'ana', 'eve' et 'bob', et trois valeurs 35, 30 et 38. Vous pouvez vraiment voir les dictionnaires comme une collection de couples clé - valeur. Votre dictionnaire va stocker cette collection qui n'est pas ordonnée, il n'y a pas d'ordre dans un dictionnaire, vous allez avoir le couple 'ana' : 35, le couple 'eve' : 30 et le couple 'bob' : 38. Ensuite, votre dictionnaire va vous permettre d'accéder aux différents éléments en nommant la clé, par exemple, 'ana' va me permettre d'accéder à la valeur correspondant à la clé 'ana', age['ana'] je vois bien apparaître 35.

J'ai une deuxième manière de construire un dictionnaire, c'est la manière suivante: Supposons déjà, supposons qu'au départ vous ayez une liste qui contienne des tuples clé - valeur. ('ana', 35), un deuxième tuple: ('eve', 30) et un troisième tuple: ('bob', 38). J'ai donc une liste qui contient des tuples. Or, je vous ai expliqué qu'en Python la liste est vraiment au coeur de tous vos programmes donc c'est tout à fait possible de vous retrouver à un moment avec une liste qui contient des couples de clés et valeurs. À ce moment-là, pour créer un dictionnaire à partir de cette liste de tuples, c'est très simple, vous n'avez qu'à écrire la chose suivante: age égale dict de a. La fonction *built-in dict*va créer un dictionnaire à partir de ces couples clé - valeur où vous aurez: 'ana' qui correspond à la valeur 35, 'eve' à la valeur 30 et 'bob' à la valeur 38. De nouveau, je peux tout à fait accéder à la valeur correspondant à 'bob' ;  a de 'bob' je vois que... alors, ce n'est pas a mon dictionnaire, a, c'était la liste. Je refais age de 'bob', vous remarquez au passage que l'exception est tout à fait explicite, j'ai TypeError: list indices must be integers or slices ; l'objet que je voulais manipuler n'était pas une liste mais un dictionnaire ; c'est ce qui me permet de savoir que j'ai fait une erreur. age de 'bob' me retourne 38 ; je réaffiche mon dictionnaire age ; et comme mon dictionnaire est mutable, je peux tout à fait changer la valeur correspondant à 'bob'. Je peux écrire maintenant 'bob' égale 45, et je regarde mon dictionnaire, la valeur correspondant à 'bob' a bien été modifiée.

De nouveau, j'insiste bien sur le fait que les dictionnaires ne sont pas ordonnés ; lorsqu'on débute en Python on peut avoir l'impression que l'on a un certain ordre et que cet ordre peut changer par moment, en fait, vous n'avez aucune garantie d'ordre lorsque vous faites print d'un dictionnaire l'ordre affiché sera quelconque.

Vous pouvez également effacer un couple clé - valeur, donc une entrée dans un dictionnaire, en utilisant l'instruction *del*. Si je fais del age de 'bob' je vais effacer la clé 'bob' et la valeur correspondante et j'obtiens donc mon dictionnaire qui maintenant ne contient plus que 'ana' : 35, 'eve' : 30.

Une caractéristique très importante des dictionnaires, c'est que les dictionnaires ont des opérations qui sont très proches des séquences lorsque cette opération a un sens. Par exemple, combien est-ce que j'ai de clés dans mon dictionnaire ? Combien de couples clé - valeur ? J'utilise la *fonction built-in len*, qui va me retourner 2. Je peux également faire du test d'appartenance sur un dictionnaire ; encore une fois, je vais utiliser exactement la même instruction que pour les séquences, *l'instruction in*; donc je peux faire est-ce que 'ana' in mon dictionnaire age ? La réponse est "vrai". Est-ce que 'bob' in mon dictionnaire age ? La réponse est "faux". Vous voyez vraiment ce souci d'uniformité en Python ; lorsque c'est possible, on utilise quel que soit le type des instructions qui sont les mêmes. Par exemple, le nombre d'éléments dans une liste ou le nombre de clés dans un dictionnaire, c'est len ; le test d'appartenance sur toutes les séquences et sur les dictionnaires, c'est in.

Pour finir, j'aimerais vous montrer comment accéder aux clés, aux valeurs, ou aux couples clé - valeur qu'on appelle les items en Python, d'un dictionnaire. J'ai mon dictionnaire qui s'appelle age, je veux accéder aux clés, je vais y accéder avec **la méthode keys()**. Et keys() va me retourner un objet qui contient les clés. Ensuite, je peux accéder aux valeurs avec values() qui va me retourner un objet qui contient les valeurs. Et je peux accéder aux couples clé - valeur qu'on appelle les items avec la méthode sur le dictionnaire items(). Et on voit que j'obtiens des couples clé - valeur.
Ces méthodes *keys, values et items*retournent un objet qui est un petit peu particulier ; c'est un objet qu'on appelle **une vue**. Qu'est-ce que c'est, une vue, en Python ? C'est un objet sur lequel on peut itérer, donc on peut faire une boucle for sur cet objet, et on peut également faire un test d'appartenance, donc faire par exemple *in*directement sur cette vue ; la caractéristique principale des vues est que la vue est mise à jour en même temps que le dictionnaire. Regardons un exemple.

Je vais écrire a égale age.keys(), je vais plutôt l'appeler *k*pour rendre plus explicite que c'est la vue sur les clés : *k = age.keys()*. Regardons k, je vois bien que c'est la vue qui me permet d'accéder aux clés. Et maintenant, je vais modifier mon dictionnaire age ; je vais écrire 'bob', donc je rajoute une clé dans mon dictionnaire, 'bob' égale 25. Je rajoute un couple clé - valeur et on rajoute les couples clé - valeur avec cette notation: mon dictionnaire entre crochets la clé qu'on veut rajouter égale la nouvelle valeur. Cette notation vous permet de modifier une valeur existante ou alors de rajouter un nouveau couple clé - valeur. Je rajoute 'bob', et regardons maintenant ma vue. Je n'ai pas recréé ma vue, c'est la vue que j'ai créée avant l'ajout de cette clé, et bien, je vois que ma vue a automatiquement été mise à jour avec cette nouvelle clé. Donc en fait, les vues, vous devez vraiment voir ça comme une vue permanente sur votre objet, si votre objet est modifié, la vue va voir ce nouvel objet qui a été modifié. Je vous montre ce test d'appartenance sur les vues, si je regarde est-ce que 'ana' est dans mes clés ? C'est vrai. Est-ce que 'bill' est dans mes clés ? C'est faux. J'ai bien le test d'appartenance qui fonctionne tout à fait directement sur la vue.

Pour finir, j'aimerais vous montrer comment est-ce qu'on parcourt les dictionnaires. Une manière tout à fait classique de parcourir les dictionnaires, j'ai mon dictionnaire age, c'est d'écrire la boucle *for*suivante, en utilisant la notation de **tuple unpacking**. Je vais faire for k, v in age.items() Que me retourne items ? Une vue sur les couples clé - valeur donc à chaque tour de boucle, la boucle for va retourner un tuple clé - valeur ; en faisant k, v in ce tuple, je fais du unpacking, donc k va correspondre à la clé, v va correspondre à la valeur. Et ensuite je peux faire un print de là, j'écris une f-string clé, valeur, et ici, j'écris directement k, v. J'exécute ce morceau de code et je vois effectivement apparaître mes couples clé - valeur. Pour finir, je veux juste vous montrer que *l'itérateur sur les dictionnaire*est un itérateur directement sur les clés. Si j'itère directement sur mon dictionnaire, sans spécifier de vue, ce que va me retourner la boucle for, c'est simplement une nouvelle clé. Ici, je fais un print de k et je vois donc que j'itère directement sur les clés.

Nous venons donc de voir le nouveau type dictionnaire qui est une implémentation de table de hash qui permet l'accès, l'insertion, la modification, et le test d'appartenance, indépendamment du nombre d'éléments. Le dictionnaire est une structure de données extrêmement souple, qui vous permet par exemple d'implémenter sans aucun effort un agenda ou un annuaire.


À bientôt !

# W3-S5 Les ensembles


Dans cette vidéo, nous allons parler des **sets**. Les sets sont très proches des dictionnaires, comme les dictionnaires, ils permettent de faire des tests d'appartenance, d'accéder, modifier, effacer des éléments indépendamment du nombre d'éléments. Les sets sont également des objets mutables mais à la différence des dictionnaires, les sets ne stockent qu'une clé, il n'y a pas de valeur correspondante. Alors on peut se demander à quoi ça sert d'avoir une sorte de sous-dictionnaire qui ne stocke que des clés et pas de valeurs. En fait, la raison, c'est que le set est optimisé et a été créé pour des opérations spécifiques. Une première opération dans laquelle le set est très utilisé, c'est par exemple pour garder uniquement les éléments uniques d'une séquence ; si on calcule le set des éléments d'une séquence, on ne va avoir que les éléments uniques. Une deuxième opération pour laquelle le set est également très utilisé, c'est pour faire des tests d'appartenance sur les éléments d'une séquence. Ouvrons maintenant un interpréteur Python pour commencer à jouer avec les sets.

Les sets comme les dictionnaires sont des objets mutables, on peut donc les modifier en place. Commençons par créer un set, un set vide. Je vais le créer avec **la fonction built-in set**. J'ai bien un objet de type *set*qui est vide. Ensuite, je peux créer un objet avec la notation accolades ; on va faire 1, 2, 3, 'a' et 18, je peux même stocker un booléen puisque je peux stocker n'importe quel objet hashable dans un set. Je vous rappelle qu'en Python tous les immuables sont hashables et que les mutables ne sont pas hashables. Donc je peux stocker des entiers, des chaînes de caractères et des tuples d'entiers ou de chaînes de caractères. Je crée mon set. Quelle est la différence ici entre les accolades qui représentent un set et les accolades qui représentent un dictionnaire ? Dans un set simplement, je n'ai pas la notation : qui sépare la clé et la valeur. C'est ça qui fait la différence pour l'interpréteur Python. Ensuite, je peux créer un set à partir d'une séquence, par exemple, je peux avoir une liste a qui contient des éléments 1, 2, 3, 1, 18, 20, 4 je vois que j'ai une séquence d'entiers avec des éléments qui sont dupliqués ; si je fais un set de a, je vais garder uniquement les éléments uniques, et créer un set à partir de ces éléments-là. On voit que j'ai un ensemble d'éléments uniques maintenant.

Ensuite, je peux manipuler un set avec les fonctions built-in len pour obtenir le nombre d'éléments ; là encore, on remarque la grande uniformité en Python, len est utilisée pour les séquences, pour les dictionnaires et pour les sets ; le test d'appartenance, comme vous devez vous en douter, est fait avec l'instruction in. Est-ce que 1 in s ? Je vois que c'est vrai. Je regarde de nouveau mon ensemble s. Est-ce que 'b' in s ? Je vois que c'est faux. Là encore, test d'appartenance tout à fait uniforme entre tous les types built-in en Python. Ensuite dans mon ensemble s, je peux ajouter des éléments avec la méthode add(). Je peux ajouter ici par exemple la chaîne de caractères '18' alors je vais plutôt mettre 'alice' voilà, et donc j'ai ajouté dans mon ensemble dans mon ensemble s, j'ai ajouté la chaîne de caractères 'alice' et je peux ajouter une séquence d'éléments donc faire une opération répétitive d'ajout d'élément dans un set, avec la fonction update(). Donc je prends update d'une séquence 1, 2, 3, 4, 5, 6 et 7 ; et évidemment, lorsque je fais un update je ne rajoute que les éléments qui ne sont pas déjà dans mon ensemble s. Donc je fais un update sur s et je vois que dans s, j'ai rajouté les éléments qui n'y étaient pas, notamment les 4, 5, 6, 7 mais par contre, les éléments 1, 2, 3 qui étaient déjà présents n'ont pas été rajoutés. Ensuite, sur un set, je peux faire des opérations d'ensembles classiques ; je vais prendre un set s1 qui contient 1, 2, 3, et je vais prendre un ensemble s2 qui contient 3, 4, 5. Je peux maintenant calculer une différence entre deux ensembles, s1 moins s2, qui va en fait enlever tous les éléments de s2 dans s1, on voit le résultat ; et puis ensuite, on peut prendre l'union et l'intersection des ensembles. Là, j'ai pris l'union et l'intersection qui est notée de la manière suivante. Voilà, donc des opérations classiques sur des ensembles.

Regardons maintenant l'efficacité du **test d'appartenance**. Vous pouvez peut-être vous poser une question, lorsque je fais un test d'appartenance, est-ce que c'est rentable de convertir ma séquence en set ou est-ce qu'il vaut mieux que je fasse directement le test d'appartenance sur une séquence ? Il faut comprendre ce que veut dire ce test d'appartenance sur les ensembles. Lorsque vous faites un test d'appartenance sur une séquence, vous devez parcourir tous les éléments de la séquence jusqu'à trouver l'élément que vous cherchez. Si l'élément n'est pas présent, vous devez parcourir tous les éléments de la séquence. Essentiellement, parcourir tous les éléments d'une séquence ça correspond à regarder une case mémoire dans votre ordinateur et faire une comparaison entre l'objet stocké dans cette case mémoire et l'objet que vous voulez comparer. Faire un test d'appartenance sur un set, c'est très différent ; comme on l'a vu, un set, c'est une table de hash ; ça veut donc dire que faire un test d'appartenance, ça représente essentiellement un calcul d'une fonction de hash sur l'objet que vous voulez chercher. Cette fonction de hash va vous donner une case et ensuite vous allez comparer si cet objet est le bon. La question qu'on peut se poser c'est combien de temps prend le calcul de cette fonction de hash sur votre objet. En fait, nous allons voir que c'est extrêmement rapide et que c'est essentiellement, le temps de calcul de cette fonction de hash, de l'ordre de grandeur de l'accès à un élément dans une séquence. Regardons cela.

Je vais créer une liste qui contient un seul élément 0. Et je vais créer un set à partir de cette liste. Donc j'ai ma liste a qui contient uniquement 0, et j'ai mon set s qui contient uniquement 0. Et maintenant je vais faire un test d'appartenance avec timeit. Je vais faire un timeit, je lui donne un argument moins n 50 pour lui dire qu'il ne fasse que 50 boucles pour que mon timeit soit plus rapide, est-ce que 0 in a ? Et regardons le temps d'exécution. Sur ma machine, cela prend autour de 40 nanosecondes. Maintenant, je vais faire le même test mais sur le set. Je vous rappelle que le processus est différent ; sur la liste, je vais accéder à la première case mémoire, je vais comparer l'objet stocké dans ma liste avec 0, il se trouve que c'est le même objet, je retourne vrai. Pour le set, je vais faire un calcul avec la fonction de hash sur 0, je vais accéder à une case et ensuite je fais faire la comparaison. Regardons cela. Je regarde sur un set et je vois que le test d'appartenance est de l'ordre encore de 40 nanosecondes. Qu'est-ce que ça veut dire ? Ça veut dire qu'en fait, dès que vous avez à faire un test d'appartenance, convertissez toujours votre séquence en set, ce sera dans la quasi intégralité des cas une opération rentable. En fait, vous pouvez demander combien de temps cela va prendre de convertir une séquence en set. En fait, **convertir une séquence en set**, ça va prendre le temps de calculer la fonction de hash sur chaque élément. C'est essentiellement le temps qu'il vous faudrait pour parcourir une seule fois cette séquence si vous faisiez un test sur un objet qui n'appartient pas à la séquence. Donc on voit qu'en fait, quasiment tout le temps, c'est beaucoup plus rentable de convertir votre séquence en set, donc c'est notre recommandation: dès que vous faites un test d'appartenance sur une séquence, convertissez cette séquence en set et faites le test d'appartenance sur ce nouveau set.

Dans cette vidéo, nous avons vu le type set qui est une implémentation de table de hash, très proche du dictionnaire. La principale différence, c'est que le set ne stocke pas de valeurs, il ne stocke que des clés ; et nous avons vu notamment que le set était extrêmement efficace pour faire des tests d'appartenance.


À bientôt !

# W3-S6 Les exceptions


Depuis que nous avons commencé à jouer avec Python, vous les avez sans doute déjà rencontrées, mais vous ne savez sans doute pas vraiment quoi en faire ni ce que c'est. Ce sont **les exceptions**. Dans cette vidéo, nous allons vous expliquer comment gérer les exceptions. Il y a trois choses importantes à savoir sur les exceptions.
- C'est que premièrement une exception n'est pas une fatalité, c'est un mécanisme de communication d'erreurs tout à fait normales dans un programme, et on est capable de les capturer et de réagir à une exception.
- Deuxièmement, les exceptions fournissent de l'information sur l'erreur qui se produit, c'est donc un mécanisme de notification d'erreur extrêmement utile.
- Et troisièmement, les exceptions étant très efficaces en Python, c'est un mécanisme qu'on utilise couramment dans un fonctionnement normal d'un programme. Ouvrons maintenant un éditeur IDLE pour commencer à jouer avec les exceptions.


Commençons par écrire une petite fonction toute simple: def div(a, b) C'est une fonction qui prend deux arguments a et b, et qui va juste faire un print de a divisé par b. Absolument rien de compliqué, rien de subtil une simple fonction qui fait une division. Je sauvegarde, je vous rappelle que dans IDLE pour exécuter, je sauvegarde avec Ctrl-S, et j'exécute avec la touche F5. Et je vois à gauche, dans mon interpréteur Python, la fonction qui vient de s'exécuter. Je peux donc maintenant l'appeler, faire un div de 1 par 2 et je vois le résultat : 0.5. Tout à fait normal. Que se passe-t-il maintenant si je fais un div de 1 par 0 ? Donc une division par 0 ? Nous savons que les divisions par 0 sont impossibles ; je vais donc avoir une erreur d'exécution. Regardons ce qui se passe.

Je vois en effet une erreur d'exécution et on va prendre quelques instants pour la détailler. La dernière ligne de cette erreur donne le nom de l'exception qui s'appelle *ZeroDivisionError*. Les exceptions finissent en général lorsqu'elles notifient des erreurs par le mot Error. Et j'ai un message d'erreur: division by zero. Ensuite, la ligne juste au dessus, je vois apparaître la ligne de mon code où l'exception est apparue: print de a divisé par b. Et ensuite, la ligne juste au dessus, je vois le fichier dans lequel c'est apparu, donc on voit que c'est à la deuxième ligne de ce fichier, et je vois l'appel qui a produit cette erreur: div(1, 0). On voit donc que l'exception fournit énormément d'informations, elle donne la raison de l'erreur, et elle permet également de situer cette erreur dans le contexte d'exécution de mon programme. Seulement cette exception n'est pas une fatalité, je peux la capturer et on va regarder comment capturer cette exception.

Dans ma fonction, je vais rajouter un bloc qu'on appelle*try - except*, qui permet de capturer les exceptions. Tout ce qui est entre le try et le except va être évalué et si j'ai une exception qui est produite dans ce bloc de code, donc dans le bloc de code du try, je vais regarder si cette exception a été capturée par mon code. Comment je capture cette exception ? En écrivant*except*et en donnant un nom d'exception, dans ce cas-là, je veux capturer l'exception*ZeroDivisionError*. Je mets un : et dans le bloc de code du except, je vais écrire ce qui doit s'exécuter lorsque cette exception est produite, et je vais simplement écrire print "attention, division par 0". Voilà, tout simplement. Et ensuite, en sortie de cette instruction*try - except*, je vais juste écrire un print "continuons". Je sauvegarde avec Ctrl-S, j'exécute avec F5 et maintenant, je vais réappeler ma fonction div. Appelons div de 1 par 2. Je vois que j'obtiens mon résultat ; évidemment, "continuons" s'affiche. Ensuite, que se passe-t-il si je fais un div de 1 par 0 ? Je vois que mon exception a été produite, mais elle a été correctement capturée par la clause**except**. En effet, j'ai*except ZeroDivisionError*. Le bloc d'instructions de ma clause except a été exécuté, "attention, division par 0", et mon programme a continué à s'exécuter normalement. On voit donc que l'on peut tout à fait capturer une exception, avoir un comportement approprié qui réagisse à cet exception, et continuer l'exécution de notre programme.

Maintenant, regardons ce qu'il se passe si, au lieu de faire une division de 1 par 0, je fais une division de 1 par une chaîne de caractères qui représente le 0. C'est quelque chose qui peut se produire dans un programme où on manipule des entrées et à un moment, on se retrouve avec une chaîne de caractères qui aurait dû être convertie en entier mais qui n'a pas été convertie en entier. Exécutons ce code et regardons l'erreur. J'ai une erreur qui s'appelle*TypeError*, et qui me dit encore une fois de manière très explicite, c'est affiché dans la dernière ligne de mon exception, que l'opération division n'est pas supportée entre les entiers et les chaînes de caractères. De nouveau, je peux tout à fait réagir à cette exception en rajoutant une**clause except**. Je peux donc ajouter autant de clauses except que je veux pour réagir à des exceptions particulières. Là, je vais réagir à*TypeError*et je vais afficher un petit message me permettant d'expliquer exactement quel est le problème, je vais juste écrire "il faut des int". Voilà, donc un message tout simple. J'exécute ce morceau de code, et je vais réappeler ma fonction div de 1 par 2, je vois qu'il s'affiche: 0.5, "continuons" ; div de 1 par 0, je vois qu'il s'affiche: "attention, division par 0", "continuons" ; div de 1 par la chaîne de caractères '0', je vois qu'il s'affiche: "il faut des int", "continuons". Je vois donc que mon mécanisme d'exception en Python me permet de capturer n'importe quelle exception et d'avoir un comportement approprié.

En Python, vous pouvez avoir une clause except sans spécifier aucune exception. C'est en général une très mauvaise pratique. Pourquoi ? Parce que ça va cacher les exceptions qui sont produites par votre code. Prenez le cas que l'on vient de regarder. Supposons que vous vous disiez: de toute façon, quelle est l'erreur qui peut se produire avec une division ? Essentiellement, ce n'est qu'une division par zéro. Et que vous fassiez simplement, je vais vous montrer ça, juste un except qui affiche simplement "attention, division par 0". J'exécute ce code, et maintenant je fais une division de 1 par 0, on se dit: oui, je l'ai testé, ça fonctionne tout à fait ; mais si maintenant je fais un div de 1 par la chaîne de caractères '0', je vais avoir un message d'erreur qui n'est pas approprié, mon exception a été cachée, je ne connais pas la raison du problème dans mon programme et mon programme risque de planter plus loin dans le code.

D'une manière générale,**on doit toujours capturer les exceptions**que l'on a étudiées et que l'on sait qu'elles vont se produire dans notre code, et laisser remonter les exceptions que nous n'avons pas prévues. Une caractéristique importante des exceptions, c'est qu'elles*bubblent*. Ça veut dire qu'elles vont remonter votre pile d'exécution jusqu'à arrêter le programme. Regardons l'illustration de ce mécanisme de*bubbling*. Je vais définir une fonction*div*, que j'ai déjà définie, qui prend juste deux arguments a et b, et qui va juste faire un print de a divisé par b. Et ensuite, je vais définir une fonction f qui prend un seul argument x et qui va appeler div de 1 par x. On voit que j'ai deux fonctions, une fonction div et une fonction f, et que ma fonction div est appelée par une autre fonction, la fonction f. Exécutons cela. Regardons ce qu'il va se passer. Lorsque j'appelle ma fonction f avec par exemple 1, ma fonction va exécuter la fonction div mais tant que ma fonction div n'a pas retourné de valeur la fonction f reste en cours d'exécution. On dit qu'elle reste dans la pile d'exécution. En fait, la pile d'exécution va contenir toutes les fonctions de notre programme qui ont été appelées mais qui n'ont pas encore retourné de valeur. Si je fais f(1), j'appelle div(1,1). Je vais exécuter et je vais voir afficher 1. Si maintenant je fais f(0), que va-t-il se passer ? Je vais appeler la fonction div(1, 0) je vais faire un print de 1 divisé par 0, je vais avoir une exception, mon exception va être produite par la division a divisé par b à l'intérieur du print. L'exception va être produite, elle va arrêter l'exécution de ma fonction mais ma fonction a été appelée par f, l'exception va donc remonter la pile d'exécution, elle va sortir dans ma fonction f, elle n'a pas été capturée, elle va remonter la pile d'exécution et elle va arrêter mon programme. Regardons l'exécution de ça.

Ce mécanisme de**bubbling** a deux avantages majeurs. Le premier avantage, c'est que je peux capturer mon exception n'importe où le long de la pile d'exécution, je peux tout à fait capturer mon exception au niveau du print, je peux la capturer au niveau de la fonction f, dans ma fonction f, au niveau de l'appel de div, et je peux tout à fait la capturer lors de l'appel de f. Le deuxième avantage de cette remontée de l'exception, c'est que ma trace d'exécution va être capable de me dire exactement par où est passée mon exception et par conséquent, va me fournir des informations précieuses sur le diagnostic du problème dans mon programme. Regardons cela. Je vois que j'ai une exception qui s'appelle ZeroDivisionError qui a été produite par print de a divisé par b. Si je remonte, je vois que cette exception a eu lieu dans la fonction div, et que cette fonction div a été appelée par l'appel de f(0). J'ai donc une trace exacte de la remontée de mon exception qui me permet de diagnostiquer l'origine du problème, dans ce cas-là, l'appel de f(0).

Nous venons de voir le mécanisme des exceptions en Python. Une bonne pratique en Python est de capturer les exceptions que vous connaissez et de les capturer au plus près de l'endroit où elles se produisent dans votre code. En effet, plus vous les capturez tôt, et plus votre réaction peut être appropriée à l'origine du problème. Une question que vous pouvez vous poser, c'est comment est-ce que je fais pour connaître les exceptions que je dois capturer ? Bien là, il n'y a pas de miracle, la seule réponse à cette question est qu'il faut lire en détail la documentation des modules que vous utilisez ou des objets que vous utilisez.


À bientôt !

# W3-S7 Les références partagées


Dans cette vidéo, nous allons voir une notion centrale en Python, la notion de **références partagées**. Pourquoi est-ce que cette notion est si importante ? C'est ce mécanisme de références partagées qui vous permet d'accéder aux attributs de n'importe quel objet dans votre programme. Par conséquent, si vous ne maîtrisez pas cette notion, vous risquez d'introduire de nombreux bugs dans vos programmes. Regardons maintenant le fonctionnement de ces références partagées.

Supposons que je veuille faire une affectation *a égale l'entier 3* ; regardons ce que cela va produire. À gauche, j'ai l'espace de mes variables, que l'on appellera espace de nommage plus tard, et à droite, j'ai l'ensemble des objets créés dans mon programme. Donc *a = 3*, je vous l'avais déjà expliqué dans une précédente vidéo, va faire les opérations suivantes: il va commencer par créer l'entier 3, à cet entier, à cet objet entier, vont être associés deux champs importants, un **compteur de références** qui est ici en rouge, qui est à zéro, qui va représenter le nombre de variables qui référencent cet objet, et un **champ de type**, qui représente **le type de l'objet**. Python étant un **langage à typage fort**, le type, une fois qu'il a été défini, ne peut plus être changé. Donc je crée mon objet entier 3, ensuite je crée une variable *a* qui référence cet objet entier. Le compteur de références passe à 1, j'ai maintenant une référence vers mon entier. Ensuite, je fais *a égale 'spam'* ; je vais créer un objet *'spam'* de type chaîne de caractères, compteur de références à zéro ; ensuite, ma variable *a* ne référence plus l'entier 3, le compteur de références de 3 passe à 0, et *a* maintenant référence la chaîne de caractères 'spam' ; le compteur de 'spam' passe à 1. Lorsque le compteur de références d'un objet passe à zéro, le **module Garbage Collector** va prendre un accès sur cet objet, et va libérer la mémoire occupée par cet objet lors d'un cycle de Garbage Collection.

On ne gère pas nous-mêmes ces cycles de nettoyage de la **mémoire**, c'est le module GC, **Garbage Collector**, qui va gérer ça automatiquement pour nous. Donc en pratique, on n'a pas à se préoccuper de la création des zones mémoire et de la libération des zones mémoire, Python gère tout ça pour nous. Maintenant, regardons un autre cas. *a égale 3*, donc on l'a déjà vu, je crée mon objet entier 3, ma variable *a* qui référence mon entier. Le compteur de références passe à 1. Ensuite, je fais *b égale a*. Dans ce cas-là, je fais toujours la même chose je crée l'objet qui est à droite sauf que cette fois, c'est une variable qui est à droite. Donc en fait, je vais simplement réutiliser l'objet, qui est déjà référencé par ma variable *a*. Ensuite, je crée une variable *b* dans l'**espace des variables**, et ma variable *b* va référencer mon entier 3. Le compteur de références passe à 2, j'ai maintenant 2 références vers mon objet entier. Si je fais *a égale 'spam'*, je crée un nouvel objet 'spam' ma variable *a* va enlever sa référence vers l'entier 3, et je vais maintenant référencer l'objet 'spam'.

Donc nous voyons qu'à un moment de l'exécution de notre code, les variables *a* et *b* référençaient toutes les deux l'objet entier 3. **C'est ce qu'on appelle une référence partagée**. Une référence partagée est une référence qui est partagée par plusieurs variables. Lorsque cette référence est faite vers un objet immuable, c'est le cas d'un entier, il n'y a aucun effet de bord possible. Par contre, si l'objet référencé est un objet mutable, il y a un risque d'effet de bord qu'il faut comprendre et être capable de maîtriser. C'est ce que nous allons voir dans la suite.

Maintenant, mon objet, au lieu d'être un entier, est une **liste**. Donc je vais créer mon objet liste, je crée un objet liste, puis mon objet liste va lui-même référencer un entier 1 et un entier 2. Maintenant, je ne montre plus le compteur de références et le type de l'objet, pour simplifier la notation, mais sachez que la référence faite par la liste vers l'entier 1 va augmenter le compteur de références de mon entier 1. Le compteur de références n'est pas seulement augmenté, incrémenté lorsqu'on référence par une variable, mais il est également incrémenté lorsqu'on référence par un autre objet. Et maintenant, je crée ma variable *a* qui va référencer l'objet liste. Maintenant, faisons *b = a*. Donc on l'a déjà vu, je vais créer une référence partagée, je vais créer une variable b qui référence le même objet que mon objet référencé par a. Puis faisons a de 0 égale 'spam'. Que va faire cette opération ? Elle va dire: créer l'objet 'spam', je crée toujours l'objet qui est à droite, et ensuite, la case 0 de ma liste référencée par *a* doit maintenant référencer cet objet 'spam'. Je vais donc enlever la référence de ma liste vers l'entier 1, et je vais faire une référence de cette liste vers la chaîne de caractères 'spam'. J'ai une référence partagée, a référence l'objet liste, b référence l'objet liste, **l'objet liste est mutable**, il a été modifié par a, b voit également cet objet modifié. C'est ce qu'on appelle un effet de bord. On voit que *a* référence l'objet ['spam', 2] ; *b* référence l'objet ['spam', 2]. Cette **notion d'effet de bord**, c'est lorsque j'ai une référence partagée vers un objet mutable, que cet objet est modifié par une variable, l'autre variable va voir cet objet modifié. Maintenant, on peut se demander mais comment se prémunir de cet effet de bord ? C'est ce qu'on va voir maintenant.

Je crée toujours ma liste [1, 2], j'avance rapidement parce que maintenant c'est une notion claire, et la variable a va maintenant référencer cet objet liste. Maintenant, au lieu de faire *b = a*, je vais faire *b* égale un slice vide de *a*. Souvenez-vous, que fait un **slice vide** ? Un slice vide fait ce qu'on appelle une copie, en fait, ça s'appelle une **shallow copy**, ou une copie superficielle de ma liste. Ça veut donc dire, cette copie superficielle, que je vais créer un nouvel objet liste, mais que cet objet liste va référencer les mêmes objets que ceux référencés par ma liste originale. Ma liste va référencer le même 1, et le même 2. Maintenant, *b* va référencer ce nouvel objet liste, en fait, cette copie de la liste. Si maintenant je fais *a de 0 égale 'spam'*, je crée toujours ma chaîne de caractères 'spam', mais a de 0, c'est la case de la liste initiale, la première case de la liste initiale, je vais donc enlever la référence vers le 1 dans la liste initiale, et maintenant je vais référencer la chaîne de caractères 'spam'. On voit donc maintenant que j'ai été capable de supprimer cet effet de bord en faisant une copie de la liste au moment du partage de référence. On voit bien que *a* référence la liste ['spam', 2], et que b référence la liste [1, 2]. Seulement vous devez vous rendre compte que lorsque je fais cette **shallow copy**, je fais juste une copie superficielle, une copie de l'objet liste. Par contre, toutes les références sont partagées. Donc si ma liste référence un objet qui est lui-même mutable, dans ce cas-là, la shallow copy ne sera pas suffisante. Regardons un exemple.


Je crée une liste qui référence un entier 1, et qui référence un objet liste qui lui-même référence un entier 2. Et maintenant *a*, ma variable *a*, va référencer ce nouvel objet liste. Maintenant, je crée une variable *b*, qui référence une shallow copy de la liste. ça veut dire quoi, cette shallow copy ? C'est la copie superficielle donc je vais dupliquer la liste d'origine ; par contre, cette liste va référencer les mêmes objets que ceux référencés par *a*. Je vais référencer le même 1 et je vais référencer le même objet liste. Et maintenant, je crée ma variable b qui référence cet objet copie. Si je fais a de 1 de 0 égale 'spam', qu'est-ce que cela va faire ? a de 1, c'est la deuxième case de ma liste. a de 1 de 0, c'est la première case de la liste qui est référencée par la deuxième case de a. C'est donc la liste que l'on a entre 1 et 2. Je vais donc créer mon objet 'spam' et je vais supprimer la référence, et maintenant référencer directement la chaîne de caractères 'spam'. Or, comme cette liste, entre les entiers 1 et 2, est référencée à la fois par a et par b, si je regarde quelle est la valeur de a, on voit que a contient une liste qui contient maintenant 'spam', et que b contient également une liste qui contient 'spam'. Donc dans le cas d'un objet mutable qui référence des mutables, la shallow copy n'est pas suffisante. Comment est-ce que je peux m'en sortir ? En faisant ce qu'on appelle une **deep copy**, c'est-à-dire une **copie profonde** qui va copier de manière récursive tous les objets référencés. Regardons comment cela fonctionne.

Je recrée mon objet liste qui référence un entier 1, une liste qui référence 2, et ma variable qui référence cet objet liste. Et ensuite, je vais importer le module copy et faire un copy.deepcopy de a. Le module copy me permet d'accéder à une **méthode deepcopy** qui fait une copie profonde de tous les éléments référencés par a, donc je vais absolument tout copier. Regardons le résultat de ça: je crée un nouvel objet liste mais je crée également un nouvel objet 1, un nouvel objet liste qui référence 2, et ma liste copiée va référencer ce nouvel objet liste. J'ai donc deux objets, b va référencer ce nouvel objet liste, et j'ai donc deux objets totalement isolés l'objet en rouge qui est référencé par a, et l'objet en vert qui est référencé par b. Maintenant, si je veux modifier ma première case de la liste, donc si je fais *a* de 1 de 0 égale 'spam', je vais créer une chaîne de caractères 'spam', je vais enlever la référence de la liste entre le 1 et le 2 de la liste référencée par a, et maintenant on voit donc que a référence un objet qui contient 1, ['spam'], et que b référence un objet qui contient 1 et la liste [2].

Ce mécanisme de références partagées est central en Python. Tout fonctionne avec des références partagées, notamment le passage d'arguments aux fonctions. En Python, vous savez que tout est un objet, et par conséquent, tout a un surcoût mémoire. Il est de nouveau très important de minimiser le nombre de copies de nos objets en mémoire, et ce sont encore les références partagées qui sont à la manœuvre. Certains objets sont immuables et Python va optimiser l'utilisation de ces objets immuables. Donc par exemple, les petits entiers, les petites chaînes de caractères ou certains types de tuples vont tous être des singletons. Ça veut dire que ce sont des objets qui ne vont exister qu'en un seul exemplaire en mémoire, et on va utiliser uniquement des références partagées à chaque fois qu'on aura besoin d'accéder à ces objets. C'est de nouveau un moyen de minimiser le nombre d'objets en mémoire. Vous voyez donc que les références partagées sont vraiment au cœur de Python et c'est le mécanisme central pour minimiser l'occupation mémoire de nos programmes.

À bientôt !

# W3-S8 Introduction aux classes


Nous avons vu jusqu'à maintenant les principaux types built-in. Nous avons vu les chaînes de caractères, les séquences avec les listes, les tuples, les dictionnaires, les sets. Et nous avons surtout remarqué que ces différents types built-in, bien qu'étant de nature différente, se manipulaient de manière extrêmement proche, en fait exactement de la même manière. Connaître la longueur d'une séquence, la longueur d'un set ou d'un dictionnaire, c'est fait avec *len*. Afficher le contenu de ces objets, c'est fait avec *print*. Faire le test d'appartenance, c'est fait avec *in*. Cette uniformité dans le comportement des objets est une caractéristique majeure de Python. Ce qui explique la faible courbe d'apprentissage que l'on a en Python ; lorsque vous savez faire quelque chose avec un type d'objet, vous savez le faire avec quasiment tous les autres types. Python va bien au-delà de cette puissance des types built-in. En fait, en Python, vous pouvez écrire **vos propres objets**, définir vos propres objets, qui vont se comporter exactement comme des types built-in. Donc vous pouvez créer des objets qui vont supporter le test d'appartenance avec in, qui vont supporter la fonction built-in print ou la fonction built-in len, ou qui vont supporter l'affectation avec les crochets. Dans cette vidéo, je vais vous présenter le mécanisme qui permet d'implémenter vos propres objets.** C'est ce qu'on appelle des classes.** Avec une classe, vous pouvez créer des objets et définir des méthodes pour que vos objets se comportent exactement comme des types built-in. Je vous rappelle que lorsque nous avons introduit ces notions d'objets, nous avons dit qu'il y avait une usine qui construisait les objets, c'était **le type**. Et bien en fait, **le type, c'est la classe**, c'est la même chose. Donc la classe, c'est l'usine qui va créer vos instances, et les instances, ce sont les objets qui vont être produits. Si vous voulez prendre une analogie avec les types built-in, list, c'est le type qui va créer les objets listes, et tous les objets listes que l'on produit sont des instances du type list. Ouvrons maintenant un éditeur IDLE pour commencer à jouer avec les classes.

On crée une **classe** avec l'instruction class suivie du nom de la classe, et je vais faire une classe qui ne fait absolument rien. En fait, comme il faut une instruction dans le bloc de code de la classe, je mets simplement pass qui ne fait absolument rien. Ensuite, je sauvegarde et j'exécute avec F5. J'ai maintenant dans mon interpréteur une classe C que je peux appeler avec des parenthèses. Lorsque j'appelle ma classe C avec des parenthèses, je vais créer des instances. Regardons ça, si j'écris *c1 égale une classe C*, je vais créer une instance de cette classe ; *c2 égale une classe C*, je vais créer une deuxième instance de cette classe. Nous voyons bien que *c1* et *c2* sont deux objets distincts puisqu'ils sont situés à des adresses mémoire différentes. Évidemment, comme cette classe n'a défini absolument aucune méthode, on n'a aucun comportement spécifique avec notre classe, on a essentiellement une classe qui ne sert à rien, qui ne fait rien. Maintenant, on veut ajouter des méthodes dans cette classe. La première méthode qu'on veut ajouter, c'est ce qu'on appelle l'initialisateur ou le constructeur de nos instances. Regardons cela ;

je vais définir une méthode *def* qui s'appelle *\_init\_* et qui va prendre deux arguments, *self* et *phrase*.  Et je vais renommer ma classe en classe *Phrase* pour avoir un nom de classe qui est un petit peu plus explicite. Ensuite, je vais écrire *self.mots*  - et je vais revenir sur la signification de ce que je suis en train d'écrire- = *phrase.split*. Regardons ce que j'ai écrit: j'ai défini une fonction avec *def* à l'intérieur d'une classe. **Les fonctions définies dans les classes s'appellent des méthodes**. Et cette méthode prend deux arguments *self* et *phrase*. En fait, lorsque je vais appeler la méthode sur la classe, l'instance va automatiquement être passée comme premier argument donc *self* va correspondre à l'instance qui a été créée par ma classe. Dans la méthode *\_init\_*, cette méthode est appelée lorsque je crée mon instance, et l'argument que je passe lors de la création de cette instance est passé à *phrase*. Regardons comment cela va se passer. Je sauvegarde, j'exécute avec F5 pour créer mon objet classe Phrase, et je vais écrire p égale Phrase de et je passe entre parenthèses "je fais un mooc sur python". Lorsque je fais un retour chariot, ma classe *Phrase* va appeler la *méthode \_init\_*. La phrase que j'ai passée entre les parenthèses de Phrase va être passée au deuxième argument de ma méthode \_init\_ Et cette phrase va être découpée par split dans une liste, et vous remarquez que cette liste, je l'ai affectée à *self.mots*. self, c'est mon instance, c'est donc p, donc self.mots va être un attribut mots dans mon instance. Regardons l'exécution ; j'exécute, j'ai donc mon instance p et mon instance maintenant a un attribut *mots qui a été créé par \_init\_ qui contient la liste des mots créés dans ma phrase. On voit que maintenant je suis capable de créer des instances qui héritent d'un comportement de la classe Phrase, donc du type qui a été utilisé pour créer mon instance. Ici, le comportement est basique ; c'est simplement la phrase que je passe lorsque je construis mon instance qui est automatiquement mise dans une liste qui est référencée par l'attribut *mots* de cette instance.

Maintenant, je pourrais vouloir ajouter des méthodes à mon instance, par exemple, je pourrais dire en fait, j'aimerais bien avoir une méthode que je suis capable d'appeler sur mon instance, comme je le fais sur les listes, sur les listes, je peux prendre une *liste.append* pour rajouter des éléments dans ma liste. Et bien, j'aimerais bien définir une méthode qui va mettre tous les mots en majuscule. Pour faire ça, je vais définir une méthode qui s'appelle **upper**, qui prend obligatoirement comme premier argument mon instance, c'est comme ça que je peux travailler sur les attributs de mon instance, et qui va simplement transformer la liste mots en liste mise en majuscule. Pour cela, je vais faire une simple compréhension de liste, donc je vais faire self.mots égale une compréhension qui va faire un *m.upper() for m in self*, et je ferme ma compréhension de liste. Donc en fait, lorsque je vais appeler upper sur mon instance, je vais récupérer l'attribut mots de mon instance, je vous rappelle que l'instance, c'est self dans les méthodes, et je vais dire que cet attribut mots maintenant référence une nouvelle liste qui prend tous les mots en majuscule. Alors évidemment sur self.mots, sur la liste des mots dans mon instance. Voilà. Je sauvegarde et j'exécute, et maintenant, je vais recréer une instance, donc je vais recréer une instance comme je l'ai fait tout à l'heure ici, je vais dire une instance p qui contient la phrase mots donc j'ai toujours mots qui est contenu dans mon instance, et si maintenant, je fais *p.upper()*, donc j'appelle la méthode upper sur mon instance, et que je regarde maintenant que vaut l'attribut mots, je vois que l'attribut mots contient tous les mots mis en majuscule. Ma méthode sur mon instance a été capable de modifier un attribut de mon instance.

Mais vous remarquez qu'en fait comment est-ce que je fais normalement avec les listes pour afficher le contenu d'une liste ? Je ne fais pas p point quelque chose, je fais directement un print de mon instance. Or, qu'est-ce qu'il se passe si je fais un print de p ? Je vois qu'il s'affiche l'adresse de l'objet. Or, ce n'est pas ce que je veux, je voudrais afficher le contenu de ma liste. En fait, c'est très facile de le faire en Python. C'est pour ça que je vous dis que Python vous permet de manipuler vos objets comme des types built-in. Je n'ai qu'à implémenter une méthode qui s'appelle *\_str\_*, qui prend comme argument self, et qui va faire un return d'une chaîne de caractères, et là, la chaîne de caractères que je vais afficher, ça va simplement être un retour chariot *"\n" join(self.mots)*. Qu'est-ce que ça va faire ? Ça va regrouper tous mes mots dans une chaîne de caractères et faire un retour chariot à chaque mot ; essentiellement, afficher mes mots sur une colonne. Lorsque maintenant je vais faire, donc j'exécute mon code, lorsque maintenant je vais faire un print sur mon instance, print(p) va automatiquement appeler la méthode *\_str\_* sur cette instance et va donc m'afficher mes mots dans une colonne. J'aurais pu tout à fait implémenter également le test d'appartenance avec la méthode *\_contains\_* ; j'aurais pu implémenter le nombre d'éléments, le nombre de mots dans ma phrase, avec la méthode *\_len\_* ; tous ces comportements que j'ai avec les types built-in, j'aurais pu les implémenter dans ma classe Phrase.

Nous avons vu, dans cette vidéo, comment implémenter des classes, c'est-à-dire comment implémenter l'usine qui va construire vos propres instances. Nous avons vu également qu'il était possible d'implémenter dans vos propres objets des comportements qui sont les mêmes que les comportements des types built-in. N'ayez pas d'inquiétude, nous reviendrons largement sur ces notions de classe et d'instance dans les semaines qui viennent.


À bientôt ! 
