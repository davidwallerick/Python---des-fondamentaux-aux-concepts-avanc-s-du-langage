# MOOC INRIA / UCA : Python 3 : des fondamentaux aux concepts avancés du langage

## Arnaud Legout et Thierry Parmentelat 

## Transcriptions des videos de la semaine 2 : Notions de base pour écrire son premier programme en Python


# W2-S1 Codage, jeux de caractères et Unicode


Bonjour.


Cette semaine, nous allons parler des **chaînes de caractères** et des **listes**. Nous en profiterons d'ailleurs lorsque nous parlerons des chaînes de caractères, pour vous expliquer ce que sont les notions de codage, décodage, jeux de caractères et Unicode. Ce sont des notions fondamentales que vous devez maîtriser dès que vous manipulez des chaînes de caractères. Ensuite nous parlerons des objets séquences dont les chaînes de caractères et les listes font d'ailleurs partie. Dans la deuxième partie de cette semaine, nous couvrirons un certain nombre de sujets très importants pour commencer à faire vos premiers programmes. Nous parlerons notamment de tests if else, nous parlerons de compréhensions de liste, de fonctions et de modules. Également nous couvrirons la boucle for. Nous ne ferons que des introductions très rapides ; notre objectif est de pouvoir vous permettre, dès cette semaine, de commencer à écrire de vrais petits programmes.



Dans cette vidéo, nous allons parler des notions fondamentales de **codage, décodage, jeux de caractères et Unicode**. Commençons par regarder cette chaîne de caractères. Ici, vous voyez une succession de lettres et il va sans doute vous falloir quelques secondes pour être capable d'identifier que ces lettres forment des mots et que ces mots forment une phrase ; *la phrase: Je fais un mooc sur Python*. Votre cerveau a fait une opération que l'on appelle une opération de décodage ; il a pris une suite de lettres et il a été capable d'identifier les mots contenus dans cette liste. En informatique, nous n'avons pas de lettres mais nous manipulons des bits, des flux de bits. La question maintenant que l'on peut se poser est comment passer d'un flux de bits à la notion de lettre. En fait nous faisons, en informatique, la même opération, une opération de **décodage**.

Donc en quoi va consister ce décodage ? Le décodage va consister à définir une convention qui va dire: je découpe mon flux de bits en blocs d'une certaine taille. Dans notre exemple, nous allons prendre des blocs de 7 bits. C'est ce qu'on appelle d'ailleurs le codage ASCII. Découpons notre flux de bits en blocs de 7 bits, et regardons à quels nombres correspondent ces blocs de 7 bits. Ici, je fais une conversion en nombre décimal pour faciliter l'explication mais en informatique, dans un ordinateur, nous restons évidemment en binaire. Donc on voit que le premier bloc de 7 bits correspond au nombre 97, le deuxième, au code 108, et caetera, 105, 99 et 101. Maintenant que nous avons été capables de découper notre flux de bits en blocs et qu'on a obtenu un code correspondant à chaque bloc, il faut être capable de dire à quelle lettre correspond ce code. Nous utilisons pour ça ce qu'on appelle un jeu de caractères.


Un **jeu de caractères** est une table qui va donner un code qui correspond à un caractère. Nous allons prendre le jeu de caractères ASCII et dans le jeu de caractères ASCII, le code 97 va correspondre à la lettre a, le code 108 à la lettre l, et caetera. Une fois que vous avez ce caractère, un caractère est une notion abstraite, ça n'est pas encore un dessin que vous allez être capable d'afficher sur votre écran. Pour être capable d'afficher un dessin sur un écran, il faut utiliser pour cela une **police de caractères**. Ici, nous allons représenter les différentes lettres du prénom Alice avec la police lucida calligraphy gras. En fait, la police de caractères va définir un **glyphe** ; un glyphe, c'est en fait le dessin qui va correspondre à chaque caractère que l'on veut afficher. En résumé, lorsque l'on lit un contenu sur internet, ou alors sur un disque dur, nous avons un flux de bits et nous faisons donc des opérations de décodage pour obtenir les caractères et de manière inverse, lorsque l'on veut écrire quelque chose sur un disque dur, ou envoyer des données sur internet, nous allons faire une opération de codage pour retransformer nos lettres en flux de bits. Cependant, vous avez peut-être remarqué un problème avec notre codage ; nous avons utilisé un codage ASCII qui est sur 7 bits. Or, sur 7 bits, vous ne pouvez coder que 128 caractères différents. Nous voyons bien que nous ne pouvons pas coder tous les caractères du monde sur simplement 128 caractères. Nous devons donc utiliser des codages qu'on appelle des codages étendus. Il existe des codages ASCII étendus qui sont codés sur 8 bits. Sur 8 bits, vous pouvez coder 256 caractères mais encore une fois, 256 caractères, ça n'est pas suffisant pour coder tous les caractères du monde. Or, pendant des années, nous avons utilisé un grand nombre de codages ASCII étendus et d'autres types de codages qui ont permis par exemple de coder les caractères utilisés en français ou les caractères utilisés en allemand. Cependant, ces jeux de caractères sont incompatibles. Et c'est ce qui a produit pendant des années les erreurs que vous connaissez sans doute, vous recevez des mails avec des caractères bizarres ou alors vous allez sur internet et vous voyez des caractères bizarres s'afficher. C'est parce que simplement votre ordinateur ne contient pas le jeu de caractères qui a été utilisé pour encoder le texte publié par quelqu'un.



Pour résoudre ce problème, un projet a été démarré qui s'appelle le projet **Unicode**. L'objectif de ce projet est de coder l'intégralité des caractères du monde. Dans Unicode, dans le jeu de caractères Unicode, nous avons actuellement plus de 120 000 caractères qui ont été codés. Ainsi, en utilisant Unicode, vous avez la certitude de pouvoir coder et décoder l'intégralité des caractères du monde entier. Unicode utilise différents types de codage qui s'appellent UTF-8, UTF-16 et UTF-32. Sans rentrer dans le détail de ces encodages, sachez qu'ils participent à un compromis entre compacité du codage et vitesse de décodage. En pratique, nous utilisons très régulièrement le codage UTF-8 qui a la caractéristique importante d'être totalement compatible avec le codage ASCII standard. La bonne nouvelle avec Unicode, c'est que Python est totalement compatible avec le codage Unicode. La mauvaise nouvelle, c'est que vous devez contrôler votre encodage. En effet, je vous ai dit qu'il existait maintenant le jeu de caractères Unicode qui couvre tous les caractères du monde mais il existe encore de nombreux autres jeux de caractères utilisés dans d'anciens documents. Si vous ne contrôlez pas finement votre codage et décodage, vous ne pourrez pas dire à Python quel type de jeu de caractères utiliser. Donc la règle est simple: lorsque vous créez des documents ou lorsque vous lisez des documents, utilisez toujours UTF-8 sauf si on vous dit explicitement d'utiliser un autre jeu de caractères.

À bientôt !


# W2-S2-1  Les chaînes de caractères

Dans cette vidéo, nous allons parler des **chaînes de caractères** et notamment de comment gérer l'encodage avec les chaînes de caractères. Ouvrons un interpréteur Python pour commencer à jouer avec ces chaînes de caractères.

Pour créer une chaîne de caractères, c'est très simple en Python, vous n'avez qu'à l'entourer soit par des apostrophes, donc par exemple je fais la chaîne de caractères 'spam', ou alors par des guillemets. Voilà, ça crée deux chaînes de caractères totalement équivalentes. Maintenant, je vais affecter ma chaîne de caractères à une variable pour pouvoir la manipuler. Les chaînes de caractères sont des objets immuables, ça veut dire qu'une fois qu'ils ont été créés, on ne peut plus les modifier. Les chaînes de caractères contiennent également de nombreuses méthodes qui permettent de manipuler ces chaînes de caractères. Comme je viens de l'expliquer, les chaînes de caractères sont **immuables**, ça veut dire que toutes les opérations, toutes les méthodes, les fonctions qui manipulent les chaînes de caractères vont retourner un nouvel objet chaîne de caractères.

Vous pouvez vous demander mais comment je fais pour connaître toutes les méthodes qui existent sur les chaînes de caractères. Python a l'avantage d'être un langage auto-documenté, ça veut dire que vous pouvez très facilement interroger depuis un interpréteur l'aide Python. Regardons un exemple. Je sais que les chaînes de caractères, c'est le **type str**, je peux donc directement écrire str point d'interrogation, cette opération point d'interrogation n'est possible que depuis un interpréteur IPython ou depuis un notebook. Regardons ce que j'obtiens, j'obtiens une aide succincte sur le type chaîne de caractères. Je peux également accéder à l'intégralité des méthodes qui existent sur un objet particulier, en utilisant la fonction **built-in dir**. Donc, si je fais dir de str, je vais voir toutes les méthodes qui sont associées aux chaînes de caractères. Vous avez remarqué que vous avez certaines méthodes qui commencent et finissent par des doubles underscores, nous ne parlerons pas de ces méthodes pour le moment, nous reviendrons dessus dans de prochaines vidéos puisqu'il s'agit d'un sujet avancé lié aux méthodes spéciales.


Donc pour l'instant, concentrons-nous sur les **méthodes** qui utilisent simplement un nom sans underscore. Nous remarquons que ces méthodes ont des noms qui ont l'air assez explicites. Par exemple, la méthode title, essayons cette méthode title, donc j'écris *"un mooc sur python"*. Comment est-ce que j'appelle cette méthode ? Simplement en mettant un point title. Exécutons cette méthode et regardons le résultat. En fait, cette méthode title va simplement mettre chaque mot avec la première lettre en majuscule. J'ai également une méthode replace donc pour ça, je vais écrire s égale 'le poulet... alors comme j'ai une apostrophe, je vais l'entourer par des guillemets, je vais écrire "le poulet c'est bon". Donc vous voyez ici l'intérêt d'avoir la notation guillemets et apostrophes, c'est de pouvoir par exemple mettre une apostrophe dans une chaîne de caractères en l'entourant par des guillemets sans avoir à mettre un backslash devant, une barre oblique inversée. Donc j'écris: s égale "le poulet c'est bon" et je peux maintenant faire un replace de poulet par spam. Et regardons, j'obtiens une nouvelle chaîne de caractères qui va être "le spam c'est bon". Évidemment, comme c'est un nouvel objet chaîne de caractères puisque les chaînes de caractères sont immuables, je peux réaffecter le retour de cette méthode sur les chaînes de caractères à ma chaîne de caractères s pour obtenir une chaîne de caractères référencée par s qui référence "le spam c'est bon".

J'ai ensuite, sur les chaînes de caractères, un certain nombre de méthodes qui me permettent de faire des **comparaisons**, ou de faire des **tests**. Regardons un exemple. J'ai une chaîne de caractères qui représente un entier qui est 123, et avant de le convertir, je pourrais vouloir m'assurer que cette chaîne de caractères représente bien un nombre décimal. Et bien, je peux faire ça avec la méthode **isdecimal** qui va simplement me retourner vrai si la chaîne de caractères représente un nombre décimal, et faux sinon. Encore une fois, je vous invite à regarder l'intégralité des méthodes qui existent sur les chaînes de caractères puisque ces méthodes sont très puissantes et très souvent, répondent aux besoins que vous avez de manipulation de ces chaînes.

Pour finir, regardons comment formater une chaîne de caractères. Je vais prendre l'exemple suivant : je vais écrire n égale le prénom Sonia et je vais écrire age égale 30. Et maintenant, j'aimerais écrire "Sonia a 30 ans". En Python, on utilise pour cela ce qu'on appelle l'instruction format qui permet de formater une chaîne de caractères en fonction de certaines variables. Je vais écrire accolade accolade point format de n virgule age, et que va faire l'instruction format ? Elle va substituer le premier argument que je lui passe, n, à la première accolade, et le deuxième argument que je lui passe, age, à la deuxième accolade. Ça me permet donc d'obtenir une chaîne de caractères qui est sonia 30. Revenons sur cette chaîne de caractères, "sonia" je vais écrire un tout petit peu plus de texte "a Et on remarque qu'il y a une petite limitation à ce format, c'est que ce n'est pas complètement expressif puisque j'écris des accolades vides avec ensuite point format. 

Depuis Python 3.6, il est possible de créer ce qu'on appelle des **f-strings**. C'est quelque chose d'extrêmement pratique et qu'on vous recommande d'utiliser systématiquement. Je mets simplement un f devant ma chaîne de caractères et entre les accolades, je vais mettre la variable que je veux substituer. Donc ici, je vais mettre n, et ici, je vais mettre age. Le résultat de l'évaluation de cette chaîne de caractères va être "sonia a 30 ans", j'ai maintenant une chaîne de caractères totalement expressive. 

# W2-S2-2  Les chaînes de caractères (suite)

Parlons maintenant du support Unicode en Python 3 Donc à ce propos je vous fais remarquer que le support natif d'Unicode n'existe qu'en python 3 et pas en python 2, c'est une excellente raison de passer à Python 3. Donc regardons un exemple de chaîne de caractère en python. Donc je vais écrire une chaîne de caractères comme par exemple Noël, été ... non je recommence été, voilà. Donc là j'ai une chaîne de caractère avec des caractères accentués avec un ë et des é accents et on voit que cette chaîne est parfaitement supportée par Python. Donc lorsque je veux rentrer le caractère avec mon clavier si j'ai une méthode de saisie par le clavier pour rentrer mon caractère je peux le rentrer directement à l'aide du clavier mais je peux également rentrer le caractère Unicode avec la notation \u. 

Donc regardons par exemple un caractère Unicode "\u03a6" qui est un code qui correspond à un caractère dans le jeu de caractères Unicode et je veux obtenir la lettre Phi. Regardons maintenant un 2ème caractère "\u0556" qui correspond à la lettre arménienne Feh. Exécutons et regardons ce que je vois. Je vois en fait un rectangle vide à la place de mon caractère. En fait quel est le problème ici ? le problème c'est que j'utilise une police de caractères qui ne supporte pas ce caractère. Donc il faut comprendre qu'en fait lorsque l'on parle d'Unicode, nous avons un jeu de caractères qui supporte l'intégralité des caractères du monde mais pour afficher ce caractère sur votre écran vous avez besoin d'une police de caractères qui est capable de dessiner un glyphe correspondant à ce caractère. Donc ici ma police de caractères ne le supporte pas, par contre j'ai une police de caractères qui le supporte. Donc pour se faire je vais aller dans mon interpréteur et je vais prendre une police qui s'appelle 'DejaVu Sans mono" C'est une police qui est connu sous Windows pour supporter un grand nombre de caractères et donc ici je vois maintenant mon fameux caractère je remets mon interpréteur en plein écran, mon fameux caractère \u0556 correspond bien maintenant à la lettre arménienne Feh.

Revenons maintenant à la notion de codage et de décodage, je vous rappelle que sur votre ordinateur vous avez un flux de bits que vous pouvez avoir à lire lorsque vous lisez ce flux de bits, vous devez décoder ce flux de bits pour obtenir les lettres et de manière inverse lorsque vous voulez écrire ces lettres sur un disque dur ou les envoyer sur internet c'est-à-dire les transformer en flux de bits vous devez les encoder. En fait cette opération de décodage et d'encodage a été rendue extrêmement simple en python. Dès que vous manipulez des chaînes de caractères en Unicode vous utilisez le type 'str'. Dès que vous manipulez des flux de bits vous utilisez **le type bytes** et python vous permet de très facilement passer des chaînes de caractères en bytes et des bytes aux chaînes de caractères.

Regardons un exemple : s = "un noël en été", j'ai donc une chaîne de caractères Unicode qui contient des caractères accentués donc je fais un print() de s, je vois bien la chaîne de caractères. Maintenant si je veux encoder ma chaîne de caractère en bytes, j'utilise une méthode sur les chaînes de caractères qui est **la méthode encode**. Je vais utiliser encode, je vais donner l'encodage que je veux utf-8, je vous rappelle que par défaut on utilise toujours utf-8 sauf si on a une très bonne raison de faire autrement mais en général on n'a pas de très bonnes raisons de faire autrement et donc là je vais obtenir un nouvel objet, remarquez ce nouvel objet : c'est une chaîne de caractères qui commence avec un petit b et ensuite qui contient des caractères particuliers. En fait le type bytes va contenir uniquement des octets, c'est-à-dire des octets codés sur 8 bits et python vous offre la possibilité que lorsque l'octet représente un caractère ASCII qui a un affichage sous forme de lettre ou sous forme de chiffre, il va vous afficher cette lettre ou ce chiffre. Cependant c'est juste une facilité et python va bien coder les bytes sous forme d'octet et non pas sous forme de caractère. Donc maintenant j'ai ma chaîne de caractères qui a été encodée donc je vais l'appeler 'en', voici ma chaîne de caractères je peux maintenant la décoder pour repasser au type 'str', au type chaîne de caractères Unicode. Donc je vais faire un decode() et là encore je vais lui passer le codec que j'utilise qui est utf-8 ... ... et donc je vais ré-obtenir ma chaîne de caractère. Evidemment vous pouvez utiliser d'autres type d'encodage. Donc regardons un autre exemple, je reprends ma chaîne de caractères s et je peux très bien l'encoder en latin1 qui est un autre encodage et de même je pourrais la décoder en latin1.
Ce qui est très important c'est de ne jamais mélanger les encodages et les décodages. C'est pour ça qu'on vous recommande de **toujours utiliser utf-8** qui a la caractéristique importante d'être un encodage qui supporte Unicode.

En résumé, les principaux problèmes qui existent aujourd'hui avec l'encodage et le décodage ne sont pas liés au jeu de caractères puisqu'on a Unicode, ils sont quasiment toujours liés au fait que la personne qui développe le code ne vous communique pas le bon encodage utilisé. Par conséquent c'est pour cela qu'on vous recommande toujours d'utiliser utf-8 de toujours exactement contrôler votre encodage donc de bien encoder et décoder les chaînes de caractères et de toujours dire à la personne ou aux personnes qui vont utiliser votre code quel type d'encodage vous utilisez.


A bientôt...



# W2-S3 Les séquences

Dans cette vidéo, nous allons parler d'un ensemble de types qu'on appelle les **séquences**. Les séquences en Python regroupent notamment les listes, les tuples, les chaînes de caractères et les bytes. Nous verrons qu'elles regroupent également encore plus de types que cela. Ouvrons maintenant un interpréteur Python pour commencer à jouer avec les séquences.

Une séquence en Python est un ensemble fini et ordonné d'éléments, indicés de 0 à n - 1 si j'ai n éléments. Prenons un exemple de séquence et commençons avec une chaîne de caractères. Voici une chaîne de caractères. Sur les séquences, je vous rappelle que la chaîne de caractères est juste un exemple de séquence mais que les listes par exemple, ou les tuples, sont également des objets séquences. Regardons un exemple d'opération que je peux faire, commune à toutes les séquences.

Je peux déjà commencer par accéder à chaque élément de la séquence, avec la notation crochets. s[0] me permet d'accéder au premier élément de la séquence, puisque, je vous le rappelle, les séquences sont numérotées à partir de 0. s[9] va me permettre d'accéder au dernier élément de ma séquence puisqu'ici, ma séquence a 10 éléments. D'ailleurs, à ce propos, comment je fais pour connaître le nombre d'éléments dans une séquence ? J'utilise la fonction **built-in len**. Donc je fais un len(s) et ça va me retourner que j'ai effectivement dix éléments dans ma séquence.

Toutes les séquences supportent également **le test d'appartenance**, c'est une opération très puissante en Python puisque je peux faire : est-ce que 'egg' in s et ça va me retourner vrai, effectivement, la chaîne de caractères 'egg' est dans la chaîne de caractères 'egg, bacon'. De même, je peux faire 'egg' not in s, qui est le test de non appartenance, et qui va me retourner faux, puisque, effectivement, 'egg' est dans la chaîne de caractères donc le test : n'est-il pas dans la chaîne de caractères ? retourne faux. Donc ce test d'appartenance, vous remarquez qu'il est extrêmement expressif, puisque c'est quasiment du langage naturel. Je regarde est-ce que ma chaîne de caractères egg in s, est-ce que ma chaîne est dans s.

Ensuite, je peux faire de la **concaténation** de séquences. Regardez ma séquence s, je peux très bien lui rajouter la chaîne de caractères 'and beans'. Et cette concaténation va me produire une nouvelle chaîne de caractères puisque les opérations sur les séquences ne les modifient pas, puisque typiquement une chaîne de caractères n'est pas mutable, mais ça retourne un nouvel objet, dans ce cas-là, un nouvel objet de type chaîne de caractères.

J'ai également des opérations comme par exemple **index()**, qui me permet de trouver la première occurrence par exemple de la lettre g. Effectivement, la première occurrence de la lettre g, c'est à la place 1. Ou par exemple, **count()** qui me permet de compter le nombre d'éléments, le nombre de g que j'ai dans ma séquence. Donc ici, on voit que j'ai 2 fois la lettre g.

Je peux également appliquer les fonctions **built-in min() et max()**, qui me retournent le minimum et le maximum de ma séquence. Dans ce cas-là, comme c'est une chaîne de caractères, c'est en utilisant l'ordre lexicographique.

Et j'ai une dernière opération qui est l'opération de **shallow copy** qui me permet de faire... alors, je vais prendre une séquence plus simple, par exemple, un x, et je veux afficher 30 x à mon écran, je vais faire x fois 30 et ça va me faire une copie 30 fois de cette chaîne de caractères 'x'. Nous verrons dans la suite que cette opération produit en fait une shallow copy qui peut avoir des effets de bord lorsque la séquence multipliée n'est pas un immuable mais un objet de type mutable. Mais nous reviendrons sur ça dans la suite.

Nous allons maintenant regarder une dernière opération très importante sur les séquences qui s'appelle l'opération de **slicing**. Pour illustrer cette opération de slicing, qui est valable pour toutes les séquences donc pour les chaînes de caractères puisque c'est l'exemple que l'on va regarder mais également pour les listes, je vais créer une chaîne de caractères qui s'appelle 'egg, bacon' et donc ici, je vous représente la chaîne de caractères avec l'indice de chaque élément. On voit que e, c'est l'élément d'indice 0, g, l'élément d'indice 1, le deuxième g, l'élément d'indice 2, etc... Je vais maintenant faire une opération de slicing. L'opération de slicing se note de la manière suivante : on va mettre une borne de gauche, deux points, une borne de droite. La borne de gauche, en vert, est incluse et la borne de droite est exclue. Donc ici, s[0:3] va me retourner tous les éléments qui vont entre 0 inclus et 3 exclu, donc c'est 2 ; ça va donc me retourner la chaîne de caractères 'egg'. Il est très important de comprendre que l'opération de slice retourne à chaque fois un nouvel objet. Prenons un deuxième exemple, s[5:10], ça va me retourner tous les éléments allant de 5 inclus à 10 exclu, 10 moins 1, ça fait 9, ça va donc me retourner la chaîne de caractères 'bacon'.Si je fais s[ :3], si vous ne spécifiez pas la borne de gauche, vous allez parcourir tous les éléments du début jusqu'au 3 exclu, ça va donc me parcourir tous les éléments allant de e jusqu'à 3 exclu, c'est 2, ça va vous retourner la chaîne de caractères 'egg'. Et si vous ne spécifiez pas la borne de droite, ça va vous retourner tous les éléments allant de 5 jusqu'à la fin, donc ça va vous retourner 'bacon'. Pour finir, si vous ne spécifiez ni la borne de gauche, ni la borne de droite, ça vous retourne la chaîne de caractères mais c'est important : cette opération de slice ne va pas vous retourner la chaîne de caractères elle-même, ça va vous retourner une copie de cette chaîne de caractères. En fait, nous verrons dans la suite qu'on appelle cette opération une opération de **shallow copy**.

Maintenant, prenons un autre exemple. On va rajouter à notre slice la notion de pas. Dans un slice, on peut donner une borne de droite, une borne de gauche et également un pas, c'est-à-dire, on va parcourir les éléments un sur deux si on donne un pas de deux. Regardons cet exemple : s, de 0 à 10 par pas de 2, ça veut dire qu'on va parcourir les éléments allant de 0 à 10 exclu par pas de 2. Donc e, g, l'espace, a, o. Ça me retourne donc la chaîne de caractères 'eg ao'. Maintenant, prenons s[ : :2]. Ça me parcourt tous les éléments allant du début à la fin par pas de 2. Ça va me retourner 'eg ao' de nouveau. Si maintenant je fais s[ : 8 : 3], ça parcourt tous les éléments du début jusqu'à 8 exclu par pas de 3. Ça va donc me retourner 'e,a'. Et si je fais s[2 : : 3], ça me parcourt tous les éléments de 2 jusqu'à la fin par pas de 3, 'gbo'.

Regardons maintenant cet exemple. Qu'est-ce qu'il se passe si je fais s[100] ? s[100], c'est un indice qui est en dehors de ma chaîne de caractères, je vais donc avoir une erreur qu'on appelle une **exception**. Mon exception, comme toujours en Python, est très explicite ; elle s'appelle **IndexError** et elle m'écrit le message d'erreur : string index out of range, ça veut dire que l'indice de ma chaîne de caractères est en dehors des indices couverts par cette chaîne. Par contre, si maintenant, je fais s[5:100], je vais obtenir tous les éléments qui vont de 5 jusqu'à la fin de la chaîne de caractères. Pourquoi est-ce que dans ce cas-là je n'ai pas d'erreur ? Parce qu'en fait, le slice est un objet et Python va faire l'opération suivante : il va prendre tous les indices couverts par le slice, donc les indices allant de 5 à 100, et il va chercher l'intersection avec les indices disponibles dans notre objet chaîne de caractères. Et il va retourner uniquement les éléments qui sont à l'intersection. Ici on voit que l'intersection est non nulle, c'est 'bacon', il me retourne 'bacon'. Si je fais un slice de 100 à 200, dans ce cas-là, les indices représentés par le slice et les indices représentés par ma chaîne de caractères n'ont pas d'intersection, donc mon slice va me retourner un objet, toujours de type chaîne de caractères mais qui est vide.

Pour finir avec les chaînes de caractères, nous allons parler des **indices négatifs**. Regardons cet exemple-là. Les indices négatifs, c'est comme les indices positifs sauf qu'ils sont numérotés à partir de la fin. C'est donc un moyen très commode d'accéder aux derniers éléments d'une séquence lorsqu'on sait leur position à la fin de la séquence. Donc s[-10:-7] va me retourner tous les éléments allant de -10 inclus jusqu'à -7 exclu. Dans ce cas-là, on va aller de -10 à -8, ça me retourne 'egg'. Ce n'est pas parce que j'ai des indices négatifs que je parcours ma séquence dans un autre sens ; je parcours toujours ma séquence de la gauche vers la droite. Si je fais s[:-3], ça me retourne tous les éléments allant du début jusqu'à -3 exclu, c'est-à-dire -4, ça va me retourner 'egg, ba'. Et si maintenant je fais s[ : :-1], le pas étant négatif, cette fois, ça va parcourir ma séquence dans le sens inverse, de la droite vers la gauche. C'est donc une notation qui est très souvent utilisée pour renverser une séquence. Donc s[ : : -1] va me retourner ma séquence et l'afficher dans l'ordre inverse. Si maintenant, je fais s[2 : 0 : -1], ça va m'inverser ma séquence et prendre un sous-ensemble allant de droite à gauche, donc allant de 2 inclus jusqu'à 0 exclu, ce qui va me retourner la sous-chaîne 'gg'. Si je fais s[2 : : -1], ça me retourne ma séquence en allant de 2 jusqu'au début.

Dans cette vidéo, nous avons vu les principales caractéristiques des objets qui sont regroupés dans l'ensemble des séquences, sous le nom de séquences. On a vu le test d'appartenance: in, not in ; on a vu qu'on pouvait accéder aux éléments d'une séquence avec la notation crochets ; et surtout, nous avons vu la notion très importante de slice qu'il est important de maîtriser puisque vous aurez à manipuler de nombreuses séquences dans vos programmes Python.

À bientôt !


# W2-S4 Les listes


Dans cette vidéo, nous allons parler des listes en Python. La liste représente un type extrêmement souple et puissant.

Une **liste** est une séquence d'objets hétérogènes. Une liste peut absolument stocker n'importe quels types d'objets mais il est important de comprendre que la liste ne stocke pas les objets mais ne stocke que des **références** vers ces objets. Par conséquent, la taille de l'objet liste est indépendante du type d'objets qui sont référencés. Une liste peut augmenter en taille, peut réduire ; on peut l'écarter au milieu, rajouter des éléments à l'intérieur, on peut vraiment complètement la manipuler c'est très malléable. En fait, la liste est malléable parce que c'est **un objet mutable**. Et cette notion de **mutabilité** est importante à comprendre. Un objet mutable, c'est un objet que l'on peut modifier en place. Ça veut dire que l'on peut modifier là où il est stocké. L'avantage de cette mutabilité, c'est que on n'a pas besoin de faire une copie de l'objet pour le modifier. C'est donc extrêmement efficace au niveau mémoire. Ouvrons maintenant un interpréteur Python pour commencer à jouer avec les listes.

Je vous rappelle qu'**une liste est une séquence**. Par conséquent, toutes les opérations que l'on a vues sur les séquences sont applicables aux listes : le test d'appartenance, la concaténation, la fonction built-in len, count, index, toutes ces opérations sont disponibles pour toutes les séquences, donc en particulier pour les listes. Maintenant, créons un objet liste vide. Pour cela, pour définir une liste, on utilise les crochets ouvrant et fermant. J'ai donc créé un objet liste qui est vide. Je peux le vérifier en utilisant la fonction built-in type et vérifier le type de cet objet, c'est bien un objet de type liste. Dans une liste, je peux stocker absolument n'importe quel type d'objet. Prenons un entier qui vaut 4, et créons maintenant une nouvelle liste qui va réferencer ma variable, enfin mon entier référencé par la variable i, la chaîne de caractères 'spam', un float et un booléen. Donc on voit que j'ai vraiment 4 objets complètement différents, et d'ailleurs le premier objet est même référencé par une variable. Et tout cela fonctionne parfaitement ; je peux afficher ma liste et je vois bien qu'elle référence l'entier 4, la chaîne de caractères 'spam', le float 3.2 et True. Je vous rappelle que la liste ne stocke pas ces objets, elle ne stocke que des références vers ces objets. C'est par conséquent extrêmement efficace. Une liste en particulier ne va jamais copier les objets qu'elle référence. Comme ma liste est une séquence, je peux donc accéder à chaque élément de ma liste, donc, par exemple, le premier élément de ma liste va être l'entier 4. Ma liste étant mutable, je peux modifier ce premier élément ; donc je peux par exemple dire: a[0] égale 6 ; maintenant, je vois que ma liste contient 6, 'spam', 3.2 et True, et je peux également faire directement une opération sur un élément d'une liste ; par exemple, a[0] égale a[0] plus 10. Je vais donc ajouter 10 au premier élément de ma liste et je vois que maintenant, j'obtiens: la liste : 16, 'spam', 3.2 et True.


Sur ma liste, je peux également faire des opérations de **slicing**, donc si je prends a[1 : 3], ça va me prendre tous les éléments allant de 1 inclus à 3 exclu, c'est-à-dire à l'élément 2, ça va me retourner: 'spam', 3.2. Et je peux même faire des opérations d'affectation sur des slices. Alors, ça, c'est quelque chose d'un peu particulier, qu'on va prendre le temps d'expliquer. Regardez, j'écris a[1 : 3] égale la liste 1, 2, 3 et regardons ce qu'il se passe. Lorsque j'exécute cela, je vois que ma liste a été modifiée d'une manière un peu curieuse. L'affectation sur un slice va effectuer deux opérations indépendantes. La première opération, lorsque je fais a[1 : 3], c'est d'enlever tous les éléments qui vont de 1 inclus à 3 exclu, donc d'enlever tous les éléments sur le slice. La deuxième opération va consister à insérer les éléments qui sont dans la séquence de droite, donc dans ce cas-là, 1, 2, 3, à la place des éléments qui ont été effacés. Dans notre exemple, j'ai effacé les éléments 'spam', 3.2, et j'ai ajouté à la place les éléments 1, 2, 3. On voit donc qu'une liste est extrêmement flexible puisqu'on peut effacer des éléments au milieu, en rajouter, la liste va automatiquement s'étendre ou alors se contracter en fonction de ce qu'on ajoute au milieu. Cette opération d'affectation sur un slice, c'est un moyen très simple d'effacer des éléments dans une liste, si je fais a[1 : 3], et que je lui affecte une liste vide, je vais effacer tous les éléments qui sont entre 1 et 3, et comme je ne remets rien à la place, ces éléments vont être simplement effacés. Je peux également utiliser l'instruction del pour enlever des éléments dans un slice donc regardons cet exemple: del a[1 : 2] va m'effacer l'élément à l'indice 1. Je regarde ma séquence et effectivement, l'élément 3 a été effacé.

Il existe un grand nombre d'opérations sur les listes. Regardons toutes ces opérations qui sont disponibles sur les listes. Pour ça, je vous rappelle qu'on peut utiliser la fonction built-in dir qui me permet de lister toutes les méthodes sur un objet. **dir(list)** va m'afficher toutes les méthodes sur un objet liste. J'oublie les méthodes avec des __ et je ne regarde que celles qui n'ont pas de __. Je vois par exemple que j'ai une méthode qui s'appelle **append**. Regardons, avec l'aide intégrée à Python, exactement ce que veut dire append. Dans IPython, je peux juste rajouter un point d'interrogation. Si vous n'utilisez pas IPython, c'est totalement équivalent d'écrire help(list.append). Ça va vous donner la même aide. Mais évidemment, on comprend bien que dans IPython, c'est plus rapide de taper le point d'interrogation. Que fait append ? append rajoute un objet à la fin de la liste. Reprenons ma liste a, qui est égale à 16, True. Si je fais a.append('18'), de la chaîne de caractères '18', - je recommence - je vais voir que j'ai rajouté la chaîne de caractères '18' à la fin de ma liste.

Je peux également utiliser l'opération **extend** qui va prendre une séquence, 1, 2, 3, et qui va ajouter chaque élément de cette séquence à la fin de ma liste. En fait, c'est comme si on faisait un append sur chaque élément de la séquence. J'ai mis une parenthèse, vous pouvez remarquer cette erreur qui s'appelle **SyntaxError** qui est juste une erreur de syntaxe ; en général, les erreurs de syntaxe c'est lorsque j'écris mal mon code, j'oublie de fermer une parenthèse, ou je remplace une parenthèse par un crochet comme je l'ai fait ici. Je recommence. Voilà, ma parenthèse est à la fin. Je regarde ma liste, et ma liste a bien été étendue des éléments que j'avais dans ma séquence 1, 2, 3.

J'ai également des opérations qui me permettent de trier une liste. Dans ce cas-là, prenons une liste de nombres : 1, 5, 3, 1, 7, 8, 9 et 2, voilà ; Je peux appeler **la méthode sort** sur ma liste et cette méthode sort va trier les éléments de ma liste, attention, sort fonctionne en place, ça veut dire que ma liste a été triée en place sans faire de copie temporaire, et la méthode sort ne retourne rien puisque l'objet a été trié en place. Maintenant, je vois bien que ma liste a a été modifiée. Ne faites jamais d'opération d'affectation sur la méthode sort parce que la méthode sort va vous retourner l'objet None, et par conséquent, si je fais a égale a.sort(), maintenant, ma variable a va référencer non plus la liste que j'ai triée mais simplement la valeur de retour de sort qui ne sert à rien, qui est juste l'objet None, l'objet vide.

Une dernière opération très importante à voir sur les listes, c'est l'**opération qui permet de passer d'une chaîne de caractères à une liste** et d'une liste à une chaîne de caractères. C'est quelque chose que vous utiliserez très régulièrement si vous accédez à des fichiers et que vous voulez les traiter avec Python. Regardons comment cela se passe en Python. Je crée une chaîne de caractères s, qui va contenir un mot, spam, et un deuxième mot, egg et un troisième, beans. Ce que j'aimerais faire, imaginons que cette chaîne de caractères soit le résultat de la lecture d'un fichier, j'aimerais séparer cette chaîne de caractères en colonnes ; obtenir la première, la deuxième et la troisième colonnes. En Python, c'est très simple de faire ça, on utilise la fonction **built-in split**, qui est une fonction des chaînes de caractères. Le résultat de cette fonction built-in, c'est de découper ma chaîne de caractères en utilisant l'espace comme séparateur. Regardons le résultat, j'obtiens une liste qui contient trois éléments: 'spam', 'egg' et 'beans'. À **split**, je peux lui passer n'importe quel caractère de séparation ; par exemple, si ma chaîne de caractères avait été formattée avec des virgules qui séparent les mots, j'aurais pu passer à split la chaîne de caractères ',' pour découper en fonction de cette virgule. Une fois que j'ai ma liste, ma liste étant mutable, je peux tout à fait faire a[0] égale a[0].upper(), c'est-à-dire que je mets en majuscule le premier élément. Et ensuite, je peux retransformer ma liste en chaîne de caractères avec la syntaxe suivante: cette syntaxe est un tout petit peu particulière en Python, je commence par écrire la chaîne de caractères séparateur, qui va être mise entre chaque élément de ma liste, et ensuite je fais un **join(a)**. Évidemment, ma chaîne de caractères peut être absolument n'importe quoi comme séparateur. Si je fais: espace.join(a) j'obtiens une nouvelle chaîne de caractères qui maintenant contient SPAM en majuscule, egg et beans.

En résumé, nous avons vu dans cette vidéo le type liste, qui est un type extrêmement puissant et central en Python. Comme je vous l'ai expliqué en introduction, cet objet est mutable, extrêmement flexible, on peut ajouter des choses au milieu, l'écarter, il peut référencer n'importe quels types d'objets, il est par conséquent vraiment le type qui est au coeur de tous vos programmes Python. Il est donc important de bien le maîtriser, et d'être capable de le manipuler de manière aisée.



À bientôt !



# W2-S5 Introduction aux tests if et à la syntaxe 

Nous avons déjà vu un certain nombre de notions importantes. Nous avons vu la notion d'objet, les notions de variable, de typage dynamique, puis nous avons vu des types centraux en Python, comme les chaînes de caractères ou les listes, et les opérations que l'on peut effectuer sur les séquences. Mais vous pouvez peut-être vous demander comment je fais pour écrire de vrais programmes ? En fait, pour écrire de vrais programmes, il faut maîtriser d'autres notions comme par exemple les tests, les modules, les boucles for, les fonctions. Pour vous permettre, dès cette semaine, de commencer à écrire de vrais programmes, nous allons faire un survol rapide de ces différentes notions clés à l'écriture de vrais programmes.

Dans cette vidéo, je vais vous parler de l'instruction **if else**, qui permet de faire de l'**exécution conditionnelle**, c'est-à-dire qu'un morceau de votre code va s'exécuter en fonction du fait qu'un test soit vrai ou qu'un test soit faux. Par exemple, dans une instruction if else, vous pouvez tester si quelque chose est supérieur ou supérieur ou égal à quelque chose d'autre, vous pouvez tester inférieur ou inférieur ou égal, vous pouvez tester l'égalité ou la différence, l'égalité étant le double signe égal et la différence étant notée par point d'exclamation égal, et vous pouvez également faire des tests d'appartenance. En fait, dans un if, vous pouvez mettre n'importe quel type d'expression mais nous reviendrons sur ça lorsque nous détaillerons le fonctionnement précis de l'instruction if else. Maintenant, prenons un exemple de test if else.

Supposons que vous vouliez afficher un message si vous avez une note qui est supérieure à 10 sur 20. Prenons cet exemple ; je commence par définir une variable note qui vaut l'entier 8. Puis je vais écrire mon instruction if. Mon instruction if s'écrit de la manière suivante: j'écris if, c'est l'instruction, une expression, là, mon expression, c'est note supérieure à 10, et un : Ensuite je vais écrire un bloc d'instructions print('reçu'); print('bravo !') puis je peux écrire une condition supplémentaire, c'est-à-dire que si mon if est faux je rentre dans la clause else. Donc après le else, j'ai un : et là encore, j'ai un bloc d'instructions print('recalé').

Revenons maintenant sur cette syntaxe. Vous remarquez que j'ai un : . Vous avez systématiquement un : avant un **bloc d'instruction** mais qu'est-ce que c'est, un bloc d'instructions ? Un bloc d'instructions, c'est un ensemble d'instructions qui sont toutes indentées du même nombre de caractères vers la droite : la convention est d'indenter tous les blocs d'instructions de 4 caractères vers la droite.
Si mon test if est vrai, je vais exécuter les instructions qui sont dans le bloc d'instructions, donc dans ce cas-là, si la note est supérieure strictement à 10.
Si jamais ce test est faux, je vais rentrer dans ma clause else qui est elle aussi suivie par un : et je vais exécuter le bloc d'instructions qui est dans ma clause else. Là encore, mon bloc d'instructions c'est toutes les instructions qui sont décalées de 4 caractères vers la droite. Python est un langage qui est conçu autour de cette notion de bloc d'instructions. Et c'est quelque chose qu'il est très important de bien comprendre. Dans un certain nombre de langages, vous n'avez pas cette notion de blocs d'instructions mais les blocs d'instructions sont délimités par exemple par des accolades.

Regardons un exemple. Voici un même test if else que l'on vient d'écrire mais avec une syntaxe qui pourrait être une syntaxe, par exemple, à la Java. Toutes mes instructions finissent par un ; pour déterminer la fin de l'instruction, et mes blocs d'instructions sont séparés par des accolades ouvrantes et des accolades fermantes. Cela constitue un problème connu en programmation, puisque, pour être capable de savoir où placer les accolades, on définit ce qu'on appelle des **conventions de codage**. La convention de codage n'a absolument aucun impact sur l'exécution de mon code, elle est simplement là pour faciliter la lecture et l'écriture du code. Or, ces conventions de codage font partie d'écoles de programmation, et certaines personnes préfèrent certaines conventions de codage, par exemple mettre les accolades en fin de ligne et en début de ligne, ou alors mettre les accolades alignées avec les instructions. En fait, vous vous rendrez compte, si vous programmez dans d'autres langages que Python, que lire un code écrit avec une convention de codage qui n'est pas la vôtre rend extrêmement difficile l'interprétation ou la lecture de ce code.

En Python, vous n'avez pas ce problème puisque **la convention de codage fait partie de la syntaxe**. Si vous ne respectez pas la convention de codage, vous aurez une erreur de syntaxe donc votre code ne s'exécutera pas. L'avantage de ça, c'est qu'en Python, vous n'avez qu'une seule manière de présenter votre code. Regardons cela. Ici, j'ai un code avec des accolades et des points virgules à la manière de Java. En Python, vous supprimez tout ce qui est point virgule, la fin d'une instruction, c'est le retour chariot, vous supprimez tout ce qui est accolade les blocs d'instructions sont tous décalés de 4 caractères vers la droite, et vous n'avez que ce fameux symbole ':' . Vous pouvez vous demander mais pourquoi est-ce que je garde quand même le : ? En fait, vous gardez le : parce que ce : a été l'objet de tests utilisateurs et on s'est rendu compte que pour les utilisateurs, c'était plus facile de détecter qu'il y avait des blocs d'instructions lorsqu'ils étaient précédés d'un : Le fait que **Python utilise l'indentation** comme base de sa syntaxe n'a presque que des avantages ; ça vous permet d'avoir un code écrit toujours de la même manière, extrêmement bien présenté, facile à lire, facile à écrire.

Il a cependant un seul inconvénient, c'est que cette convention, cette syntaxe qui est basée sur l'**indentation ne supporte pas très bien le copier-coller**. Par conséquent, ma recommandation est lorsque vous copiez-collez du code, par exemple, que vous récupérez d'internet ou d'autres morceaux de code, vous devez toujours très attentivement vérifier que l'indentation respecte ce que vous voulez faire.

Ensuite cette convention de codage qui décale les blocs d'instructions de 4 caractères vers la droite a la tendance à créer des lignes qui sont un petit peu grandes. En Python, on vous recommande de **ne pas dépasser 79 caractères sur une seule ligne** ; l'idée est de pouvoir, même si aujourd'hui on a des écrans très grands, de pouvoir mettre plusieurs éditeurs l'un à côté de l'autre, et puis de toute manière, c'est plus facile de lire des lignes qui sont courtes que des lignes qui sont longues. En Python, on vous encourage à avoir **peu de niveaux d'imbrications de blocs de code** pour essayer de rester à ce niveau de 79 colonnes par fichier.

Pour finir, Python vous permet assez facilement de retourner à la ligne tout ce qui est entre parenthèses, entre crochets ou entre accolades supporte le retour chariot sans créer de problème dans la syntaxe de Python. Par exemple, si vous avez une grande liste ou un grand nombre d'expressions séparées par des parenthèses, vous pouvez très facilement faire un retour chariot, et votre éditeur vous permettra de bien aligner ces instructions tout en respectant la syntaxe des blocs d'instructions.



À bientôt !


# W2-S6 Introduction aux boucles for et aux fonctions

Un principe fondateur de la programmation est ce qu'on appelle la **factorisation du code**. C'est quoi, la factorisation du code ? C'est ce qui vous permet de ne pas réécrire plusieurs fois un code qui fait la même chose. L'intérêt de ça est évidemment de faciliter la maintenance et surtout la qualité de votre code. Nous allons voir dans cette vidéo les notions de **boucle for** et de **fonction**, qui sont deux techniques de factorisation de code.

Ouvrons maintenant un interpréteur Python pour commencer à jouer avec les boucles for et les fonctions. Supposons maintenant que je veuille simplement afficher à l'écran les carrés des nombres allant de 0 à 9. Donc je peux écrire print de 1 au carré, puis ensuite, je vais rappeler cette instruction je vais faire print de 2 au carré, puis ensuite je vais faire print de 3 au carré, et je peux continuer comme ça longtemps, vous vous rendez vite compte que c'est très fastidieux. En fait, comment est-ce que je peux automatiser cette tâche ? Je peux automatiser cette tâche avec, justement, **une boucle for**. L'intérêt de la boucle for est d'automatiser une tâche qui se répète. Regardons comment cela fonctionne.

Je vais écrire l'instruction *for* et je vais mettre une *variable i* et je vais dire qu'elle parcourt un objet, cet objet s'appelle range de 10. Nous reviendrons plus tard sur la signification exacte de cet objet, pour l'instant, sachez simplement range de 10 me permet de parcourir tous les entiers allant de 0 jusqu'à 9. Et ensuite j'écris un : pour définir un bloc d'instructions. Mon bloc d'instructions doit donc être décalé de 4 caractères vers la droite. Et ensuite, je vais faire un print de i au carré. Donc ici je me retrouve avec une boucle for qui va parcourir tous les entiers de 0 jusqu'à 9 c'est la variable i qui va référencer chacun de ces entiers à chaque tour de boucle et mon print de i au carré va m'afficher le carré de l'entier référencé par i au moment du tour de boucle. Regardons ce que j'obtiens: j'obtiens bien le carré des entiers allant de 0 jusqu'à 9. En fait, dans une boucle for, je peux mettre absolument n'importe quelle séquence. Nous verrons plus tard qu'en fait on peut mettre n'importe quel itérable. Donc je peux prendre par exemple une liste qui va contenir une chaîne de caractères 'a', un float et un booléen, et donc faire un print de i simplement, et je vais donc afficher chaque élément qui est contenu dans ma liste: la chaîne de caractères 'a', le float 3.5 et le booléen True.

Maintenant, reprenons notre exemple du carré. Supposons que je crée une liste a qui est égale à 1, 2, 5, 8, 9 ; et que je veuille obtenir les carrés de ces entiers. Je vais faire un for i in a : print de i au carré. Ça fonctionne exactement comme nous l'avons vu. Supposons maintenant que je prenne une deuxième liste b qui est égale à une autre suite de nombres, par exemple 3.6, 18, 12 et 25. Comment est-ce que maintenant je peux parcourir de nouveau cette liste ? En fait, je vais refaire une boucle for for in in b : print de i au carré. Ça fonctionne exactement comme précédemment. Cependant, vous remarquez quelque chose d'un peu fastidieux, c'est que j'ai deux fois exactement la même boucle for. C'est peu pratique, c'est peu commode de retaper cette boucle for de multiples fois.

Une manière de factoriser ce code, c'est d'utiliser ce qu'on appelle une **fonction**. Une fonction est un morceau de code que l'on peut rappeler n'importe quand. Regardons comment implémenter une fonction qui va justement faire cette boucle for. Je vais définir une fonction f, alors je vais même l'appeler carré, puisque c'est une fonction qui va parcourir les carrés, et je vais lui passer un argument, et ensuite je vais définir dans ma fonction carré une boucle for: for i in a : print de i au carré. Donc j'ai défini ma fonction carré et maintenant ma fonction carré je peux l'appeler directement sur ma liste a et je peux l'appeler directement sur ma liste b. Comment ça fonctionne ? En fait, lorsque je définis une fonction, je définis une fonction avec l'instruction **def**, je lui donne ensuite un nom, dans mon exemple, carré, je pourrai réutiliser ce nom à chaque fois que je veux appeler ma fonction et entre parenthèses, dans la définition, là où j'écris le def, je vais définir un argument et c'est l'argument que je vais être capable de passer à ma fonction lorsque je l'appelle. Donc, lorsque je fais un carré de b, la liste b est passée à ma fonction, nous verrons plus tard que c'est passé **par référence** donc je n'ai pas de copie d'objet, je passe simplement une référence de cette liste, et ma fonction carré va récupérer cette référence et être capable de faire un for i in l'objet qui est passé par référence à ma fonction, et donc je vais être capable de calculer le carré de ces entiers.

Revenons sur cette fonction. En fait, dans une fonction, on fait très rarement des affichages avec des print ; en fait, ce qui est utile dans une fonction c'est plutôt de faire des retours. Donc pour faire un retour, je vais écrire l'**instruction return** qui va me retourner le carré des entiers ; en fait, ce que je voudrais réellement retourner, c'est une liste qui contient le carré des entiers. Donc je vais définir une liste L qui est une liste vide, et, à chaque tour de ma boucle, je vais faire un L.append de i au carré. Et ensuite, mon instruction return va être alignée avec la boucle for, c'est-à-dire que mon return ne va s'exécuter qu'au moment où la boucle for a fini de faire tous ses tours. Reprenons cette fonction, je définis une fonction de nom carré qui prend un argument a ; ensuite ma fonction définit une liste vide et elle va faire une boucle for sur chaque élément de a ; à chaque tour de boucle, je vais ajouter à ma liste L le carré de l'élément parcouru sur a, donc i au carré, et quand ma boucle a terminé, je fais un return de L. Maintenant, je vais réexécuter ma fonction carré sur b, et je vais voir que ma fonction maintenant me retourne un objet liste qui contient le carré de chaque élément de b et je peux ensuite affecter ce résultat à ma variable b pour référencer maintenant la liste des carrés de b.

Nous avons vu dans cette vidéo deux notions essentielles à l'écriture de programmes et notamment à la factorisation de code, la boucle for et les fonctions. Nous reviendrons bien évidemment en détail sur ces notions dans de prochaines vidéos, mais avec ces notions, vous pouvez dès maintenant commencer à écrire de vrais petits programmes.


À bientôt !


# W2-S7 Introduction aux compréhensions de listes

Nous avons vu que les listes étaient au coeur de tous les programmes en Python. La liste est un objet extrêmement flexible, qui peut référencer n'importe quels types d'objets. Et une manière simple de parcourir les listes c'est d'implémenter une boucle for. Ainsi vous pouvez appliquer une opération à chaque élément de votre liste. Cette opération est tellement commune que Python a inventé une nouvelle expression qu'on appelle **compréhension de liste**, qui permet de manière extrêmement simple et intuitive d'appliquer une opération à chaque élément d'une liste et éventuellement d'ajouter une condition de filtre. Ouvrons maintenant un interpréteur Python pour commencer à jouer avec les compréhensions de listes.

Supposons que l'on souhaite prendre les logarithmes d'une liste d'entiers. Créons une liste d'entiers, j'écris a égale les entiers 1, 4, 18, 29 et 13. J'ai une liste de quelques entiers sur lesquels je veux calculer le logarithme. Commençons par importer le module math qui est le module qui contient la fonction logarithme. Et ensuite, essayons de mettre tous ces résultats à l'intérieur d'une nouvelle liste qui va contenir le logarithme des entiers. Je vais créer une nouvelle liste b qui est une liste vide et je vais faire un for i in a : b.append de math.log de i J'ai donc créé une boucle for qui va parcourir les éléments de a et qui va ajouter à la liste b le résultat de mon logarithme sur chaque élément de la liste. Maintenant, si je regarde ma liste b, je vois bien que ma liste b contient le logarithme de chaque élément. En fait, cette opération est extrêmement courante en Python, c'est pour ça qu'on a la compréhension de liste. Cette compréhension vous permet donc d'appliquer une opération à chaque élément d'une liste et de grouper ces résultats dans un nouvel objet liste.

Regardons comment écrire la compréhension On va voir que c'est quelque chose d'extrêmement intuitif qui est quasiment du langage naturel. Pour dire que j'ai une compréhension, je vais dire b égale, et je commence par écrire crochet ouvrant crochet fermant pour bien symboliser le fait que j'ai une liste. Et puis ensuite, je vais écrire l'expression que je veux appliquer à chaque élément de ma liste. L'expression que je veux calculer, c'est math.log de i Et ensuite, je vais dire que parcourt i : je prends i pour i dans a : for i in a. Ça veut dire que je vais calculer le logarithme de chaque élément de la liste a. Exécutons cela et regardons le résultat de ma liste b ; évidemment ma liste b contient ce nouvel objet liste qui contient le logarithme de chaque élément de a.

Maintenant, supposons que dans ma liste a, j'ai un nombre négatif. Ce qui est quelque chose qui en pratique peut arriver lorsqu'on récupère de vraies données, soit des erreurs de mesure, ou alors des données un peu corrompues. Ma liste maintenant contient un nombre négatif. Alors, comme j'ai un nombre négatif, je ne peux plus calculer le logarithme de -1 Comment est-ce que je peux m'en sortir avec une compréhension ? En fait, dans une compréhension de liste, je peux tout à fait rajouter un **test**. Regardons ce cas. Je reprends ma compréhension précédente donc je calcule le logarithme de i pour i qui parcourt a mais je vais rajouter un test uniquement if i supérieur à 0. Donc en fait, qu'est-ce que ça va faire ? Ça va créer un nouvel objet liste qui va être le résultat du logarithme appliqué à chaque élément de a uniquement si i est strictement positif. Exécutons cela, et je vois bien que ma compréhension de liste a fonctionné et a créé une liste qui contient le logarithme de tous les entiers qui sont contenus dans ma liste a du moment qu'ils sont strictement positifs.

Alors on pourrait croire avec ces exemples que les compréhensions de listes sont limitées au cas des calculs sur les entiers. En fait, pas du tout, une compréhension de liste vous permet d'appliquer n'importe quelle opération, n'importe quelle expression, n'importe quelle fonction, à n'importe quel type de séquence. Regardons un exemple avec par exemple des chaînes de caractères. Supposons que j'ai une liste de prénoms qui contienne des prénoms avec une mauvaise capitalisation. Je vais prendre 'Alice', 'eVE', 'sonia' et 'BOB'. C'est quelque chose de possible en pratique une liste qui contient des prénoms qui ont mal été entrés. Mon objectif, maintenant, est d'obtenir une liste qui contient les prénoms avec tous la même capitalisation, typiquement, les mettre tous en minuscule. Je peux faire ça avec une compréhension de liste de manière très simple. Je vais réécrire prenom parce je veux que ma variable prenom référence maintenant ce nouvel objet liste. Je mets mes crochets. Quelle opération je vais appliquer ? je vais donc avoir un prénom p qui est une chaîne de caractères et je vais lui appliquer la fonction lower qui permet de mettre une chaîne de caractères en minuscule, pour p dans ma liste de prénoms. Encore une fois, je lis: je vais obtenir une liste qui prend p en minuscule pour p qui parcourt ma liste de prénoms. J'exécute, je vois le résultat et j'ai bien obtenu ma liste de prénoms.

Nous venons de voir dans cette vidéo la notion de compréhension de liste. Il s'agit d'une structure qui permet d'implémenter des boucles avec des tests de manière extrêmement expressive et intuitive. Vous vous rendrez compte qu'à l'usage il est extrêmement facile d'écrire des compréhensions de listes et que les compréhensions de listes sont plus faciles à maintenir et à lire que les boucles for et les if. Évidemment, il va vous falloir un petit peu de pratique, c'est pourquoi je vous encourage dès maintenant à vous entraîner à écrire des compréhensions de listes.


À bientôt !



# W2-S8 Introduction aux modules 	


Dans cette vidéo, nous allons introduire la notion de **module**. Un module, c'est en fait un **fichier Python qui finit en .py**, un fichier Python normal, et lorsqu'on importe ce fichier avec l'instruction import, nous allons voir ça dans quelques secondes, ça va créer un objet module. Un module en fait contient un certain nombre de fonctions, d'opérations à effectuer et l'idée des modules, c'est de mettre des opérations similaires dans le même fichier. Donc en fait vous pouvez voir un module comme une sorte de boîte à outils que vous importez lorsque vous avez besoin de l'ouvrir. Ouvrons maintenant un interpréteur Python pour commencer à jouer avec les modules.

Nous allons commencer par importer **le module random**. Pour importer un module, on utilise l'**instruction import** suivie du nom du module. Maintenant que j'ai importé ce module, je peux faire un print de random et je vais voir qu'effectivement cet objet est un objet de type module. Maintenant, je peux accéder à tous les attributs de ce module avec la fonction built-in dir. Donc, si je fais un dir de random, je vais voir tous les attributs qui existent et vous vous souvenez que si l'attribut commence ou finit par un underscore, c'est un attribut que vous ne devez pas manipuler vous-mêmes, donc tous les attributs qui n'ont pas d'underscore ce sont les attributs que vous pouvez utiliser. Je peux avoir l'aide d'un module en utilisant la fonction **built-in help**. Si je fais help de random, je vais voir toute l'aide liée à random. On voit qu'il y a énormément d'aide. D'ailleurs, je vous fais remarquer que c'est assez rare en pratique d'utiliser l'instruction help, enfin, la fonction built-in help, directement sur un module, parce que ça fait beaucoup de texte, c'est beaucoup plus pratique de regarder ça directement sur internet, dans l'aide de Python. Mais par contre help est très utile lorsque vous voulez regarder le fonctionnement d'une méthode particulière d'un module.

Refaisons un dir de random. On voit qu'on a un certain nombre de méthodes, et maintenant, je vais regarder quel est le fonctionnement de la **méthode randint**. Je vais faire un random.randint et je veux voir l'aide. Si je suis sur IPython je mets un point d'interrogation, si vous n'utilisez pas IPython ou un notebook, écrivez la fonction built-in help. Et je vais voir l'aide de randint. Que fait randint ? Il me retourne un nombre au hasard choisi entre a et b en incluant a et b. Je vais maintenant appeler cette méthode sur mon module ; la notation, c'est point donc je donne le nom du module point le nom de la méthode à appeler, et je vais choisir un entier entre 1 et 100 et ça va effectivement me calculer un entier au hasard ; dans ce cas-là, c'est 45 ; et évidemment, chaque fois que je relance, j'ai un nouvel entier choisi au hasard. Python est livré avec un grand nombre de modules, c'est ce qu'on appelle **la librairie standard**, il y en a autour d'une centaine. Ces modules vous permettent de faire un grand nombre d'opérations courantes et l'avantage de la librairie standard, c'est qu'à chaque fois que vous installez Python sur une machine, vous avez la certitude que la librairie standard va venir avec cette installation de Python.

Regardons quelques opérations que l'on peut effectuer avec la librairie standard. On peut faire de la programmation parallèle ou de la programmation asynchrone, on peut faire de la persistance de données, une opération que l'on appelle sérialisation pour garder une copie des objets sur le disque dur, on peut faire de la communication sur internet, Python supporte quasiment tous les protocoles classiques sur internet, on peut formater les données et lire des formats spécifiques de données sur internet, on peut manipuler des fractions ou des nombres décimaux, on peut écrire des expressions régulières, gérer des dates et des calendriers, interagir avec le système de fichiers, créer des fichiers, des répertoires, parcourir des répertoires, on peut faire également de la compression de fichiers et on peut même écrire des interfaces graphiques.

Vous voyez donc que vous avez un grand nombre de modules qu'on appelle la librairie standard livrée avec Python mais Python a également des centaines de milliers de modules écrits par des groupes de développement ou alors par des individus que vous pouvez charger et importer dans votre programme. Nous verrons notamment dans ce MOOC une partie de la librairie utilisée pour la programmation scientifique, ce qu'on appelle le data-science, notamment les modules numpy et pandas.



À bientôt !
