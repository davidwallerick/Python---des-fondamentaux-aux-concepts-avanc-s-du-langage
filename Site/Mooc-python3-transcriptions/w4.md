# MOOC INRIA / UCA : Python 3 : des fondamentaux aux concepts avancés du langage

## Arnaud Legout et Thierry Parmentelat 

## Transcriptions des videos de la semaine 4 : fonctions et portée des variables

# W4-S1 Fonctions

 Bonjour,

Cette semaine, nous allons parler de l'**instruction while**, nous allons revenir sur l'**instruction if**, mais le gros morceau de la semaine sera le sujet des **fonctions**. Nous allons en particulier parler de la notion de **portée de variable** et nous allons voir comment modifier cette portée. Nous conclurons cette semaine en étudiant comment définir les paramètres d'une fonction et les différentes manières d'appeler une fonction.

Nous avons précédemment succinctement introduit **le fonctionnement des fonctions**. Dans cette vidéo, nous allons revenir sur ce comportement et voir comment définir une fonction. Ouvrons un interpréteur Python pour commencer à jouer avec les fonctions.

Regardons comment définir une fonction. Nous l'avons déjà vu, une fonction se définit avec l'instruction *def*, suivie du nom de la fonction, ici, je l'appelle simplement *f*, et je vais lui passer des arguments ; à une fonction, on peut lui passer un nombre quelconque d'arguments séparés par des virgule. Ensuite, je n'oublie pas le : qui signifie que je vais avoir un bloc de code, ça va être le bloc de code de la fonction : *def f(a, b, c):* Je fais un retour chariot, et ensuite, je peux simplement faire un *print(a, b, c)*. Donc j'ai une fonction *f* qui va simplement afficher ses trois arguments. Lorsque ce bloc de code est évalué, je vais créer un objet fonction et le nom de la fonction, *f*, va être une variable qui va référencer cet objet fonction. J'ai donc une variable *f* qui référence un objet fonction. Comme tous les objets en Python et comme toutes les variables en Python, une variable est simplement un nom qui référence un objet, je peux donc renommer mon objet fonction avec une autre variable en faisant une référence partagée. Je peux tout à fait écrire *g = f*. J'ai maintenant une variable *g* qui référence le même objet fonction, je peux donc appeler ma fonction à partir de la variable f ou alors à partir de la variable g. En Python, tout est un objet, et je vous ai expliqué, lorsqu'on a parlé des **références partagées**, que cela avait un coût mémoire important mais que le mécanisme de références partagées permettait de minimiser les copies des objets. En particulier, Python ne copie jamais d'objet sauf si cela est demandé de manière explicite. Lorsque vous passez des arguments à une fonction, donc lorsque vous passez des objets à une fonction, ces objets ne sont jamais copiés, ils sont toujours passés par référence. Regardons un exemple.

Je vais définir une liste *L* qui est une liste vide, et je vais définir une fonction *add1* qui prend un argument *a* et qui va simplement faire un *a.append(1)*. Donc en fait, que fait ma fonction ? Ma fonction prend un argument et sur cet argument je vais appeler la méthode *append*, donc je suppose que cet argument est une liste, et je vais lui ajouter 1. Je fais un retour chariot. J'ai donc défini une nouvelle fonction ; *add1*, c'est une variable qui référence mon objet fonction. Maintenant, appelons cette fonction sur ma liste *L*. Je vous remontre ma liste *L*, j'appelle *add1* de ma liste *L*. Et je fais un retour chariot. Maintenant, regardons la valeur de l'objet référencé par ma variable L. Je vois que maintenant c'est la liste qui contient l'entier 1. Donc on voit que à aucun moment je n'ai réaffecté L, à aucun moment je n'ai fait de retour ; pourtant, ma liste a été modifiée. En fait, elle a été modifiée par effet de bord parce que j'ai une référence partagée vers un objet mutable. Quelles sont mes références partagées ? *L* référence un objet liste, j'ai passé cet objet liste à ma fonction et ma fonction a une variable locale *a*, cette variable locale référence le même objet liste que la variable *L*. Lorsque je modifie l'objet mutable par la méthode append, je modifie l'objet partagé, donc lorsque ma fonction retourne, la variable *L* référence l'objet qui a été modifié. Alors, ce comportement par effet de bord est un comportement qui peut être tout à fait souhaitable. Quel est son intérêt ? C'est d'être extrêmement économe en terme de mémoire. L'inconvénient, c'est qu'il est fait de manière implicite. Par conséquent, comme on veut qu'en Python tout soit fait de manière explicite, on doit extrêmement bien documenter son code. Pour cela, j'aime bien vous montrer l'exemple de la **méthode sort** sur les listes. Regardons cela.
*help(list.sort)* Je vous rappelle que la méthode sort sur les listes permet de faire un tri en place ; l'intérêt, c'est que c'est très économe au niveau mémoire, l'inconvénient, c'est que c'est fait par effet de bord. Regardons ce que nous donne l'aide de **sort** sur les listes. On voit que l'aide nous dit que l'on fait un tri mais que ce tri est fait en place. C'est marqué entre étoiles et écrit en majuscule pour vraiment insister sur le fait que ce tri est fait en place. Donc ici, on n'a aucune ambiguïté, on voit bien que le retour de *sort* c'est *None*, donc cette méthode nous retourne juste l'objet vide, et la liste est modifiée en place. Donc à chaque fois que vous voulez faire une modification par effet de bord, c'est quelque chose de possible, qui peut être souhaitable si vous voulez être économe en mémoire ; par contre, documentez-le extrêmement bien.

Maintenant, je pourrais tout à fait dire: je ne veux pas modifier ma liste *L*, donc je vous remontre ma liste *L* qui vaut juste [1], je ne veux pas modifier ma liste *L* donc je vais lui passer une copie, et vous vous souvenez de cette notation slice vide, qui représente une *shallow copy*. Donc je passe une shallow copy de ma liste à ma fonction. Ma fonction va donc travailler sur ce nouvel objet liste, qui est copie de ma liste *L*, mais lors du retour, regardons ma liste *L*, évidemment elle n'a pas été modifiée puisque j'ai passé une copie. Mais cette shallow copy a été perdue puisqu'à aucun moment, je n'ai récupéré une référence vers ce nouvel objet liste. En fait, si je veux pouvoir récupérer une référence vers cet objet liste, il faut que je fasse une valeur de retour, il faut que ma fonction retourne quelque chose. Regardons comment faire cela.

Je redéfinis ma fonction *add1*, et je lui passe, je définis un argument *a*. Ensuite, dans ma fonction, je vais faire une shallow copy *a = a[:]* a égale shallow copy de a et ensuite, je vais faire un a.append de 1. Jusqu'à maintenant, qu'est-ce que j'ai fait ? À l'intérieur de ma fonction, j'ai dit: je fais une shallow copy, parce que je ne veux pas que ma fonction fasse de modification en place, je modifie ma shallow copy mais maintenant, pour pouvoir la récupérer, pour pouvoir la modifier lorsque ma fonction retourne, il faut obligatoirement que je passe une valeur de retour et que je fasse un return de *a*. Maintenant, regardons ma liste *L*. Ma liste *L* contient uniquement l'entier 1. Si je fais maintenant un *add1(L)* add1 de L, je passe ma liste L à ma fonction, ma fonction fait une copie, elle modifie la copie et elle me retourne une référence vers cette copie. Je vois bien que maintenant, la valeur de retour, c'est une nouvelle liste qui vaut [1, 1] ; par contre, ma liste L originale n'a pas été modifiée. Si maintenant, je veux modifier ma liste originale, c'est très simple, je le fais de manière explicite, je vais dire L égale add1 de L, et on voit maintenant que j'ai absolument tout qui est explicite, je passe ma liste qui vaut [1] à ma fonction, ma fonction s'appelle add1 donc on suppose qu'elle va lui ajouter 1, et elle donne une valeur de retour que je réaffecte à ma liste L qui est une variable globale, donc maintenant, je vais bien avoir une modification de ma liste L globale. Regardons cela. Maintenant, la valeur de retour est bien la nouvelle liste [1, 1].

Il y a un autre point important que je voudrais aborder lors de cette présentation des fonctions, c'est que lorsque vous écrivez le code d'une fonction, par exemple dans un module et que vous importez le module, lors de l'**importation du module**, l'objet fonction va être créé, et le nom de la fonction va être une variable qui va référencer cet objet fonction. Par contre, le bloc de code de la fonction ne sera évalué que lors de l'appel de la fonction. Regardons ce que cela implique. Je définis une fonction f qui prend un argument a et ma fonction appelle une autre fonction qui s'appelle func. Regardons ce code. J'ai donc une variable *f* qui référence mon objet fonction ; par contre, la variable *func* n'existe pas ; je n'ai pas encore d'objet fonction. Nous voyons que lors du retour chariot, la fonction a été correctement créée ; mon objet fonction existe, ma variable f référence bien l'objet fonction, je n'ai aucun problème. Le problème, je le verrai, donc l'absence de la définition de la fonction func, je le verrai uniquement lors de l'appel de ma fonction f. Appelons maintenant la fonction f. Je vois qu'ici j'ai une exception qui me dit clairement que le nom func n'a pas été défini. Donc on voit que je peux définir une fonction qui appelle du code qui n'est pas encore défini, et que c'est possible jusqu'au moment où j'appelle effectivement ma fonction. Si maintenant, je définis ma fonction func qui prend un argument *a* et qui fait simplement un return de *a* ; maintenant, j'ai bien une fonction f, une fonction func et je peux donc appeler ma fonction f, f de 1, qui va appeler func en lui passant 1, et qui va faire un retour, voilà, de 1.

Pour finir, j'aimerais vous parler de **polymorphisme**. Polymorphisme, c'est un nom un petit peu étrange pour un concept très simple. Regardons ce que cela veut dire. Je vais définir une fonction qui s'appelle *my_add* et qui va prendre deux arguments a et b. Et cette fonction va simplement faire un *print* d'une *f-string* qui contient *a et b*, et ensuite ma fonction va faire un return de *a* plus *b*. Donc j'écris une fonction *my_add* qui prend deux arguments a et b, qui va les afficher et qui va faire un return de la somme de ces arguments. Vous remarquez que, vous savez qu'en Python on a du **typage dynamique**, donc à aucun moment, je n'ai spécifié le type. Ça veut dire que je peux donc appeler ma fonction *my_add* avec deux entiers 1 et 2 ; regardons le résultat, c'est 3. J'ai bien fait la somme. Je peux appeler *my_add* avec des floats 4.3 et 2.3, et je vais faire l'addition de ces floats. Et je peux même appeler ma fonction *my_add* avec une chaîne de caractères et une autre chaîne de caractères. Quelle va être la valeur de retour ? La concaténation des chaînes de caractères. Donc la caractéristique de cette notion de polymorphisme, c'est qu'une fois que vous avez défini une fonction, cette fonction va pouvoir s'exécuter sur n'importe quels types qui sont compatibles avec les opérations contenues dans le bloc de code de la fonction. L'intérêt de ce polymorphisme, c'est que vous réduisez énormément le code que vous avez à écrire puisque vous n'avez pas besoin d'écrire une fonction pour les entiers, une fonction pour les floats, une fonction pour les chaînes de caractères ; votre fonction va être unique et va pouvoir se comporter correctement avec n'importe quels types que vous lui passez, du moment que les opérations définies dans la fonction sont définies pour les types qui sont passés à cette fonction.


Dans cette vidéo, nous avons présenté **le fonctionnement des fonctions**. En fait, les fonctions sont des objets qui sont référencés par une variable qui est le nom de la fonction. Tous les arguments de la fonction sont passés par référence ; ça veut donc dire qu'on a des risques d'effets de bord qu'il faut contrôler, et nous avons vu qu'il est toujours mieux de faire des retours de fonction sauf lorsqu'on a besoin d'une grande efficacité mémoire, c'est-à-dire lorsqu'on ne veut pas dupliquer les objets. Nous avons également vu que les fonctions étaient polymorphes ; l'intérêt de ce polymorphisme c'est de simplifier l'écriture de votre code, vous écrivez une seule fois la fonction et cette fonction va pouvoir s'exécuter avec n'importe quels types du moment que les opérations définies dans la fonction sont compatibles avec ces types. Python utilise le typage dynamique, ce qui veut dire que nous n'avons jamais à définir le type des objets que nous passons aux fonctions. Cependant, Python permet de donner des indications de type, c'est ce qu'on appelle les type hints. Les type hints sont uniquement des indications qui peuvent être utilisées par exemple pour améliorer la documentation du code ou alors pour faire une validation statique du code. Cependant, l'auteur de Python a été très clair sur cette notion-là, les type hints resteront toujours optionnels et ne vous obligeront jamais à définir du typage statique dans votre code.


À bientôt !



# W4-S2 Tests if/elif/else et opérateurs booléens



Dans une précédente vidéo, nous avons vu l'**instruction if else**. Dans cette vidéo, nous allons revenir dessus et en particulier, nous allons vous expliquer ce qui peut être contenu dans un test.

Revenons sur cette syntaxe de *if else*. Vous commencez avec l'instruction *if* et ensuite vous mettez un test. Nous allons revenir dans quelques instants sur exactement ce que peut contenir ce test. Ensuite on a un : qui signifie qu'on va avoir un bloc d'instructions. Ce bloc d'instructions ne sera exécuté que si le test est vrai. Ensuite, on peut avoir de manière optionnelle un *elif* avec un bloc d'instructions ou même plusieurs *elif* avec des blocs d'instructions. L'intérêt de ces *elif* c'est de faire des tests supplémentaires ; ça va fonctionner de la manière suivante: vous commencez avec le premier *if* si le premier test est vrai, vous exécutez le bloc d'instructions et vous sortez de votre *if else*. Si le test 1 est faux, vous passez au deuxième test, le test 2, s'il est vrai, vous exécutez le bloc d'instructions correspondant ; sinon, *else if*, (**elif** ça veut dire *else if*), vous passez au troisième test et vous continuez, de manière successive, jusqu'au dernier test. Si l'intégralité de vos tests sont faux, vous pouvez, avec le *else* optionnel, faire une exécution d'un bloc d'instructions.

En résumé, si test 1 est vrai, vous exécutez le bloc d'instructions correspondant ; sinon vous passez à test 2, sinon vous passez à test 3, et si aucun des tests n'est vrai, vous finissez dans *else* et vous exécutez le bloc d'instructions de *else*. En fait, dans une structure *if, elif, else*, un seul bloc d'instructions sera exécuté. Regardons maintenant ce que nous pouvons avoir dans un test.

Dans un test d'un *if* ou d'un *elif*, vous pouvez avoir absolument n'importe quelle expression. En fait, le test va évaluer, va appeler la **fonction built-in bool** sur le résultat de l'évaluation de cette expression. Vous avez une expression, cette expression va être exécutée, elle va produire un objet et vous allez appeler *bool(objet)*. Que va faire bool sur cet objet ? Il va appeler soit la méthode *objet._bool_()* double underscore bool double underscore qui est une méthode spéciale, lorsque nous parlerons des classes nous reviendrons largement sur ces méthodes spéciales, et cette méthode *bool* va retourner vrai ou faux, qui sera pris en compte par le test, ou alors, s'il n'y a pas de méthode bool, il va appeler la méthode *len*. Si la méthode *len* retourne 0, ce sera faux ; si la méthode *len* retourne quelque chose d'autre, ce sera vrai. L'intuition derrière ça, c'est que un objet vide, de longueur vide, est considéré comme faux, un objet qui n'est pas vide est considéré comme vrai.

Regardons maintenant quelques exemples d'expressions que nous pouvons avoir dans un test d'un *if* ou d'un *elif*. Ces exemples ne sont pas exhaustifs mais vous permettent de couvrir un panorama de tests que l'on peut faire.

Premier exemple, c'est mettre directement un *type built-in* ; un type built-in, s'il est False, 0, None, ou n'importe quel type liste, set, dictionnaire, chaîne de caractères, tuple, vide, il sera considéré comme faux. Tout le reste est vrai. Regardons un exemple. Je définis un dictionnaire et je fais : *if d: print(d)*. L'intérêt de faire ça, c'est que si mon dictionnaire est vide, je ne fais pas de print, s'il y a quelque chose dans mon dictionnaire, je vais afficher ce que contient mon dictionnaire.

Deuxième exemple: je peux mettre une comparaison donc je peux mettre supérieur, supérieur ou égal, inférieur, inférieur ou égal, égal ou différent. Regardons un exemple. Si a est différent de b, je vais afficher faux.

Troisième exemple: le test d'appartenance. Je peux faire if 'a' in 'marc' donc si la lettre 'a' est dans la chaîne de caractères 'marc', j'affiche 'ok'. Là aussi, un test extrêmement simple, et encore une fois intuitif. Donc ici, j'insiste sur la nature explicite et proche du langage naturel de Python: if 'a' in 'marc' c'est si 'a' est dans 'marc' alors j'affiche (print) 'ok'. On voit que c'est extrêmement facile à lire et à comprendre.

Exemple suivant: un retour de fonction. Que va être l'évaluation du retour de fonction ? On va évaluer l'objet qui est retourné par l'appel de la fonction, avec les règles qu'on a vues précédemment. Je fais une chaîne de caractères qui est égale à '123', et je regarde *if s.isdecimal()*. On voit que '123' est décimale. **isdecimal** va donc me retourner un booléen True ou False ; dans ce cas-là, ça va être True, je vais donc pouvoir bien faire mon print de *int(s)* puisque *s* est une chaîne de caractères qui représente un entier.

Regardons maintenant ce dernier cas: ce sont les opérateurs de test booléen ; lorsque vous avez plusieurs conditions, vous pouvez les combiner avec ces opérateurs. *A and B est vraie si A et B sont vraies*, *A or B est vraie si soit A, soit B est vraie*. Il est d'ailleurs intéressant de remarquer que ces opérateurs sont ce qu'on appelle **short-circuit**: ça veut dire quoi ? Ça veut dire que A et B est vraie si les deux sont vraies. Donc si on évalue A à faux, on sait que le A and B sera faux donc on n'évaluera pas le B. De même, A or B est vraie si A est vraie, donc si jamais A est vraie, dans le A ou B, on n'évaluera pas le B. C'est ce qu'on appelle **short-circuit**, **court-circuit**, on va court-circuiter l'évaluation si on sait que le test est de toute façon déjà validé. Et puis pour finir, on a *not A* qui permet de retourner vrai si A est faux.

Regardons un exemple: j'ai une chaîne de caractères qui vaut '123' et je regarde si '1' est dans ma chaîne de caractères et que s est décimale, alors je vais faire un print de ma chaîne de caractères convertie en entier plus 10.

Pour finir, je vais vous montrer un petit jeu fait uniquement à base de tests *if elif else* qui est le suivant: on va juste faire *s = input("Quelle est votre question ?\n")* **input** est une fonction built-in qui vous permet de taper du texte dans un terminal. Lorsque vous faites un retour chariot, ce que vous avez tapé va être mis dans une chaîne de caractères et s va référencer cet objet. Après, vous pouvez manipuler ce que vous avez tapé sur le terminal. Ensuite, je fais un *if s.startswith('bonjour')* donc si jamais ma chaîne de caractères commence avec "bonjour", je vais simplement afficher un print("bonjour, comment allez-vous ?"). Et ensuite, je fais un *elif* si jamais la chaîne de caractères "bien" est dans ce que j'ai tapé, alors je vais afficher "c'est super !". Ensuite, je fais si jamais dans ma chaîne de caractères j'ai "bye" qui est contenu, j'affiche simplement "Au revoir !" et sinon, je vais afficher print "mais encore...". Voilà, c'est un tout petit jeu, vous n'allez pas passer une année là-dessus, mais vous verrez que ça vous amusera quelques minutes.


Nous venons de voir **l'instruction if elif else** qui permet de faire une évaluation conditionnelle de blocs de code. Nous avons vu que les tests étaient très expressifs ce qui vous permet d'écrire du code qui soit simple et intuitif à lire.


À bientôt !



# W4-S3  Boucles while


Nous avons vu précédemment l'instruction *if* qui permet d'évaluer des tests et nous avons vu également la boucle *for* qui permet de répéter un bloc d'instructions un certain nombre de fois. Nous allons voir, dans cette vidéo, **l'instruction while**, qui permet de combiner ces deux possibilités. Ouvrons maintenant un éditeur IDLE pour commencer à jouer avec les boucles while.

Regardons comment est-ce que je peux écrire une **boucle while**. Je vais commencer par définir une liste qui contient des entiers allant de 0 à 10. Je vais prendre une liste qui va de 1 à 10. Voilà. Et ensuite, je vais faire un *while a :*  donc *while*, c'est l'instruction, à côté de l'instruction, je mets un test et ce test est exactement de même nature que le test que je mets avec un *if*, que nous avons vu dans une précédente vidéo. Tant que ce test est vrai, je continue, *while* veut dire tant que, tant que c'est vrai, je continue à boucler et lorsque le test devient faux, je sors du bloc de code du while.

Regardons quelque chose que je peux mettre dans un while, je vais mettre un *a.pop()* et ensuite je vais faire un *print(a)*. Que va faire ce code ? Il va boucler tant que *a* est vrai, *a* est une liste et nous savons qu'une liste est vraie tant qu'il y a des éléments dans la liste, et qu'elle devient fausse dès qu'elle est vide. *a.pop()* va enlever le dernier élément de la liste, et lorsqu'il n'y aura plus d'élément dans la liste, mon test va naturellement s'arrêter. Regardons ça, je le sauvegarde avec Ctrl-S, je l'évalue avec F5, et regardons l'exécution, je vois bien ma liste qui apparaît et qui diminue d'un élément à chaque tour du while, et lorsque ma liste est vide, simplement le while s'arrête.

Dans un *while*, je peux également mettre des instructions *break* et *continue*, qui me permettent d'interrompre l'exécution d'un *while* ou alors de remonter au début.

Regardons cela. Donc ici, je fais mon *a.pop()* et je vais rajouter un *if len de a égale 5 : **continue***. Qu'est-ce qu'il va se passer ? Lorsque ma liste aura exactement 5 éléments je vais arriver à l'instruction continue, donc l'instruction continue va être évaluée, et je vais remonter au début du while. Ça veut donc dire que je vais sauter un print de la liste. Regardons cette évaluation, je le sauvegarde avec Ctrl-S et je l'évalue avec F5, et je vois que j'ai la liste [1, 2, 3, 4, 5, 6, 7, 8] [1, 2, 3, 4, 5, 6, 7] [1, 2, 3, 4, 5, 6] mais je n'ai pas la liste [1, 2, 3, 4, 5]. En effet, lorsque la liste a exactement cinq éléments, je fais un *continue* ce qui me permet de remonter en haut de mon *while*.

Dans mon *while*, je peux également avoir un **break**, et le *break* va faire quoi ? Il va simplement sortir de mon bloc d'instructions donc du while, dès que cette instruction est rencontrée. Regardons ça, je vais l'exécuter. Ce que me dit mon code, c'est que lorsque la longueur de ma liste sera exactement de cinq éléments, je ferai un break donc j'arrêterai mon *while*. Évaluons cela et regardons ce qu'il se passe. Je vois effectivement que je vois apparaître [1, 2, 3, 4, 5, 6, 7, 8] [1, 2, 3, 4, 5, 6, 7] [1, 2, 3, 4, 5, 6] et lorsque j'ai exactement cinq éléments, et bien je sors de mon *while*, j'interromps la boucle.

Il y a un usage fréquent du *while* que je voudrais vous montrer, c'est lorsque l'on fait un **while True**. Quel est l'intérêt de faire un *while True* ? C'est qu'on fait une boucle infinie, et on sortira de cette boucle en fonction d'un certain critère de test avec un *break*. Regardons cela.

Je vais faire un *while True:* et dedans, je vais simplement faire un *s = input(')* qui me permet de taper une chaîne de caractères au niveau de l'interpréteur, lorsque je fais un retour chariot, cette chaîne de caractères sera capturée et je la récupèrerai grâce à la variable *s*. Je vais faire : *Quelle est votre question ?* et ensuite, je fais *if 'aucune' in s: break*. Que va faire ce *while* ? Il va faire une boucle infinie, il va en permanence me demander quelle est votre question, et lorsque ma réponse contiendra 'aucune' alors je pourrai sortir du *while*. Regardons l'évaluation de ce code, je le sauvegarde avec Ctrl-S, je l'évalue avec F5 et je vois: *Quelle est votre question ?* Ici, je vais taper 'bonjour', ce n'est pas une question et il continue à parler, je peux taper 'rien' et il continue, et si jamais j'écris 'aucune', à ce moment-là, 'aucune' est dans ma chaîne, j'évalue mon *break*, je sors de mon while.

Reprenons l'exemple que nous avions eu précédemment avec le *if*, du petit jeu où je pose un certain nombre de questions. Je l'ai repris ici et je vous laisse le temps de le taper, n'hésitez pas à mettre cette vidéo en pause pour le retaper. Alors, nous allons inclure ce petit test dans un *while*. Je vais écrire un *while True* exactement comme précédemment pour faire une boucle infinie, je vais prendre tout ce code et je vais l'indenter de 4 caractères vers la droite je peux aller dans Format, Indent Region ou faire directement un Ctrl-crochet fermant, et ensuite, alors, lorsque j'ai 'bye', je vais écrire "au revoir" mais à ce moment-là, je veux sortir de mon while donc je vais rajouter un break. Et pour finir, comme la question n'est posée qu'au début, juste avant le while, je vais rajouter ici un *s = input* pour attendre une réponse de l'utilisateur, à chaque tour de la boucle while. Exécutons ce petit morceau de code, je fais Ctrl-S pour le sauver, et F5 pour l'évaluer, Quelle est votre question ? donc je vais écrire bonjour ; bonjour, comment allez-vous ? donc j'écris bien ; c'est super ! ; je peux demander ça va ? et là, il me dit: mais encore... et finalement, je peux quitter en tapant simplement bye.

Dans cette vidéo, nous venons de voir l'instruction **while** qui ne présente pas de difficulté particulière mais qui se révèle extrêmement utile lorsqu'on a un traitement systématique à faire qui ne doit s'arrêter qu'en fonction d'un certain critère.


À bientôt !


# W4-S4  Portée des variables - règle LEGB


Nous avons déjà parlé de la notion de **bloc de code** lorsque nous avons parlé par exemple de l'instruction *for* ou de l'instruction *if*. Un *bloc de code* est un ensemble d'instructions contiguës indentées du même nombre de caractères vers la droite. Lorsque vous faites une opération d'affectation, par exemple x = 1, on dit que vous définissez votre variable x, donc cette notion de définition, ça veut dire qu'une variable référence un objet. Nous avons plusieurs synonymes, que sont *définition, affectation, assignation ou binding*. Nous utilisons ces termes de manière interchangeable. La portée d'une variable détermine de quel endroit du code on peut accéder à cette variable. Python utilise ce qu'on appelle **la portée lexicale**, ça veut dire que la portée d'une variable est déterminée en fonction de l'endroit dans le code où cette variable est définie. Une variable locale au bloc de code d'une fonction est ce qu'on appelle une **variable locale**, donc une variable qu'on définit dans le bloc de code de la fonction sera locale. Lorsque la fonction retourne, toutes les variables locales de la fonction sont détruites. Une variable définie en dehors de toute fonction est ce que l'on appelle une **variable globale**. Nous avons donc principalement deux catégories de variables, les variables locales qui sont définies dans le bloc de code des fonctions, et les variables globales qui sont définies en dehors de toute fonction. Nous allons voir dans cette vidéo **la notion de portée de variable** et en particulier les notions de **variables locales et globales**.

Commençons par regarder la règle pour savoir comment trouver les bonnes variables lorsque l'on veut les référencer. Il y a une règle qui s'appelle **la règle LEGB**. Que veut dire cette règle ? Elle veut dire que lorsque l'on référence une variable, on va d'abord chercher si elle a été définie localement à l'endroit où elle est référencée. Donc typiquement, lorsque je référence une variable dans une fonction, je regarde est-ce que cette variable a été définie localement à la fonction. Si elle n'a pas été définie localement à cette fonction, je vais aller la chercher dans les fonctions englobantes. Je vais remonter, de la fonction la plus proche de là où je référence ma variable, jusqu'à la fonction la plus externe. Si je ne trouve pas cette variable définie dans les fonctions englobantes, je vais la chercher globalement, c'est-à-dire au niveau des variables globales, et pour finir, si je ne la trouve toujours pas, je la chercherai dans le module *builtins*. Nous allons revenir sur chacun de ces critères. Ouvrons maintenant un éditeur IDLE pour commencer à jouer avec cette notion de portée de variable.

Définissons une fonction pour commencer à jouer avec cette notion de portée de variable. Je vais définir trois variables *a, b, c*, qui valent toutes 1. Donc j'utilise à cette occasion la notion de **tuple unpacking**. Vous remarquerez que dans cet exemple j'utilise des noms de variable un petit peu simplifiés ; c'est exactement l'intérêt de cet exemple, c'est de produire de la confusion pour être sûr que vous avez parfaitement compris cette notion de portée de variable. Dans du code réel, on cherchera évidemment à différencier les noms de variable pour éviter toute confusion. Cependant, c'est important de comprendre cette règle, parce qu'on ne tombe pas toujours sur du code écrit proprement. Donc je définis ma fonction *g* et dans ma fonction *g*, je vais définir deux variables *b* et *c* qui sont égales à 2,4. Et ensuite je vais faire *b = b + 10*. Ensuite, je définis une fonction *h* qui va définir une variable *c* qui est égale à 5, et je vais faire, dans ma fonction *h*, un *print* de *a,b,c*. Ensuite, je vais appeler ma fonction *h* et pour finir, au niveau du module, je vais appeler ma fonction *g*. Voici le code qu'on vient de taper, maintenant, essayons de comprendre ce qu'il va se passer lorsque l'on va exécuter ce code. La question principale que l'on a à se poser, c'est: qu'est-ce qu'il va se passer lorsqu'on va faire un print de a, b, c. Quelle variable *a* va être affichée ? Quelle variable *b* va être affichée ? Quelle variable *c* va être affichée ?

Commençons par le *a*. Je vous rappelle qu'on utilise la règle **LEGB** : locales, fonctions englobantes, globales et ensuite builtins. Lorsque je fais print de *a*, je regarde est-ce que *a* est définie localement à ma fonction *h* ? Non, je n'ai pas défini *a* localement. Est-ce que *a* est définie dans les fonctions englobantes ? *g* est une fonction qui englobe *h*, donc *g* est une **fonction englobante** ; non, *a* n'est pas définie dans la fonction englobante. Est-ce que *a* est définie globalement ? Oui, je trouve ma variable globale *a* et il se trouve qu'au moment de l'exécution de ce code, ma variable globale *a* référence l'entier 1. Donc mon print de *a* va afficher 1.

Ensuite, je prends la variable *b*. Est-ce que *b* est définie localement à ma fonction *h* ? Non. Est-ce que *b* est définie dans les fonctions englobantes ? Oui, j'ai une fonction englobante *g* qui définit la variable *b*. *b* vaut 2, et ensuite je fais *b = b + 10* donc au moment où je recherche ma variable *b*, ma variable *b* référence l'entier 12. Mon print de *b* va donc afficher 12.

Et ensuite, je cherche ma variable *c*. Est-ce que *c* est définie localement ? Oui. *c* est une variable définie dans *h* et *c* référence l'entier 5. Maintenant, sauvegardons ce code, exécutons-le et vérifions l'évaluation de ce code ; on voit bien qu'il s'affiche 1, 12 et 5.

En résumé, nous pouvons voir qu'une variable définie dans une fonction devient locale à cette fonction ; ça veut dire qu'elle peut être vue dans les fonctions qui sont englobées, par contre une variable locale à une fonction ne peut pas être vue à l'extérieur de cette fonction. Une variable globale, au contraire, définie au niveau du module, peut être vue par toutes les fonctions qui sont définies dans ce module.

Évidemment, si je fais un print de *a,b,c*, je vois bien s'afficher 1, 1, 1, puisque mes variables *a, b, c* sont définies globalement et que le print est demandé depuis le contexte global de mon module. Seulement vous vous souvenez que dans la règle **LEGB**, j'ai locales, fonctions englobantes, globales et **builtins**. À quoi sert cette recherche builtins ? En fait, lorsque je fais un print de *a, b, c*, j'ai quatre variables. J'ai bien sûr la variable *a*, la variable *b* et la variable *c*, mais j'ai une quatrième variable. Est-ce que vous voyez de quelle variable je parle ? Il s'agit de la variable *print*. *print* est une variable qui référence un objet fonction. En fait, vous avez remarqué que je peux tout à fait faire un *len* d'une liste, que je peux appeler la fonction built-in *str*, je peux appeler la fonctions built-in *dict*, *set*, et je peux appeler la fonction built-in *print*. À aucun moment, je n'importe un module. En fait, toutes les fonctions qui sont définies dans le **module builtins** sont directement accessibles sans avoir à importer le module builtins grâce à cette **règle LEGB**. En dernier ressort, si on ne trouve pas un nom de variable, on le cherche dans le module builtins pour pouvoir, si cette variable est définie dans builtins, appeler la fonction correspondante. Évidemment, on peut importer le module builtins à la main, donc je vous montre ça, je peux faire un import de builtins, et ensuite on peut regarder tout ce qui est défini dans le module builtins. Nous voyons des exceptions, nous en parlerons dans de prochaines vidéos, et nous voyons un certain nombre de fonctions que nous avons déjà utilisées, par exemple, la fonction *min*, la fonction *tuple*, la fonction *type*, qui sont des fonctions définies dans le module builtins. Donc à chaque fois que j'utilise le terme **fonction builtins**, c'est une fonction qui est définie dans ce module. Seulement, c'est important de comprendre que ces fonctions builtins sont référencées par des variables et qu'une fonction, c'est un objet, et qu'une variable, c'est un nom qui référence un objet, et que par conséquent, je peux redéfinir des fonctions builtins. Regardons cela.

Si je fais un print de 1, je vais chercher print dans le module builtins parce que print n'est définie ni localement, ni dans les fonctions englobantes, ni globalement. Par contre, si je fais un *print = 10*, je définis une variable *print* qui référence l'entier 10. Maintenant, *print* est une variable qui référence un entier, si je fais un print de 1, je vais avoir une exception parce que je ne peux pas appeler un entier 1 pour afficher quelque chose. Alors, vous pouvez vous dire: mais c'est très risqué ce type de mécanisme, parce que je peux redéfinir tous mes builtins. En fait, en pratique, ça ne se produit jamais. Regardez pourquoi.

Si je tape *x = 1*, quelle est la couleur de mon *x* ? On voit que mon *x* est écrit en noir, c'est un nom de variable classique. Par contre, si je fais *print = 1*, je remarque que mon print est affiché dans une couleur différente, ici, c'est une sorte de mauve violet, et donc ça me permet de voir que ce nom de variable est déjà défini dans le module builtins. Dès que je vois une variable qui est d'une couleur différente, je sais qu'il ne faut pas l'utiliser. Et puis évidemment, comme ma fonction print est toujours définie dans le module builtins, je peux toujours écrire *print = builtins.print* et ainsi récupérer la référence vers le bon objet fonction, et maintenant, je peux de nouveau faire un print(1), ça va fonctionner normalement.

Nous venons de voir la notion de portée de variable mais il y a ici une subtilité importante. Vous avez remarqué qu'il n'y a rien de supérieur à une variable globale, une variable est définie comme globale au niveau d'un module, donc chaque module va définir ses propres variables globales. Cela est rendu possible grâce à un mécanisme d'isolation qui s'appelle **espace de nommage**. Chaque module va définir son propre espace de nommage, et les variables définies dans l'espace de nommage du module sont ce que l'on appelle des variables globales. Nous verrons dans une prochaine vidéo comment communiquer entre les espaces de nommage et notamment comment accéder à des attributs définis dans d'autres espaces de nommage. En résumé, nous avons vu **la règle LEGB**, la règle de portée des variables en Python. Je vous rappelle que Python utilise la portée lexicale, ça veut dire que la portée d'une variable est définie en fonction de l'endroit où la variable est définie dans le code source. Une variable définie dans une fonction est locale à la fonction ; une variable définie en dehors de toute fonction est une variable globale.


À bientôt !


# W4-S5 Modification de la portée avec global et nonlocal


Nous avons vu dans une précédente vidéo la notion de portée de variable et notamment la règle LEGB qui permet de trouver les variables que l'on référence. Nous avons également vu qu'une variable définie dans une fonction est locale à cette fonction. Dans cette vidéo, nous allons voir **comment modifier la portée des variables avec les instructions global et nonlocal**. global permet de rendre une variable locale de portée globale, et nonlocal permet de rendre une variable locale de portée locale dans une fonction englobante. Ouvrons maintenant un éditeur IDLE pour commencer à jouer avec **la portée des variables**.

Commençons par expliquer le fonctionnement de **global**. Pour cela, je vais créer une variable *a* qui vaut 'a globale', donc c'est une chaîne de caractères, et je vais créer une fonction *f* qui va redéfinir localement la variable *a*, qui va dire 'a dans f' et ensuite qui fait un print de *a*. Donc je vais exécuter ce bloc de code, alors, j'ai une petite erreur de syntaxe parce que j'ai oublié mon guillemet ici ; je réexécute mon bloc de code, et maintenant, je fais un *print(a)*. Donc je vois que j'ai 'a globale'. J'exécute ma fonction *f*, ma fonction *f* va définir une variable locale *a*, va faire un print de *a* que je vais chercher avec la règle LEGB. Est-ce que *a* est définie localement ? Oui, je vais donc afficher ma variable locale sauf que les variables locales, lorsque ma fonction retourne, sont détruites, et donc elles n'ont aucun impact sur les variables globales. Donc j'exécute ma fonction *f*, je vois bien que mon print m'affiche 'a dans f' mais si maintenant, je fais un *print(a)*, je vois que j'ai toujours mon *a globale* qui vaut la chaîne de caractères 'a globale'. La question qu'on peut se poser maintenant c'est comment est-ce que je pourrais modifier une variable globale depuis ma fonction ? Bien pour ça, on peut utiliser **l'instruction global**. Regardons comment cela fonctionne.


Dans ma fonction, je vais rajouter l'instruction *global a* et après mon code reste exactement le même. J'exécute ce code, je l'évalue avec F5, maintenant, je regarde que vaut *a* ; *a* vaut 'a globale' ; maintenant, j'exécute *f*, je vois bien 'a dans f', et si maintenant, je fais un print de *a* après l'exécution de ma fonction, je vois que j'ai maintenant 'a dans f'. Que s'est-il passé exactement ? Dans ma fonction *f*, j'ai défini *global a*. Lorsque l'interpréteur Python trouve *global a*, pour lui, la variable *a* qui sera utilisée dans la fonction, ça n'est plus une variable locale c'est la variable globale *a*. Donc ici, ça n'est même pas une référence partagée, j'accède directement à la variable qui est définie dans le module. Donc c'est une manière, depuis une fonction, de modifier des variables globales directement. Cependant, cette notation a un inconvénient qui est majeur. L'inconvénient, c'est que lorsque je définis une variable globale à l'intérieur d'une fonction, je fais une modification implicite d'une variable globale, donc d'une variable définie dans le module. Or, on sait qu'en Python, on n'aime pas les modifications implicites. Regardons comment changer cela, comment avoir une modification qui est faite de manière explicite.

Pour illustrer cette modification, prenons l'exemple suivant. Maintenant, je vais définir une variable *a* qui vaut 10, une fonction *f* qui fait *global a* et qui va faire *a = a + 10*. Tout simplement. J'exécute ce code, et je regarde maintenant que vaut ma variable *a*. Ma variable *a* vaut 10, pas de surprise. Maintenant, j'appelle ma fonction *f*. Ma fonction *f* définit la variable *a* comme étant une **variable globale**, je vais donc travailler sur la variable globale, et je vais faire *a = a + 10*, *a* étant la variable globale, je vais donc lui ajouter 10, elle va donc valoir 20 en sortie. Si maintenant, je fais un print de *a* je vois que mon *a* vaut 20. Seulement ce code a tout faux. Premièrement, les noms de variable sont très mal choisis, on voit que c'est très difficile de comprendre ce que veut faire ce code. Deuxièmement, l'accès à ma variable globale est fait de manière implicite, et la modification de ma variable globale est faite de manière implicite également. Regardons comment est-ce qu'on écrirait du vrai code qui manipule explicitement une variable globale. On va faire la chose suivante. Au lieu d'appeler ma variable *a*, je vais l'appeler *note*, parce que je suis dans un contexte d'un programme dans lequel je manipule des notes. Et puis ensuite, on voit bien que ma fonction *f*, en fait, elle ajoute 10, donc plutôt que de l'appeler *f*, je vais l'appeler *add_10* pour rendre explicite le fait qu'elle ajoute 10. Et ensuite, plutôt que de chercher ma variable avec la règle LEGB, je vais la placer explicitement, je vais passer une note *m*. J'enlève *global a* ; et maintenant, au lieu de faire un *a égale a plus 10*, je vais simplement faire un *return de a plus 10*. Maintenant, regardons comment est-ce que je vais appeler cette méthode. Je sauvegarde, et j'exécute. Maintenant, si je veux modifier ma variable globale *note*, je n'ai qu'à écrire *note = add_10(note)*. Je remarque une petite erreur dans mon code, ici, j'ai écrit *a* ; évidemment, ma variable que je passe à ma fonction, c'est *m*. Je le corrige, je réexécute, alors, j'efface ce petit morceau, je réévalue mon code, F5, et maintenant, j'écris *note = add_10(note)*. Regardons ce que dit cette notation. Cette notation dit: je prends ma variable globale *note* et je lui affecte un retour de fonction ; ma fonction s'appelle *add_10* et elle prend comme argument *note*. Donc là, on voit de manière très explicite que note maintenant va valoir le résultat de *add_10 sur note*. J'exécute ce morceau de code, je regarde le résultat de note en sortie, et je vois maintenant qu'il vaut 20. On voit que cette notion de **variable globale**, cette notion d'instruction global est très trompeuse puisqu'elle rend toutes les modifications implicites, et qu'il vaut bien mieux travailler avec des **retours de fonction** pour contrôler de manière explicite le changement de nos variables globales.


Nous venons donc de voir l'instruction global. D'expérience, je peux vous garantir que un code dans lequel on a beaucoup de variables globales manipulées de cette manière avec l'instruction global, est extrêmement difficile à débugger et à maintenir. Donc croyez-moi, rendez toujours vos modifications de variable globale explicites avec des **retours de fonction**.

Maintenant, nous allons voir **l'instruction nonlocal**. Pour expliquer son comportement, je vais implémenter une petite fonction et comme je l'ai dit rapidement en introduction, nonlocal sert à modifier la portée d'une variable locale pour accéder à une variable également locale mais dans une fonction englobante. Il faut donc que j'écrive des fonctions englobantes. Je vais écrire *a = 'a globale'*, et ensuite, je vais définir une fonction *f* qui définit *a égale 'a de f'* et qui va définir une fonction *g* qui contient *a égale 'a de g'*. Ensuite, je fais un print de *a dans g*, j'appelle ma fonction *g* pour qu'elle s'exécute depuis la fonction *f*, je fais un print de *a dans f*, et ensuite j'appelle ma fonction *f*, et pour finir, je fais un print de *a* pour voir l'état de ma variable globale en sortie. J'exécute ce morceau de code. Et là, sans surprise, comme on l'a vu, lorsqu'on fait *print(a)* dans la fonction *g*, on cherche *a* localement, on affiche 'a de g'. Lorsqu'on fait *print(a)* dans la fonction *f*, on cherche *a* localement à la fonction *f*, on voit 'a de f'. Et lorsque l'on fait print de *a* dans le module, on cherche *a* globalement et on voit 'a globale'. Maintenant, je sais comment modifier la variable globale *a* depuis *f* ou *g* ; dans *f*, si j'écrivais *global de a*, je modifierais la variable globale ; et si dans *g*, j'écrivais *global de a*, je modifierais depuis *g* la variable globale. La question qu'on peut se poser, c'est comment est-ce que je peux modifier la variable locale à *f* depuis *g*? Pour ça, j'ai l'instruction qui s'appelle **nonlocal**. Regardons comment elle fonctionne.

Dans *g*, je vais écrire *nonlocal de a* et que va dire cette instruction **nonlocal** ? Elle va dire que maintenant ma variable *a* que je définis dans *g* n'est plus une variable locale de *g*, c'est la variable locale qui est définie dans *f*. Donc depuis *g*, je peux directement modifier la variable locale de f. Exécutons ce code et regardons ce qu'il va se passer. Je vois que lorsque je fais un *print(a)* depuis *g*, je vois apparaître 'a de g' ; mais dans *g*, j'ai redéfini ma variable *a* *a de f* vers la chaîne de caractères 'a de g', donc maintenant, lorsque je fais un *print(a)* dans *f* après avoir appelé *g*, je vois que *a* maintenant vaut bien 'a de g'. Elle a donc été modifiée depuis la fonction *g*. Donc nonlocal me permet de modifier les variables des fonctions englobantes.

Dans cette vidéo, nous avons vu la notion de **modification de portée de variable** avec les instructions **global** et **nonlocal**. Cependant, gardez toujours en tête que les modifications implicites de variables représentent une source de confusion et une difficulté pour maintenir votre code. Donc réservez ces usages uniquement pour des applications avancées.

À bientôt !



# W4-S6 Modification de la portée avec global et nonlocal

Lorsque vous définissez une fonction, par exemple *def sum(a,b):* les variables *a* et *b* sont ce qu'on appelle des **paramètres de la fonction**. Et lorsque vous appelez une fonction, par exemple *sum(x, y)*, les variables *x* et *y* représentent ce qu'on appelle les **arguments de la fonction**. Dans cette vidéo, nous allons voir les différentes manières de définir les paramètres d'une fonction et les différentes manières de passer des arguments à une fonction. Ouvrons maintenant un interpréteur Python pour commencer à jouer avec ces définitions de paramètres et ces passages d'arguments.

Commençons par regarder la manière standard de définir les **paramètres d'une fonction**. Je vais donc définir une fonction *agenda* qui prend trois paramètres: nom, prénom et téléphone. Et ensuite, ma fonction *agenda* va simplement faire un *return* d'un dictionnaire qui va contenir pour nom, le paramètre nom, pour prénom, le paramètre prénom, et pour téléphone, le paramètre téléphone. Voici ma fonction *agenda*. Je l'évalue, j'exécute avec F5, et maintenant, je vais appeler ma fonction agenda. Je vais l'appeler de la manière suivante, une manière qu'on a déjà vue qui est tout à fait classique, je vais passer un nom 'idle', un prénom 'eric', et un numéro de téléphone voilà. J'exécute ma fonction et je vois que ma fonction me retourne bien un dictionnaire qui a pour clé nom, pour valeur 'idle', pour clé prenom, pour valeur 'eric' et pour clé tel, pour valeur le numéro de téléphone que j'ai passé. Seulement, on se rend bien compte que, lorsque l'on définit une fonction, les paramètres de la fonction, si on les choisit bien, si on a des noms qui sont explicites, il est beaucoup plus facile de se souvenir du nom des paramètres que de leur ordre. Est-ce que j'ai mis le nom ou le prénom avant ? Est-ce que le téléphone est entre le nom et le prénom ? Ça, on a du mal à s'en souvenir ; par contre, se souvenir qu'on a un paramètre nom, un paramètre prénom et un paramètre tel, est quelque chose de très facile. Donc Python vous permet d'utiliser cette possibilité en vous permettant d'appeler une fonction avec ce qu'on appelle des **arguments nommés**. Regardons comment cela fonctionne.

Lorsque j'appelle ma fonction *agenda*, au lieu de passer mes arguments dans l'ordre de définition des paramètres, je peux donner explicitement le nom des paramètres auxquels je veux passer mes arguments. Regardons cela. Je vais donc appeler ma fonction avec tel égale un numéro de téléphone, nom égale 'idle', je rappelle ma ligne, et prenom égale 'eric'. On voit que j'ai défini mes arguments que j'ai passé mes arguments à ma fonction dans un ordre quelconque, par contre, je les ai nommés en fonction des paramètres définis dans l'en-tête de ma fonction. Il est très important que les noms que vous donnez, ce soient exactement les nom qui sont définis dans les paramètres de la fonction. J'exécute mon *agenda* et on voit que mon dictionnaire a été construit parfaitement avec le nom qui est bien idle, le prénom qui est bien eric et le téléphone qui est bien un numéro de téléphone. Maintenant, lorsque je définis ma fonction, je pourrais tout à fait dire j'aimerais bien avoir des paramètres optionnels. Par exemple, si jamais je ne passe pas de numéro de téléphone, j'aimerais avoir par exemple un point d'interrogation à la place du numéro de téléphone, ce qui me permettrait par exemple d'afficher une valeur par défaut. Bien c'est possible en Python, en mettant justement ces **paramètres optionnels**. Comment est-ce que je définis cela ? Je définis ça avec mon paramètre suivi de égal suivi de la valeur qui sera passée à ce paramètre si jamais je ne le spécifie pas lors de l'appel de la fonction. Regardons cela. J'évalue ma fonction et maintenant j'appelle ma fonction *agenda* avec, comme arguments, 'eric', alors, le premier, c'est le nom donc je vais passer 'idle', le deuxième, c'est 'eric', donc là, évidemment, j'aurais pu passer des **arguments nommés** mais je passe des **arguments ordonnés**, et je ne passe pas de numéro de téléphone. Quel va être mon agenda ? Mon *agenda* va être nom: 'idle', prénom:'eric', téléphone: point d'interrogation. Si jamais je passe un numéro de téléphone, évidemment, c'est ce numéro de téléphone qui va être pris en compte et là, mon argument optionnel ne sera pas utilisé et donc je vois bien que maintenant mon agenda est construit avec l'argument numéro de téléphone que j'ai passé à ma fonction.

Lorsque vous définissez des **arguments ordonnés et optionnels**, c'est très important de mettre en premier les arguments ordonnés... Pardon, lorsque vous définissez l'en-tête d'une fonction, c'est très important de définir en premier **les paramètres ordonnés** et ensuite, les paramètres optionnels. Nous venons de voir deux manières de définir les paramètres d'une fonction, **paramètres ordonnés**, **paramètres par défaut**. Et nous avons vu deux manières de passer des arguments à une fonction, **arguments ordonnés, arguments nommés**.

Il existe en tout quatre manières de définir les paramètres d'une fonction, et quatre manières de passer les arguments à une fonction. Regardons ces dernières manières. La prochaine manière que je vais vous montrer, pour définir les paramètres d'une fonction, c'est **la forme étoile**. C'est une forme qui peut vous sembler un peu étrange mais qui est extrêmement pratique. Je définis une fonction *f* qui cette fois va prendre un argument qui est devancé par une petite étoile. Donc *t* va être une variable qui va référencer, nous allons le voir dans un instant, un tuple d'arguments que je passe à ma fonction. Regardons, j'ai défini ma fonction *f* qui prend étoile *t* [def f(*t):], Je fais *print(t)*. J'évalue cette fonction. Et maintenant, je peux appeler *f* sans aucun argument. Je vois qu'elle retourne un **tuple** vide. Je peux appeler ma fonction *f* avec un argument, et je vais voir qu'elle va retourner un tuple avec un élément. Je peux appeler *f* avec 2, 3, 4, 5 arguments, autant d'arguments que je veux, et elle va me retourner un tuple de ces arguments. Donc l'intérêt de cette notation étoile, et dans cette notation, ce qui est important, c'est l'étoile, ce n'est pas le nom de la variable, le nom de la variable peut être tout à fait quelconque, c'est que lorsque j'ai une forme étoile, je peux passer une liste quelconque d'arguments à ma fonction ; ces arguments vont être mis dans un tuple qui va être référencé par la variable qui suit l'étoile, donc dans notre cas, par la variable *t*.

Il existe une deuxième forme, c'est **la forme double étoile**. Je vais vous montrer le fonctionnement de cette forme. Donc je fais double étoile de d [def f(**d):] ; je vais mettre un petit *d*, vous allez voir dans quelques secondes pourquoi est-ce que je l'appelle *d*. Je sauvegarde ce code, je l'évalue avec F5, et maintenant, la forme double étoile me permet d'appeler ma fonction sans aucun argument, mais on voit que maintenant, ma fonction ne me retourne plus, enfin, mon print ne m'affiche plus un tuple mais un dictionnaire. En fait, la forme double étoile me permet de passer n'importe quel argument nommé à ma fonction. Je vais mettre nom égale 'idle', prenom égale 'eric', on voit bien que dans ma fonction *f* je n'ai jamais défini de paramètres nom ou prenom, mais la forme double étoile me permet de prendre ces paramètres. Python va prendre ces arguments nommés et les mettre dans un **dictionnaire**, la clé étant le nom de l'argument, la valeur étant l'argument que je lui passe, et on voit que maintenant j'ai un dictionnaire qui a été construit, qui vaut: nom: 'idle', prenom: 'eric'.

Alors, vous pouvez vous demander mais quel est l'intérêt de ces formes étoile et double étoile ? La forme étoile est assez évidente ; lorsque vous faites un print, vous avez remarqué que vous pouvez faire un print de 1, ça va afficher 1 ; puis vous pouvez faire un print de 1, 2, 3, 4, vous lui passez autant d'arguments que vous voulez et il va tous vous les afficher. En fait, comment est-ce que print peut faire ce type d'opération ? Simplement parce que dans l'en-tête de print, de la fonction print, il y a un argument qui s'appelle un **argument étoile** qui me permet de passer une liste quelconque d'arguments. La forme double étoile est un petit peu plus subtile, et nous en parlerons dans les compléments, elle est notamment utilisée lorsque vous construisez des *wrappers*.

Donc nous avons vu quatre manières de définir les arguments d'une fonction: **arguments ordonnés, arguments par défaut, forme étoile, forme double étoile**. Nous pouvons combiner ces différentes manières, ces différentes formes dans une même en-tête de fonction, mais ça n'est pas recommandé parce que ça crée très rapidement beaucoup de complexité, et d'ailleurs vous verrez dans les compléments les contraintes que vous avez sur la définition de ces différents paramètres. Il nous reste maintenant à voir deux manières d'appeler une fonction. Regardons cela.

Je vais définir une fonction *f* qui prend deux arguments *a* et *b* et qui va simplement faire un print de *a, b*. J'exécute ma fonction. Maintenant, j'ai ma fonction que je peux appeler. Supposons maintenant que dans le code de mon programme, j'ai à un moment une liste qui contient deux éléments, 1 et 2. Nous savons que c'est très courant, les listes sont vraiment au coeur de tous les programmes Python. De quelles manières pouvons-nous appeler cette fonction ? Une manière classique, ça serait de faire *L de 0* et puis *L de 1*. Ça va passer 1 au paramètre *a* et 2 au paramètre *b*. Ça va évidemment fonctionner, ça va m'afficher 1, 2. Seulement en Python, il y a une règle que vous devez toujours garder en tête, c'est que dès que vous manipulez des indices probablement, vous ne faites pas du code pythonique. Python vous offre vraiment la possibilité de manipuler très rarement les indices. Alors, dans ce cas-là, comment est-ce que je pourrais passer ma liste comme argument de ma fonction ? Et bien en fait, je vais passer ma liste avec une forme étoile. Que va faire cette forme étoile ? Elle va faire ce qu'on appelle du **tuple unpacking** que nous avons déjà vu. Elle va prendre chaque élément de ma liste et elle va le *unpacker* vers les paramètres de ma fonction. Il faut évidemment que j'aie le même nombre d'éléments dans ma liste que j'ai de paramètres dans ma fonction, mais si j'ai le même nombre, le *unpacking va être automatique. J'appelle ma fonction *f* avec une forme étoile, et automatiquement, 1 est passé à *a* et 2 est passé à *b*. C'est une forme extrêmement pratique qu'il faut favoriser.

Pour finir, je peux passer à ma fonction directement un **dictionnaire** avec une forme double étoile. J'aimerais vous montrer comment cela fonctionne. Je vais définir un dictionnaire *d* qui prend pour argument *a* qui vaut 1 et pour argument *b*, une valeur 2. Et maintenant, je peux appeler ma fonction *f* avec une forme double étoile *d* ; mon dictionnaire va être automatiquement passé à ma fonction. Donc là, on voit que ça, ça a très peu d'intérêt puisque je dois nommer les arguments, en même temps, je donne les valeurs ; on peut se dire: mais quel est l'intérêt de cette forme double étoile ? En fait, cette forme double étoile a de nombreux usages et je vais vous en montrer un qui est extrêmement pratique.

Vous savez que dans la fonction *print*, vous avez une forme étoile, donc vous avez une liste d'arguments, mais vous avez également des arguments nommés, par exemple, vous avez *sep* qui permet de séparer les valeurs, vous avez *end* qui permet de définir une valeur de fin lorsque je fais mon print ; et ces arguments, si jamais je veux les afficher systématiquement de la même manière, il faut les écrire à chaque fois dans mon print. Regardons un exemple, je fais un *print(1,2, sep=';', end='FIN')*. On voit bien que si à chaque fois que je devais faire ce print, ça serait extrêment laborieux. Seulement, ça serait très laborieux. Avec cette forme double étoile, en fait, je peux mettre ces arguments dans un dictionnaire, et directement les passer à ma fonction print. Regardons cela. Je vais définir un dictionnaire que j'appelle *pp* pour *pretty print*, affichage joli, et je vais lui passer ces arguments pp = (sep=';', end='FIN') . J'ai défini mon dictionnaire *pretty print*, regardons, c'est le dictionnaire, voilà, que je viens juste d'écrire. Et maintenant, je peux écrire print de 1 virgule 2 et au lieu de réécrire à la main sep: point virgule, end: FIN, je lui passe un double étoile de *d* ; et là Python va faire du unpacking du dictionnaire vers les paramètres de mon print, et automatiquement, alors, je le reprends ; j'ai passé l'argument d qui n'était pas le bon, c'est le *pp*, le pretty print évidemment. Donc je passe mon double étoile pretty print et là, les arguments vont être automatiquement passés à ma fonction print.

Nous venons de voir les différentes manières de définir les paramètres d'une fonction et de passer des arguments à une fonction. Nous avons quatre manières de définir les paramètres: paramètres ordonnés, paramètres par défaut, forme étoile, forme double étoile, et nous avons quatre manières de passer des arguments à une fonction: arguments ordonnés, arguments nommés, forme étoile, forme double étoile. Ces différentes manières de définir les paramètres et de passer des arguments à une fonction vous offrent énormément de souplesse sur la manière d'appeler les fonctions.


À bientôt !
