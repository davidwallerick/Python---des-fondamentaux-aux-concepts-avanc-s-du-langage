# MOOC INRIA / UCA : Python 3 : des fondamentaux aux concepts avancés du langage

## Arnaud Legout et Thierry Parmentelat 

## Transcriptions des videos de la semaine 5 : Itération, importation et espace de nommage

# W5-S1 Itérable, itérateur, itération

Bonjour,

Dans les précédentes semaines, nous avons vu de nombreuses notions, notamment les types *built-in*, les instructions, les fonctions, ... et nous avons également parlé de la notion de références partagées. Cette semaine, nous allons voir deux autres notions clés en Python: la **notion d'itérateur** et **d'espace de nommage**. Les **itérateurs** sont ce qui vous permet de parcourir les objets de manière simple et intuitive. Et les **espaces de nommage** vous permettent d'isoler les variables dans les objets tout en vous gardant la possibilité d'accéder aux attributs de n'importe quel objet avec une notation simple et explicite.

Nous avons vu dans une précédente vidéo la notion de **boucle for** qui vous permet de parcourir de nombreux objets comme par exemple les séquences. On a vu que les boucles *for* étaient simples et permettaient d'écrire des **itérations** qui soient expressives. Les boucles *for* reposent sur un concept majeur en Python que l'on appelle le **concept d'itérateur**. Les itérateurs en Python sont des objets simples qui définissent une interface unique que l'on appelle le **protocole d'itération**. En plus de la simplicité et de l'efficacité de ce mécanisme, la notion d'itérateur permet de découpler l'objet qui itère de l'objet qui contient les données. L'avantage est que maintenant avec un itérateur, nous avons un objet extrêmement simple et compact que l'on peut parcourir de manière intuitive. Un objet que l'on peut parcourir grâce à un itérateur s'appelle un **objet itérable**. Donc un **itérable** est un objet que l'on peut parcourir de multiples fois. Ouvrons maintenant un interpréteur Python pour découvrir cette notion d'itération.

En Python, tous les types *built-in* sont itérables sauf évidemment les types numériques puisque ça n'aurait pas de sens de les parcourir. Nous allons maintenant déconstruire la manière dont fonctionne une boucle *for* sur les *itérables*. Regardons cela avec un exemple simple. Je vais créer un ensemble *s* qui contient quatre éléments: 1, 2, 3 et la chaîne de caractères 'a'. Ensuite on sait que l'on peut faire une boucle *for* qui va parcourir chaque élément de cet ensemble, et on peut tout à fait afficher les éléments parcourus par cette boucle *for*. On peut également écrire une compréhension de liste: `[x for x in s if type(x) is int]`. Donc en fait, ça va me retourner la liste de tous les éléments de cet itérable, dans ce cas-là c'est un ensemble, lorsque ces éléments sont des entiers. Mais maintenant essayons de comprendre comment est-ce que la boucle *for* va faire pour parcourir cet objet. En fait, la boucle *for* va faire les opérations suivantes: elle va commencer par récupérer l'itérateur sur cet ensemble ; regardons, j'ai un ensemble *s* ; je peux tout à fait définir un objet *iter* sur s. `it = iter(s)` **iter** est la fonction *built-in* qui me permet de créer un itérateur sur cet objet itérable. Regardons cela. Je regarde maintenant *it* et je vois que *it* est un objet qui s'appelle `set_iterator`. Donc en appelant cette méthode *iter*, j'ai créé un itérateur sur mon objet ensemble. Maintenant, qu'est-ce que je peux faire avec cet itérateur ?

La boucle *for*, après avoir appelé cette méthode *iter*, va appeler une méthode *next*, et c'est ainsi qu'on va parcourir chaque élément de cet objet itérable. Si j'appelle `next(it)`, je vais obtenir le premier élément de mon ensemble. Et puis ensuite, je peux le rappeler, je vais obtenir le deuxième élément, le troisième élément, le quatrième élément et lorsque je n'ai plus d'élément, la méthode *next* va me retourner une exception qui s'appelle `StopIteration`. Ensuite, je ne peux plus obtenir d'autres éléments, j'obtiendrai en permanence `StopIteration`, ce qui représente bien le fait qu'un itérateur ne peut se parcourir qu'une seule fois. Je tiens à vous rassurer dès maintenant, en pratique, vous n'aurez jamais à appeler vous-mêmes les méthodes *iter* et *next* sur vos objets pour être capables de les parcourir. Ce sont les mécanismes d'itération comme par exemple les boucles *for* ou les compréhensions qui vont faire ça pour vous. Cependant, c'est très important de comprendre ce protocole d'itération parce que ça vous permettra par la suite d'écrire vos propres objets itérables ou vos propres itérateurs.

Essayons maintenant de formaliser un petit peu plus ces notions d'itérable et d'itérateur. Comme je vous l'ai expliqué, vous avez deux types d'objets, les itérables et les itérateurs. Ce sont deux types d'objets qui sont conceptuellement différents. Un **itérable** est un objet qui a une méthode `__iter__()` que l'on appelle une **méthode spéciale** ; nous parlerons largement des méthodes spéciales lorsque nous reviendrons sur les classes ; mais pour l'instant, sachez que c'est une méthode qui existe sur cet objet, et cette méthode, lorsqu'on l'appelle, elle retourne un nouvel objet qui s'appelle un **itérateur**. Cette méthode, vous pouvez l'appeler soit directement sur l'objet ou alors avec la fonction *built-in* `iter(obj)`, c'est totalement équivalent et c'est la méthode que nous avons utilisée il y a quelques instants. Un **itérateur** est un objet qui a une méthode `__iter__ ()` qui retourne l'itérateur lui-même, et une méthode `__next__` qui, à chaque fois qu'on l'appelle, va retourner un nouvel élément et ensuite `StopIteration` lorsqu'on n'a plus d'élément à parcourir. Donc un itérateur ne peut se parcourir qu'une seule fois ; on parcourt tous les éléments et lorsqu'il n'y a plus d'élément à parcourir on a `StopIteration`. Là également, on peut appeler cette méthode *next* `it._next_()` soit directement sur l'objet ou alors avec la fonction *built-in next* `next(it)`. Lorsqu'on voit ces notions d'itérable et d'itérateur, il y a plusieurs questions qu'on peut se poser.

La première question, c'est pourquoi est-ce qu'on a une méthode *iter* sur l'itérateur qui retourne l'itérateur lui-même ? La raison est simple, c'est qu'un objet itérable est itérable parce qu'il a une méthode *iter* qui retourne un itérateur ; et bien un itérateur est également itérable parce qu'il a une méthode *iter* qui retourne un itérateur. Le fait que ce soit lui-même ne change rien à l'affaire, ça reste un objet itérable. Par conséquent, tous les mécanismes d'itération, *boucle for*, *compréhension de liste*, peuvent prendre soit un itérable, soit un itérateur, et le parcourir de manière totalement simple et intuitive.

La deuxième question qu'on peut se poser est pourquoi est-ce qu'on a deux notions **itérable** et **itérateur** puisque les boucles *for* peuvent prendre ces deux objets de manière indifférente ? En fait, ces deux objets sont conceptuellement différents ; l'itérable est l'objet qui contient les données et l'itérateur est un objet simple et compact qui parcourt les données qui sont contenues dans l'itérable.

Lorsque vous manipulez des objets itérables, comme les listes, c'est votre mécanisme d'itération qui va s'occuper de parcourir ces objets. Mais dans certains cas, vous n'aurez pas d'itérable, vous aurez directement un itérateur. C'est par exemple le cas des **fichiers**. **Pourquoi est-ce que les fichiers sont des itérateurs** ? On le comprend assez aisément ; on voit bien que si on avait à lire un fichier qui fasse des dizaines de megabytes ou des centaines de megabytes, ça serait une mauvaise idée d'avoir entièrement à le charger en mémoire. Or, le seul moyen d'avoir un itérable, c'est d'avoir un objet qui contient toutes les données en mémoire. Donc le choix de Python a été de dire pour les fichiers, on a un itérateur qui va parcourir ligne par ligne le fichier qui est contenu sur le disque dur. Évidemment, si vous avez le besoin de stocker toutes les lignes d'un fichier dans une liste, vous pouvez le faire mais vous le ferez de manière explicite. Regardons maintenant de nouveau le fonctionnement des itérateurs et notamment le fait qu'un itérateur ne peut se parcourir qu'une seule fois. Pour cela, ouvrons un interpréteur Python pour jouer avec les itérateurs.

Créons maintenant deux listes. Je vais créer une liste *a* qui contient deux éléments, 1 et 2. `a=[1,2]` Et je vais créer une liste *b* qui contient deux éléments, 3 et 4. `b=[3,4]` Donc maintenant, j'ai deux listes *a* et *b*, ce sont des objets *listes*, je peux très bien prendre un itérateur sur ma liste, et je vais voir que j'ai un nouvel objet qui s'appelle **list_iterator**. Mais en pratique, je n'ai pas besoin de le faire, mon objet *liste* est itérable et je peux faire autant de boucles *for* que je le souhaite sur cet objet. En fait, comme on le sait, ma liste va contenir une référence vers les objets qui sont contenus dans la liste, par conséquent, mon objet *liste* existe en mémoire. Mais regardons maintenant un autre type d'objet. Créons un nouvel objet qui est un objet *zip* qui va prendre deux listes, *a* et *b*. `z = zip(a,b)` Que fait la fonction *built-in* `zip` ? En fait, elle va prendre le premier élément de chaque liste, elle va le mettre dans un **tuple**, puis ensuite, elle va prendre le deuxième élément de chaque liste, le mettre dans un *tuple*. On voit bien dans ce cas-là qu'il n'y aurait pas vraiment d'intérêt à créer une structure de données temporaire qui contiendrait la liste de tous les *tuples*. Donc le choix de Python a été de créer un objet *zip* qui est en fait un itérateur. Regardons cela.

J'ai mon objet *zip* qui est un objet *zip* classique et si je regarde est-ce que `z is iter(z)` ? C'est-à-dire est-ce que *z* est son propre itérateur ? Je vois que c'est le cas. Donc maintenant j'ai la certitude qu'il s'agit d'un **objet itérateur**. Par conséquent, je ne peux le parcourir qu'une seule fois. Donc maintenant, si je fais une compréhension de liste, `[i for i in z]`, je vais obtenir la liste des *tuples* qui contiennent le premier élément de chaque liste puis le deuxième élément de chaque liste. Regardons cela, j'ai effectivement `[(1, 3), (2, 4)]`. Mais si maintenant, je fais une deuxième compréhension de liste, je vais obtenir une liste vide. En effet, mon itérateur a été consommé, maintenant il est vide, je ne peux plus le parcourir. Et je peux le vérifier en faisant un `next(z)` ; je vais bien voir que j'ai `StopIteration` donc mon itérateur a été consommé.

Le principe des **itérateurs**, c'est que les itérateurs sont des objets simples et compacts, qui sont très peu coûteux à créer. Par conséquent, si je veux une nouvelle fois parcourir les couples de premiers éléments de mes listes et de deuxièmes éléments de mes listes, je n'ai qu'à recréer un nouvel objet itérateur ; c'est extrêmement peu coûteux à créer puisque cet objet ne va rien parcourir et ne va faire aucun calcul. Et en fait, le calcul ne sera fait qu'au moment où je vais itérer sur cet itérateur, donc de nouveau, je peux bien parcourir les éléments de ma liste.
Donc gardez bien en tête que les itérateurs sont des objets simples et compacts, que l'on ne peut parcourir qu'une seule fois ; par contre, en général, créer un nouvel itérateur est très peu coûteux donc nous pouvons en créer à chaque fois que nous en avons besoin d'un nouveau.

Nous venons de voir le concept d'**itérable** et d'**itérateur** ; nous avons vu que l'itérable est un objet que l'on peut parcourir autant de fois que l'on veut avec n'importe quel mécanisme d'itération en Python ; et que l'itérateur est un objet simple et compact que l'on ne peut parcourir qu'une seule fois.

À bientôt !

# W5-S2 Objet fonction, fonction lambda, map et filter


Python est un langage **multiparadigmes** qui supporte évidemment la programmation objet, mais qui supporte également certains concepts de programmation fonctionnelle. Pourquoi est-ce que Python supporte ces différents paradigmes ? C'est simplement pour en faire un langage simple et puissant et facile à utiliser. Donc Python n'est pas un langage dogmatique, c'est un langage qui utilise ce dont on a besoin là où on en a besoin. Dans cette vidéo, nous allons parler des **fonctions lambda**, nous allons expliquer que les fonctions étant des objets, on peut les passer comme argument à d'autres fonctions, et nous allons parler des fonctions *built-in* `map` et `filter`. Commençons par parler des fonctions `lambda` .


Les **fonctions lambda** sont en fait des fonctions qui sont anonymes. Alors on peut se demander mais **à quoi sert une fonction lambda** ? En fait, en introduction, il faut savoir que tout ce qu'on peut faire avec une fonction lambda, on peut le faire avec une fonction traditionnelle. Par conséquent, les fonctions lambda ne sont en rien nécessaires. Elles constituent simplement une facilité d'utilisation pour écrire du code, parfois, qui est plus simple et expressif. En fait, une fonction lambda, la principale différence entre une fonction lambda et une fonction traditionnelle est qu'**une fonction lambda est une expression**. Par conséquent, on peut définir une fonction lambda partout où on peut avoir une expression, par exemple, lorsque l'on écrit une liste, un dictionnaire, ou alors lorsque l'on veut passer directement un argument à une fonction. Maintenant, ouvrons un éditeur IDLE pour commencer à jouer avec ces concepts.

Regardons comment écrire une fonction lambda. C'est très simple, on va commencer avec le mot-clé *lambda*, suivi d'un paramètre, on pourrait avoir plusieurs paramètres, et ensuite je vais mettre une expression que je calcule à partir de ces paramètres. Donc là, je vais simplement prendre x au carré moins 1. `lambda x:x** -1` Voilà, j'ai défini une fonction lambda, je fais un retour chariot, et je vois que ma fonction lambda a été créée. Évidemment, comme cette fonction n'a pas de nom, je n'ai pas de référence vers cette fonction, je ne peux donc pas l'utiliser directement. Donc ma fonction lambda, je peux lui donner un nom, je vais rappeler mon expression précédente, et je vais lui donner un nom, voilà, le nom *carré*. `carre = lambda x:x** -1` Donc maintenant, j'ai une variable qui va référencer cet objet fonction, je peux donc maintenant appeler ma fonction *lambda* comme une fonction traditionnelle. Évidemment, maintenant que je lui ai donné un nom, ça perd un petit peu de son intérêt puisque ça devient une fonction nommée un peu comme une fonction classique.

Regardons un usage pratique d'une fonction lambda. Je vais définir une fonction, que je vais appeler image de f `def image(f):`. Et maintenant, je vais faire une boucle *for*, `for x in range(10):` et ici, je vais simplement faire un print de, alors je vais prendre une f-string qui va m'afficher f de x deux points x Je vais donc calculer ma fonction f sur x et ensuite, je vais montrer quelle était la valeur que j'ai passée à ma fonction. `print(f"{f(x)}:{x}")`. Donc ici, évidemment, quand je vais appeler *f* entre parenthèses x, je suppose que je passe bien une fonction à ma fonction *image*. Exécutons ce code. Et je l'évalue avec F5. J'ai maintenant une fonction image voilà, tout à fait normale, et qui accepte comme argument un objet qui doit être une fonction. Je vais donc maintenant lui passer directement une fonction lambda. Regardons cela. `image(lambda x: x**2 -1)` En fait, on voit que j'ai directement passé un objet fonction à ma fonction image ; ça m'évite d'avoir à définir une seconde fonction avec une instruction `def`. J'exécute ma fonction et je vois bien s'afficher les différentes valeurs, donc je vois le résultat de `f(x)` et je vois la valeur de *x*. Évidemment, il faut bien comprendre que, à aucun moment, je n'ai absolument besoin d'avoir cette fonction lambda ; je peux tout à fait définir ici une fonction que je vais appeler carré carré de x, `def carre():` et qui en fait va juste retourner ce que me ferait ma fonction lambda, x au carré moins un. `return x**2 -1` J'évalue ce code, je retourne dans mon interpréteur, et maintenant, je peux tout à fait faire `image(carre)`. Alors, je vous montre ça ; *image* est une fonction, *carre* est une autre fonction, et je peux donc passer *carre* en argument de *image*, et je vais donc avoir exactement le même résultat qu'avec ma fonction lambda. Donc il faut vraiment voir la fonction lambda comme quelque chose qui permet d'écrire du code parfois plus simple et expressif qu'avec une autre fonction classique.

J'aimerais maintenant finir en vous parlant des fonctions `map` et `filter`. *map* et *filter* sont deux primitives de **programmation fonctionnelle**. *map* permet d'appliquer une fonction à chaque élément d'un itérable. Regardons comment *map* fonctionne. Je vais écrire `m = map` je vais passer une fonction, donc la fonction *carre* que j'ai déjà utilisée, qui va calculer `x**2 -1` sur chaque élément de mon itérable, et comme itérable, je vais passer un range de 10. Je vais donc appliquer ma fonction carré à chaque élément de range de 10. `m = map(carre, range(10))`Exécutons ça et regardons *m*. *m* est un objet *map*. Comment est-ce que je peux voir les différents éléments de mon objet ? Je vais simplement faire une liste de *m* si j'ai besoin d'accéder aux éléments de mon objet, ou alors, j'aurais tout à fait pu prendre la somme de ses éléments pour calculer la somme sans avoir créé de liste temporaire. Maintenant, regardons la fonction `filter`. La fonction *filter* permet de filtrer les éléments d'un itérable en fonction d'un test. Regardons comment cela fonctionne. Je vais définir un *filter* de et là, je vais prendre comme fonction une fonction lambda, pour avoir à écrire un petit peu moins, lambda de *x* deux points le reste de la division entière de x par 2 égale 0. Donc ça veut dire que ce test est vrai que pour les éléments pairs, et je vais passer un *range* de 10. Donc je vais appliquer *filter* à chaque élément d'un range de 10. Je vois que j'obtiens un objet filter ; cet objet, je peux maintenant l'affecter à une variable, et après, comme cet objet est itérable, je peux le parcourir ou afficher la liste correspondant à cet objet pour voir les objets qui ont été filtrés. `f = filter(lambda x: x%2 == 0, range (10))` Donc vous pouvez voir que ces fonctions *map* et *filter* vous permettent d'appliquer une fonction à chaque élément d'un itérable, et vous permettent de filtrer les éléments d'un **itérable**. Cela devrait vous faire penser à quelque chose. En fait, ça devrait vous faire penser à la **compréhension de liste**. En fait, la compréhension de liste permet de faire exactement ce que font les fonctions *map*  et *filter*. *map* et *filter* sont dans un paradigme de programmation fonctionnelle et les compréhensions de liste correspondent plus à une manière pythonique d'écrire l'application d'une expression à chaque élément d'un itérable et un critère de test. En Python moderne, on préfère utiliser les compréhensions de liste aux fonctions *map* et *filter*.

Dans cette vidéo, nous avons vu la notion de fonction lambda, nous avons également vu le fait que les fonctions peuvent se passer comme argument d'autres fonctions puisque les fonctions sont des objets tout à fait normaux, et nous avons également vu les fonctions built-in *map* et *filter*. *map* permet d'appliquer une expression à chaque élément d'un itérable, et *filter* permet de trier cet itérable. Un point important sur *map* et *filter*, c'est que *map* et *filter* produisent des itérateurs. Ça veut dire qu'on ne peut les parcourir qu'une seule fois. Si vous voulez parcourir de multiples fois le résultat d'un *map*, il faut simplement produire un nouvel objet *map*. Je vous ai également dit que, en Python moderne, on préférait utiliser les compréhensions de liste. Cependant, les fonctions *map* et *filter* ont un avantage majeur par rapport aux compréhensions de liste. Lorsque vous faites une compréhension, vous créez un nouvel objet liste, même si vous n'avez pas forcément besoin de cet objet. Imaginez par exemple que vous vouliez faire la somme des éléments de cette liste, vous n'avez pas besoin de cette liste temporaire. Les fonctions *map* et *filter*, au contraire, produisent un objet extrêmement compact. Nous verrons dans une prochaine vidéo que nous pouvons **étendre les compréhensions de liste** à une notion qui s'appelle **expression génératrice** qui a l'avantage des compréhensions de liste avec une syntaxe simple et expressive, et l'avantage des fonctions *map* et *filter* en produisant directement des itérateurs.

À bientôt !

# W5-S3 Compréhension de listes, sets et dictionnaires

Dans une précédente vidéo, nous avons introduit la notion de **compréhension de liste**. Les compréhensions de liste, lorsqu'elles ont été introduites en Python, ont très vite rencontré un énorme succès. Et ce succès a été tel qu'elles ont été étendues aux notions de *set* et de *dictionnaire*. Dans cette vidéo, nous allons vous présenter ces différents **mécanismes d'itération**. Ouvrons maintenant un interpréteur Python pour jouer avec les compréhensions de liste, de set et de dictionnaire.


La syntaxe des compréhensions est simple et intuitive, c'est pour ça qu'elle rencontre un grand succès, elle est d'ailleurs proche du langage naturel. Regardons maintenant un exemple. Je vous rappelle comment fonctionne une compréhension de liste ; je vais prendre une liste de prénoms `prenoms = ['ana', 'eve', 'ALICE', 'Anne', 'bob']` Et vous remarquez que lorsque je rentre mes prénoms, je n'ai pas de capitalisation consistante, et ce sera d'ailleurs la base du traitement que je vais vous montrer. J'ai donc créé une liste avec quelques prénoms et les prénoms n'ont pas de capitalisation consistante. Regardons cela. Voilà. Maintenant, imaginons que je veuille créer une liste de tous les prénoms qui commencent par *a* et mettre ces prénoms en minuscule. Donc, je peux faire ça avec une **compréhension de liste**, je vais créer *a_prénoms* qui va représenter la liste de tous les prénoms mis en minuscule et qui commencent par *a*, et je vais faire un `[p.lower()` - pour dire: je mets mes prénoms en minuscule-  `for p in prenoms if p.lower().startswith ('a')]`. Exécutons cette compréhension, regardons le résultat maintenant ; j'obtiens bien la liste de tous les prénoms mis en minuscule.

Maintenant, j'aimerais reprendre ma liste de prénoms et l'étendre. Donc je vais faire un *extend* de prenoms : `prenoms.extend(prenoms)`. Donc, qu'est-ce que j'ai fait ? J'ai pris ma liste de prénoms et j'ai dupliqué tous les prénoms, donc maintenant, ma liste de prénoms est la suivante : `['ana', 'eve', 'ALICE', 'Anne', 'bob', 'ana', 'eve', 'ALICE', 'Anne', 'bob']`. Je reprends ma compréhension de liste précédente ; je calcule la liste des prénoms en minuscule qui commencent par *a* et regardons maintenant cette liste. J'ai bien ma liste de prénoms mais avec des prénoms dupliqués. Donc je pourrais tout à fait vouloir calculer uniquement les prénoms uniques. Comment est-ce que je fais ça traditionnellement en Python ? Je vais simplement transformer ma liste en *set*. Donc je vais calculer un *set(prenoms)*, et je vais obtenir la liste unique, alors *set(a_prenom)*, et j'obtiens l'ensemble unique des prénoms mis en minuscule qui commencent par la lettre `*a*. Seulement vous voyez ici que vous avez un problème, vous avez créé une liste temporaire qui en fait, ne vous sert essentiellement à rien puisqu'après, vous voulez uniquement les prénoms uniques. Donc on se dit que ça serait vraiment pratique de pouvoir directement obtenir la liste des prénoms uniques à partir d'une compréhension. Et bien, en fait, en Python, c'est extrêmement simple. Regardons cela.

Je reprends ma liste de prénoms qui est la liste suivante  `['ana', 'eve', 'ALICE', 'Anne', 'bob', 'Ana'. 'eve', 'ALICE', 'Anne', 'bob']`  et je vais reprendre la compréhension de liste que j'ai écrite `a_prenoms = [p.lower() for p in prenoms if p.lower().startswith la lettre 'a')]`. Ma compréhension de liste dit simplement je prends les prénoms en minuscule pour les prénoms qui sont dans ma liste de prénoms, et uniquement s'ils commencent par la lettre *a*. Comment transformer ça en compréhension de *set* ? Je n'ai qu'à remplacer les crochets par des accolades. Donc on voit que c'est extrêmement simple ; il suffit simplement de changer les crochets qui entourent ma compréhension par des accolades. Je calcule cela, et maintenant, regardons ce que contient *a_prenoms* ; il contient bien l'ensemble des prénoms uniques mis en minuscule qui commencent par la lettre *a*. Donc on voit qu'en une seule expression simple, expressive, intuitive et facile à lire et à écrire, j'ai pu faire un traitement extrêmement sophistiqué. J'insiste d'ailleurs sur le point suivant, c'est que, lorsque je crée une **compréhension de set**, à aucun moment, je ne crée une liste temporaire ; ce *set* est créé à la volée en parcourant les éléments de ma liste de prénoms et en faisant les calculs au fur et à mesure. C'est donc quelque chose d'extrêmement compact, simple et intuitif à utiliser.


Regardons maintenant le fonctionnement de la **compréhension de dictionnaire**. Donc pour cela, je vais créer un dictionnaire tout simple, que je vais appeler *ages*, et qui est égal à
 `ages = [('ana',20), ('EVE',30), et ('bob',40)]`. Donc ici, j'ai créé une **liste de tuples** et je vais créer mon dictionnaire de la manière suivante : `ages = dict(ages)`. Donc maintenant, *ages* contient bien un dictionnaire qui a pour clé 'EVE', pour valeur 30, clé 'ana', valeur 20, clé 'bob', valeur 40. Maintenant, supposons que je veuille obtenir le même dictionnaire mais dans lequel toutes les clés sont mises en minuscule, donc je corrige les problèmes de capitalisation. Donc là, on pourrait très bien faire une boucle *for* et itérer dessus, mais je vais faire ça directement avec une **compréhension de dictionnaire**. Regardons comment je fais ça. Je vais appeler ça *ages_fix*, donc c'est ages dans lequel j'ai fixé les problèmes de capitalisation, est égal à, je mets des accolades comme une compréhension de *set*, mais maintenant, je vais séparer mes clés *p.lower* : de mon age, et je vais écrire `ages_fix = {p.lower():a for p, a in ages.items()}`. Donc en fait, qu'est-ce que j'ai fait ? Je parcours les items de mon dictionnaire *ages* ; le premier élément, la clé, c'est un prénom, le deuxième élément, c'est un âge, c'est pour ça que je les appelle *p, a* ; et dans mon dictionnaire, je vais construire les prénoms en minuscule : les âges. Regardons le résultat de ce dictionnaire *ages_fix* `{'ana': 20, 'bob':40, 'EVE':30}`, et je vois bien que maintenant j'ai fixé ce problème, j'ai maintenant tous mes prénoms mis en minuscule. De même, j'aurais très bien pu rajouter un test pour dire par exemple je veux simplement les prénoms : les âges mis en minuscule si l'âge est inférieur à, par exemple, 40  `ages_fix = {p.lower():a for p, a in ages.items() if a < 40}`. Et donc là, j'exécute de nouveau ma compréhension de dictionnaire, et je regarde le résultat *age_fix* ; maintenant, j'ai bien un dictionnaire qui contient uniquement les prénoms mis en minuscule et les entrées pour lesquelles les âges sont strictement inférieurs à 40 ans.

Les **compréhensions** en Python représentent un outil extrêmement puissant puisqu'avec exactement la même syntaxe, la syntaxe des compréhensions de liste, on peut créer des sets et des dictionnaires. Nous verrons dans une prochaine vidéo qu'on peut étendre ce concept à la notion d'**expression génératrice** qui nous permet de nous passer de la création de liste temporaire pour directement obtenir un itérateur.


À bientôt !

# W5-S4 Expressions et fonctions génératrices : 1.


Dans une précédente vidéo, nous avons vu les notions de compréhensions, compréhensions de liste, de *set* et de dictionnaire. Et nous savons que les compréhensions constituent un moyen extrêmement simple et expressif de parcourir des itérables et d'appliquer des traitements sur ces itérables. Ces compréhensions cependant ont un inconvénient majeur, c'est qu'elles créent des structures de données temporaires ; une compréhension de liste va créer une liste temporaire. Or, si par exemple, on veut juste calculer, au final, uniquement la somme des éléments calculés par cette compréhension, on a créé une liste pour rien. Nous allons voir dans cette vidéo la notion **d'expression génératrice**. Une **expression génératrice** s'écrit exactement comme une compréhension de liste, mais la différence, c'est que ce qui sera retourné sera un **itérateur** et non pas une liste temporaire. C'est donc quelque chose qui permet d'économiser énormément de mémoire tout en gardant toute la fonctionnalité d'une compréhension. Nous verrons également dans cette vidéo la généralisation des expressions génératrices que l'on appelle **fonctions génératrices**. Ouvrons maintenant un interpréteur Python pour jouer avec les expressions et les fonctions génératrices.

Commençons par prendre un exemple de **compréhension de liste**. Je vais créer une liste *carre* qui va prendre les carrés pour x in range de 1000. `carre = [x**2 for x in range(1000)]`. Donc j'ai créé une compréhension de liste, donc maintenant, lorsque je fais un retour chariot, j'ai une liste qui est créée en mémoire et qui contient les carrés de tous les entiers allant de 0 à 999. Mais supposons maintenant que je veuille simplement calculer la somme de ces carrés. Pour calculer la somme des éléments d'un **itérable**, on peut utiliser la fonction *built-in* `sum` Et le résultat est le résultat suivant : `sum(carre) 332833500`. Sauf que pour calculer la somme de ces éléments, je n'ai absolument pas besoin de créer une liste temporaire qui contient tous ces éléments. C'est pour cela que je peux utiliser une **expression génératrice**. Alors, vous pouvez vous demander est-ce que l'expression génératrice, c'est compliqué à écrire ? Non, on va voir que c'est extrêmement simple.

Je reprends ma compréhension et je vais remplacer les crochets par simplement des parenthèses. Je ne fais rien d'autre, je fais un retour chariot. Maintenant, lorsque j'ai fait le retour chariot, aucune liste n'a été créée. À la place, j'obtiens un objet *carré* qui s'appelle `generator_object`. C'est en fait un itérateur qui va calculer à la volée le carré de chaque élément retourné par *range* de 1000. Comme *range* est également un objet qui ne crée pas de liste temporaire mais qui retourne, à chaque fois qu'on l'appelle, l'entier suivant, en fait, je peux parcourir tous les éléments de cette expression génératrice sans jamais créer de structure temporaire. Maintenant, je peux calculer la somme de *carré* ; on va voir que je vais obtenir le même résultat qu'avec la liste mais la grande différence, c'est que je n'ai pas créé de liste temporaire. J'insiste sur le fait que cette expression génératrice est un **itérateur** ; par conséquent, si je calcule de nouveau somme de *carré*, je vais obtenir 0 puisque cet itérateur a été consommé une première fois, il ne génère plus aucun élément. Je peux m'en assurer en faisant un `next(carre)`, je vois bien que j'ai la fameuse exception `StopIteration`, qui veut dire que mon itérateur a été consommé. Mais comme la création d'un **générateur** est une opération extrêmement peu coûteuse puisque, lorsque je crée mon générateur, je ne fais absolument aucun calcul, et que les calculs seront faits à la volée, lorsque j'en ai besoin, je peux très facilement recréer un générateur et de nouveau calculer la somme des carrés.

Un intérêt des expressions génératrices, c'est qu'on peut les **chaîner**. Ça nous permet donc d'avoir une succession de traitements qui peut s'exécuter sans jamais avoir besoin de créer des objets temporaires. Regardons un exemple. Je vais créer un générateur de carrés `gen_carre` qui est égal à l'expression génératrice qu'on a déjà utilisée
`(x**2 for x in range(1000))`. Là, j'ai mon générateur qui génère les carrés. Et ensuite, je vais créer un deuxième générateur `palin` que je vais appeler **palindrome**. Alors, qu'est-ce qu'un palindrome ? Un palindrome, pour un nombre, c'est un nombre qu'on peut lire de gauche à droite ou de droite à gauche. Par exemple, 121 est un palindrome, qu'on le lise de gauche à droite ou de droite à gauche, ça fait toujours 121. Et donc, j'aimerais faire un générateur qui soit capable de détecter les palindromes dans, par exemple, les carrés des entiers allant de 0 à 999. Regardons cela. Je mets des parenthèses pour dire que c'est une expression génératrice et je fais `palin = (x for x in gen_carre` - Donc c'est ici que je chaîne mon générateur `gen_carre` avec mon générateur palindrome - `if str(x) == str(x)`- et maintenant, je fais mon test pour le palindrome -  c'est très simple, je convertis mon entier en chaîne de caractères et je regarde si c'est égal à cet entier converti en chaîne de caractères lorsque je le renverse, et je le renverse avec un slice de pas -1. `[::-1]`./  `palin = (x for x in gen_carre if str(x) == str(x)[::-1])` /.Donc j'ai créé mon expression génératrice sur les palindromes, je l'exécute et maintenant, si je regarde `palin`, j'ai bien un objet générateur. Maintenant, si je veux obtenir ces palindromes dans une liste, je peux forcer la création de la liste mais maintenant, je le fais de manière explicite, donc je dis `list(palin)` et j'obtiens bien la liste de tous les palindromes des carrés des nombres qui vont de 0 à 999.


# W5-S4 Expressions et fonctions génératrices : 2.

On voit que cette notion d'expression génératrice est très puissante et extrêmement souple. Vraiment, la tendance en Python, c'est de dire je manipule toujours des itérateurs le plus loin possible sans créer de structure de données temporaire et je ne créerai ma structure de données qu'uniquement à la fin par exemple, pour stocker mes résultats. Évidemment, cette logique est de dire qu'en Python, tout est un objet donc tout prend de la place donc c'est inutile de créer des objets si on n'en a pas besoin ; on ne les crée que quand c'est strictement nécessaire. Cependant, l'expression génératrice a une limitation, c'est que dans une expression génératrice exactement comme dans une compréhension de liste, je ne peux mettre qu'une expression. Or, si je voulais faire un traitement plus sophistiqué qu'une compréhension de liste, je me dis mais comment est-ce que je pourrais faire ça puisque je ne peux pas le mettre dans une expression ? Et bien, en fait, les expressions génératrices ont été généralisées dans un concept qu'on appelle **fonctions génératrices**. Vous pouvez créer des fonctions qui vont se comporter comme des expressions génératrices. Mais comme ce sera défini à l'intérieur d'une fonction, vous aurez toute la souplesse de ce que vous pouvez définir dans une fonction. Ouvrons maintenant un éditeur IDLE pour explorer ce concept de fonction génératrice.

Revenons sur la notion de **fonction**. Lorsque vous définissez une fonction, votre fonction retourne forcément une valeur. Si vous ne mettez pas d'instruction `return`, elle va retourner l'objet *None* ; si vous mettez une instruction `return`, elle va retourner le résultat de l'expression qui est après le `return`. Une fonction, lorsqu'elle a retourné, détruit toutes ses **variables locales** et par conséquent, ne garde aucun état entre deux appels. Une fonction génératrice a un comportement qui est différent. Regardons cela.

Pour définir une fonction génératrice, je vais définir une fonction normale que je vais appeler `gen` mais au lieu d'écrire un `return`, je vais écrire l'instruction `yield`. Et je vais mettre un *yield de 10*. Je sauvegarde ce code, je l'évalue avec F5, et maintenant, je vais dans mon interpréteur. Regardons ce qu'est cet objet `gen`. `gen` est une fonction et lorsque j'appelle ma fonction, que se passe-t-il ? J'obtiens un nouvel objet qui s'appelle un **objet générateur**. Alors on voit qu'en fait, je n'ai pas eu de valeur de retour, je ne vois pas le 10 apparaître. En fait, l'appel de ma fonction crée un objet. Cet objet, qu'est-ce que je peux en faire ? Cet objet est un **itérateur** que je manipule comme un itérateur. Regardons cela. Je vais appeler `g = gen()`, donc je mets une variable qui référence maintenant ce générateur, et maintenant, comme c'est un itérateur, je peux directement le parcourir avec *next*. Je fais `next(g)`, qu'est-ce que je vois apparaître ? La valeur qui est après le `yield` (10). Donc en fait, lorsque j'appelle le générateur, ça crée un objet générateur qui attend. Au premier appel de *next*, je vais aller jusqu'au premier *yield* et je vais retourner la valeur, l'expression qui est à côté du *yield*, puis j'attends. Donc on voit que mon objet *g* existe toujours, c'est toujours un générateur. Je rappelle *next* dessus ; maintenant, je reprends là où je me suis arrêté, c'est-à-dire au *yield* de 10, et je continue le code. Je vais jusqu'au deuxième *yield*, sauf qu'ici, je n'ai pas d'autre *yield*. Qu'est-ce qu'il va se passer ? En fait, dès que j'arrive à la fin du bloc de code de ma fonction, je vais avoir une exception `StopIteration` exactement comme un itérateur normal. Faisons un générateur un tout petit peu plus sophistiqué.

Je vais faire un générateur qui prend un argument *x* ; je vais faire un `yield x` et ensuite, je vais faire un `x = x + 1`, et ensuite, je fais de nouveau un `yield x`. Exécutons ce code et retournons dans l'interpréteur. Maintenant, je vais faire un `g = gen(10)`. Donc je crée un **générateur** et j'ai passé 10 à mon objet générateur, à ma fonction. Maintenant, *g* est bien mon générateur et je vais le parcourir comme un itérateur puisque mon générateur produit un itérateur. Mon générateur, lorsque je l'ai créé, attend. J'appelle `next`, ça déclenche son exécution, je vais jusqu'au premier *yield* ; le premier *yield*  me retourne *x*. *x* vaut 10, je vois donc apparaître 10. Ensuite, mon générateur se stoppe ; il attend avec tout son état qui est préservé, ses variables locales qui sont préservées. Je rappelle `next` dessus ; que va-t-il se passer ? Je reprends l'exécution juste là où je me suis arrêté, c'est-à-dire après le `yield x` ; je calcule `x = x + 1` maintenant, x vaut 11 ; et je *yield* ce nouveau *x*. Regardons la valeur. Maintenant, j'obtiens 11. Je rappelle `next` sur ce générateur ; je reprends là où je me suis arrêté au deuxième `yield` de x, je reprends l'exécution à ce moment-là, je sors du bloc de code ; lorsque je sors du bloc de code, j'ai `StopIteration`.

Évidemment, en pratique, vous n'allez pas mettre une multitude de `yield` ; ça serait absolument peu pratique. En pratique, vous allez faire plutôt une **boucle** par exemple, une boucle `for` ou un `while`. Regardons un exemple un peu plus réaliste. Je vais définir un générateur que je vais appeler *carré*, et qui prend deux arguments *a* et *b*. Et mon générateur carré va faire une boucle for i et dedans, je vais faire un yield de i au carré.

```
 def carre(a,b):
     for i in range(a, b):
         yeald i **2	  
```
Évaluons ce morceau de code, retournons dans l'interpréteur et maintenant, regardons quel est le résultat de 'carre(1, 10)'. J'obtiens évidemment un générateur, je récupère ce générateur avec une variable, je le nomme avec une variable *c*, et maintenant, je peux tout à fait mettre ce générateur par exemple dans une liste, parce que j'ai fini mon calcul et je veux récupérer le résultat dans une liste. J'aurais pu faire une boucle *for*, une compréhension sur ce générateur, de manière équivalente ; et j'obtiens bien ici mes carrés allant de 1 jusqu'à 10. On voit bien que dans ce cas extrêmement simple d'un générateur qui produit juste les carrés, on aurait pu mettre ça dans une expression génératrice. Regardons un cas encore un peu plus sophistiqué où ça serait moins commode d'écrire ce fonctionnement dans une expression génératrice. Pour cela, je vais créer un **générateur** que je vais appeler *palindrome*. Et je vais lui passer directement un itérateur, enfin, un **objet itérable**. Et puis ensuite, je vais faire un `for i in it:` - cet objet itérable -  et dedans, je vais regarder si `isinstance`. Ça veut dire quoi ? Ça veut dire si *i* est une instance soit d'une chaîne de caractères soit d'un entier, deux possibilités. `and` -  alors, je vais mettre tout ça entre parenthèses parce que je vous rappelle que, lorsqu'on écrit une expression entre parenthèses, on peut la mettre sur plusieurs lignes -  et *str de i égale égale à str de i en le renversant moins un* `str(i) == str(i)[::-1])` alors - il ne faut pas que j'oublie mon deux points de fin de bloc de code - , alors, je vais simplement faire un `yield de i`. Regardons de nouveau cette expression génératrice. Mon palindrome, ma fonction palindrome, va prendre un itérable ; il va parcourir cet itérable et il va regarder chaque élément: est-ce que c'est un entier ou une chaîne de caractères ? Si c'est un entier ou une chaîne de caractère, il va dire: je sais travailler dessus, je vais le convertir en chaîne de caractères donc si c'est un entier, ça devient une chaîne, si c'est une chaîne, ça reste une chaîne, et je regarde si cette chaîne est égale à la chaîne prise dans l'autre sens, donc effectivement, si c'est un palindrome.

J'exécute cela. Et maintenant, je retourne dans mon **interpréteur**, et je vais évaluer ça. Donc ici, pour commencer comme exemple, je vais simplement lui passer une liste. Donc je vais dire: *p égale la liste qui comprend 121, 10, 12321* donc on voit que j'ai quelques palindromes, et puis des chaînes de caractères 'abc', et puis 'abba'. 'p = palin([121, 10, 12321, 'abc', 'abba'])`. Voilà. J'exécute mon itérateur et maintenant, je récupère tout cela dans une liste, et je vais pouvoir extraire les palindromes, que ce soient des entiers ou des chaînes de caractères.

Évidemment, l'intérêt principal de ma **fonction génératrice** n'est pas de prendre une liste temporaire mais de travailler directement sur un **itérateur**. Donc, par exemple, j'aurais tout à fait pu lire, ouvrir un fichier qui contient, sur chaque ligne, un nombre ou une chaîne de caractères et passer directement cet objet fichier à mon générateur palindrome. Dans ce cas, je n'aurais créé aucune structure temporaire, mon générateur palindrome aurait extrait les palindromes contenus dans ce fichier et après, j'aurais pu les mettre dans une liste, dans un ensemble, ou j'aurais pu les traiter d'une autre manière.

Je vais vous montrer une dernière possibilité d'exécuter ce palindrome. Donc on va faire `list(palin)` pour voir le résultat affiché ; et à mon palindrome, je vais simplement lui passer une **expression génératrice**, qui va être les *carrés de x pour x in range de 1000*  `list(palin(x**2 for x in range(1000)))`. Et donc là, ici, j'ai passé une expression génératrice à ma fonction génératrice palindrome, donc je n'ai aucune structure de données temporaire qui est créée ; mon expression génératrice va générer les carrés un à un, elle va les passer un à un à mon générateur palindrome, et mon générateur palindrome va ensuite produire les palindromes qui sont contenus dedans. Vous noterez d'ailleurs que lorsque je passe une expression génératrice à une fonction, les parenthèses sont facultatives et dans ce cas-là, je ne les ai pas mises. Regardons le résultat. Et on voit maintenant que j'ai obtenu la liste de tous les palindromes des carrés allant de 0 à 999 sans avoir créé aucune structure de données temporaire.

Je vous rappelle qu'en Python tout est un objet, donc tout a un surcoût mémoire. Python vous encourage à ne jamais créer de structure de données temporaire. C'est pourquoi nous avons les notions *d'expression génératrice* ou de **fonction génératrice**. Et comme ces objets produisent des *itérateurs* et que le protocole d'itération est universel en Python, vous pouvez utiliser ces expressions ou ces fonctions génératrices absolument dans tous les mécanismes d'itération en Python, les boucles *for* ou d'autres mécanismes d'itération.  


À bientôt !

# W5-S5 Modules et espaces de nommage


Lorsque nous avons parlé de la notion de **portée de variable**, nous avons expliqué que nous pouvions avoir une variable d'un nom donné, par exemple une variable *x*, qui coexiste dans le même fichier à l'intérieur d'une fonction et à l'intérieur d'un module. Nous avons également expliqué que les modules isolaient complètement leurs variables. Comment est-ce que ce  **mécanisme d'isolation des variables** fonctionne ? Il fonctionne avec ce qu'on appelle des **espaces de nommage**. Un espace de nommage regroupe un ensemble de variables appartenant à un objet. En Python, les modules, les fonctions et nous verrons également les classes et les instances, définissent des espaces de nommage. Dans des langages comme le C, où vous n'avez pas cette notion d'espace de nommage, il faut faire extrêmement attention de ne pas définir des variables qui se surchargent l'une l'autre, qui s'écrasent l'une l'autre. Et en Java, qui est un langage orienté objet, qui a également une notion d'espace de nommage, vous devez créer des classes à chaque fois que vous voulez isoler les espaces de nommage. En Python, comme les modules définissent des espaces de nommage, vous avez quasiment gratuitement cette notion d'isolation des variables dès que vous commencez à écrire votre première ligne de code. Nous allons voir dans la suite comment est-ce que les modules isolent les variables à travers les espaces de nommage.


Regardons cette notion d'isolation des variables par les espaces de nommage dans les modules. Je vais commencer par créer un module `spam.py`, donc un fichier python qui s'appelle `spam.py`. Dedans, je définis une variable *x = 1* puis ensuite une fonction *f* qui va faire print de x, et je définis un deuxième fichier python, `egg.py`, qui va importer *spam*, qui va faire *x = 2*, *def(f)*, donc on va définir une fonction *f*, qui fait *print de x*, ensuite, j'appelle la fonction *f*, j'appelle `spam.f()` et ensuite je fais un `print(spam.x)`.

Maintenant, vous pouvez prendre quelques instants pour avoir le temps de taper ces différents morceaux de code, et nous nous retrouvons dans quelques instants. Vous pouvez ouvrir une ligne de commande, par exemple `cmd` sous Windows, ou alors `bash` sous Linux, et vous allez taper à votre ligne de commande `python egg.py`, ce qui veut dire que vous allez lancer le programme à partir de `egg.py`. Regardons maintenant ce qu'il va se passer.

Je vais définir l'espace des objets, donc c'est la mémoire de mon ordinateur qui va contenir tous les objets créés, et je vais définir les espaces de nommage. Ici, on se focalise sur l'espace de nommage des modules donc je ne vais pas montrer les espaces des fonctions ; on va avoir un espace de nommage pour *spam* et un espace de nommage pour *egg*. Je vous rappelle cependant que les fonctions ont leur propre espace de nommage qui est créé à l'appel de la fonction et détruit dès que la fonction retourne. Maintenant, commençons par la première ligne de code ; la flèche rouge vous montre le fonctionnement de l'interpréteur, comment est-ce que l'interpréteur va évaluer chaque ligne de code. Ma première ligne de code, lorsque j'appelle `python egg.py`, consiste à évaluer `import spam`. Je vais donc aller chercher le fichier `spam.py`, nous verrons dans une prochaine vidéo le mécanisme exact de recherche de ce fichier, et nous allons maintenant, pour créer l'objet *spam*, l'objet module *spam*, commencer à évaluer le code de `spam.py`.

La première ligne de code, dans `spam.py`, est `x = 1`. Je vais donc créer un objet entier 1 dans l'espace des objets, et une variable *x* qui est dans l'espace de nommage de *spam*. Maintenant, cette variable *x* va référencer l'entier 1. Puis j'arrive à la ligne: `def f():` ; je vais donc créer un **objet fonction** puis je vais créer une variable *f* dans l'espace de nommage de *spam* qui va référencer cet objet fonction. Je vous rappelle que le bloc de code d'une fonction n'est évalué que lors de l'appel pas lors de l'importation. Maintenant que j'ai évalué le code de *spam.py* je retourne dans le code de *egg.py*, donc dans le code de mon module *egg* ; et maintenant, j'ai fini d'importer mon module *spam*, je vais donc créer l'objet module et je vais créer une variable *spam* dans l'espace de *egg* qui va référencer cet objet module. Évidemment, l'objet module va lui-même référencer l'objet fonction et l'entier 1, mais je passe sur ce détail, je vous présente juste, pour l'instant, le découpage des espaces de nommage par module. Maintenant, je fais `x = 2` ; je vais créer l'entier 2 puis une variable *x* dans l'espace de nommage de *egg* qui référence 2. Puis je définis ma fonction *f* dans le module *egg*, donc je définis un objet fonction et une variable *f* qui référence cet objet fonction. Et maintenant, je vais commencer à appeler mes différentes fonctions. Que va-t-il se passer lorsque je vais appeler *f* ? *f* est une variable ; je vais la chercher avec la **règle LEGB**. *f* est définie en dehors de toute fonction et de toute fonction englobante, donc je vais chercher *f* dans l'espace de nommage du module, comme **variable globale**. *f* est définie et fait un print de *x*. *x*, dans ma fonction *f*, est une variable ; je cherche *x* avec la règle LEGB ; *x* n'est pas définie dans la fonction ; il n'y a pas de **fonction englobante** ; elle est définie globalement, c'est la variable globale définie dans l'espace de nommage de *egg*. Regardons ce que vaut *x* dans l'espace de nommage de *egg* ; elle vaut l'entier 2, ça va donc m'afficher l'entier 2. Maintenant, je fais un `spam.f()`. Qu'est-ce que ça veut dire exactement ? J'ai la notation "point", ça veut donc dire que je vais accéder à *f* dans l'espace de nommage de *spam*. Je vais donc appeler ma fonction *f* dans l'espace de nommage de *spam* ; ma fonction *f* fait un print de *x* ; *x* est une variable dans *spam* ; je cherche *x* avec la règle LEGB ; *x* est définie localement: non ; il n'y a pas de fonction englobante ; elle est définie globalement, c'est la variable définie dans l'espace de nommage de *spam*. Que vaut cette variable au moment de l'évaluation de *f* ? On regarde, *x* dans l'espace de nommage de *spam* vaut actuellement 1 ; ça va donc afficher l'entier 1. Puis pour finir, je fais un `print(spam.x)`, ça veut donc dire: accède à l'attribut *x* qui est défini dans l'espace de nommage de *spam*. Que vaut *x* à ce moment-là dans l'espace de nommage de *spam* ? Il vaut toujours 1, donc `print(spam.x)` va donc m'afficher l'entier 1.

Donc, en résumé, vous avez cette notation qui est très importante qui est **objet.attribut** qui veut dire: accède à l'attribut dans l'espace de nommage de mon objet. Lorsque cet objet est un module, ça veut dire: accède à l'attribut dans l'espace des **variables globales** de mon module. Nous verrons que, dans le cas des instances et des classes, nous avons un mécanisme de recherche d'attribut qui est un petit peu différent mais nous en parlerons dans une prochaine vidéo.

Les **espaces de nommage** en Python isolent les variables, mais ils n'isolent pas les objets. Par conséquent, avec des mécanismes d'espace de nommage, vous pouvez tout de même avoir des **références partagées** vers des **objets mutables**. Donc, vous avez deux variables dans deux espaces de nommage qui peuvent référencer le même objet. Cet objet étant mutable, si vous le modifiez, il sera modifié par effet de bord donc les deux variables dans les deux espaces de nommage différents verront cet objet modifié. On peut également se demander comment est-ce que les espaces de nommage sont implémentés en Python. En Python, rien n'est caché donc on peut très facilement expliquer comment sont implémentés les espaces de nommage. En fait, ils sont implémentés en général sous forme de **dictionnaires**. Comment fonctionne cet espace de nommage ? La clé du dictionnaire correspond au nom de la variable ; la valeur correspondant à cette clé va être la référence vers l'objet qui est référencé par la variable. Donc lorsque vous ajoutez une variable dans un module, ça va créer une entrée dans l'espace de nommage de ce module, donc une clé correspondant au nom de la variable et une valeur qui est une référence vers l'objet associé à cette variable.

Les espaces de nommage permettent une parfaite **isolation de vos variables**, et leur grande force est que pour accéder à l'attribut dans un autre module, dans un autre objet, vous devez utiliser une notation explicite qui est votre objet point l'attribut. Donc en rendant ce mécanisme explicite, vous n'avez plus aucun risque d'erreur ou de collision de variables par erreur. Je voudrais également rajouter que la **règle LEGB** que nous avons vue permet en fait de savoir où la variable que vous référencez a été définie, c'est-à-dire dans quel espace de nommage cette variable a été définie. En fait, Python est vraiment construit autour de cette notion d'espace de nommage et cette notion d'espace de nommage rendant l'accès aux attributs explicites facilite extrêmement le développement et la maintenance du code.

À bientôt !



# W5-S6 Processus d'importation des modules



Dans cette vidéo, nous allons parler du **processus d'importation des modules**, c'est-à-dire les différentes étapes que va suivre l'interpréteur Python du moment où on tape l'instruction *import* jusqu'au moment où on a l'**objet module**. Ouvrons un interpréteur Python pour commencer à regarder ce processus d'importation.

Lorsque l'on importe un module, on utilise l'instruction import, comme on l'a déjà vu, et par exemple, je vais ici importer le module os `import os`. *os* a deux rôles, il va définir le nom du fichier qui va être cherché sur le disque dur, qui va s'appeler `os.py` ; nous avons quelques exceptions pour certains modules qui sont directement écrits en *C* mais en général, ce sont des fichiers écrits en Python ; et ce nom, *os*, va également définir le nom de la variable qui va référencer l'objet module. Si je fais un `print(os)`, je vois bien que *os* est une variable qui référence l'objet module. Donc, maintenant regardons les différentes étapes qui vont se dérouler lorsqu'on tape `import os`. Premièrement, il faut trouver le fichier sur le disque dur. Pour trouver ce fichier sur le disque dur, l'interpréteur va regarder dans un certain nombre de répertoires ; il va commencer par regarder est-ce que le module *os* est défini dans le répertoire courant, là où vous avez démarré votre interpréteur ? Ensuite, s'il ne trouve pas ce fichier, il va le chercher dans la variable système qui s'appelle `PYTHONPATH`. Regardons cela.

J'ai, dans mon module *os*, une liste qui s'appelle *environ*, qui en fait veut dire environnement, et qui contient la liste - pardon, c'est un dictionnaire - qui contient toutes les **variables d'environnement** dans notre système. Donc regardons cette variable `PYTHONPATH` et regardons vers quoi elle est définie  `os.environ['PYTHONPATH']`; dans mon système, elle est définie vers le bureau de mon ordinateur. Donc je cherche le fichier dans le répertoire courant, puis ensuite dans `PYTHONPATH`, et si je ne le trouve pas, au final, je vais le chercher dans le répertoire des librairies standards ; évidemment, c'est pour ça qu'on peut importer n'importe quel module de la **librairie standard** sans avoir à se soucier de l'endroit où se situe ce fichier module. Lorsque l'on a un doute sur le chemin de recherche, en fait, on peut regarder dans une variable qui s'appelle `sys.path`. Donc importons le module `sys` et `sys.path` est une liste qui contient tous les chemins qui sont suivis par l'interpréteur Python dans l'ordre, du premier chemin au dernier. Cette variable étant une liste, on peut la modifier en cours d'exécution et lorsque l'on fera une importation, le processus d'importation regardera l'état actuel de cette variable. C'est ce qui nous permet, dans un programme, de pouvoir adapter les chemins de recherche des modules. Donc maintenant que j'ai trouvé mon fichier module, je vais devoir le pré-compiler ; la pré-compilation consiste à générer ce qu'on appelle du *bytecode*. Ce *bytecode*, qui en général,... le fichier va se finir par une extension .pyc, Tous ces fichiers bytecode vont être mis dans un répertoire qui s'appelle `__pycache__` Donc ce répertoire est en général là où vous exécutez votre programme. Et pour finir, l'interpréteur Python, une fois qu'il a généré le *bytecode*, va évaluer ce *bytecode* pour générer l'objet module. Je vous rappelle qu'un module s'importe toujours de manière séquentielle donc on va parcourir les lignes de la première ligne à la dernière ligne de code dans l'ordre, du début jusqu'à la fin, et que lorsque l'on rencontre une fonction, on va créer les objets fonction ; par contre, le bloc de code de la fonction ne sera évalué qu'à l'appel de la fonction.

Le processus d'**importation** étant une opération coûteuse, l'interpréteur, lorsque vous faites de multiples *import* vers le même module, ne va importer ce module qu'une seule fois, et il va ensuite créer des **références partagées** vers cet objet module. C'est pourquoi il est très important de comprendre qu'**un objet module est mutable**, et que la manière d'importer un module peut avoir un impact sur l'espace de nommage de ce module ou l'espace de nommage de votre programme. C'est ce que nous couvrirons dans une prochaine vidéo.

À bientôt !

# W5-S7 Importation des modules et espaces de nommage


Nous avons vu dans une précédente vidéo que lorsque vous importiez un module, le module n'était importé qu'une seule fois, donc de multiples *import* vont simplement créer des références partagées vers cet objet module. Mais l'**objet module** n'existe qu'en un seul exemplaire. L'objet module étant mutable, il est possible de le modifier. Il est par conséquent très important de comprendre l'**interaction des différents mécanismes d'importation avec l'espace de nommage des modules*. C'est ce que nous allons couvrir dans cette vidéo.

Commençons par créer un fichier `spam.py` qui va uniquement contenir `x = 1`. Et je vais créer un deuxième fichier, `egg.py`, qui contient uniquement `import spam` et `x =2`. Je vous laisse quelques instants pour créer ces fichiers et nous nous retrouvons dans quelques secondes. Une fois que ces fichiers sont créés, vous pouvez exécuter le fichier `egg.py` en ligne de commande depuis votre commande Windows `cmd` ou depuis un `bash` sous Linux, avec `python egg.py`. Si vous voulez voir les espaces de nommage de ces modules, vous pouvez utiliser **l'instruction vars** qui est équivalente à l'**instruction globals** dans ce contexte ; et si vous voulez voir l'espace de nommage d'un module importé, vous pouvez utiliser `vars` de ce nom de module. Vous pouvez également simplement voir les attributs d'un module en utilisant `dir` ; c'est ce que nous utilisons depuis le début de ce mooc pour voir les attributs des différents objets que nous manipulons.

Maintenant, regardons l'impact de l'importation sur les espaces de nommage. Lorsque j'exécute `egg.py`, lorsque je fais `python egg.py`, je vais commencer par importer mon module *spam* ; je vais donc aller dans le code de *spam*, créer l'entier 1, créer la variable *x* dans l'espace de nommage de *spam* et *x* va référencer cet entier 1. Maintenant, l'objet module *spam* a été créé ; je crée donc une référence de la variable *spam* dans `egg.py` vers cet objet module. Pour finir, dans le module *egg*, je crée un entier 2 et une variable *x* qui référence cet entier 2. On voit que c'est un mécanisme extrêmement simple avec deux modules tout bêtes. Maintenant, que se passe-t-il si on fait `print(x)` ? *x* est une variable définie dans le module *egg*, je la cherche avec la **règle LEGB** ; *x* est définie globalement dans l'espace de nommage de *egg* ; je regarde *x* dans l'espace de nommage de egg et je vois qu'elle référence l'entier 2. Que fait `print(spam.x)` ? Il va accéder à *x* dans l'espace de nommage de *spam*. Que vaut *x* dans l'espace de nommage de *spam* ? Il vaut 1. Maintenant, regardons un deuxième cas. Je fais `spam.x = 3`. Je vous rappelle que les modules sont des objets mutables, je peux donc modifier leurs attributs. Lorsque je fais un `spam.x = 3`, je vais créer un nouvel entier 3 et je vais dire: la variable *x* dans l'espace de nommage de *spam* maintenant référence cet entier 3. Donc, lorsque je vais faire `print(x)`, `print(x)` va afficher le *x* de l'espace de nommage de *egg* ; je vois donc qu'il vaut 2. `print(spam.x)` va m'afficher le *x* de l'espace de nommage de *spam* ; je vais donc voir 3. On remarque bien que dès que j'accède à un attribut dans un autre module, j'ai la notation explicite nom du module point nom de l'attribut. Maintenant, si je fais `spam.y = 4`, comme mon objet *spam* est mutable, je vais créer un entier 4 et une nouvelle variable *y* dans l'espace de nommage de *spam*. Et maintenant, *y* va référencer cet entier 4. Donc, si je fais `print(spam.x)`, je vais voir le *x* qui est dans l'espace de nommage de spam, 3 ; et si je fais `print(spam.y)`, je vais voir le y qui est dans l'espace de nommage de *spam* 4. Nous allons voir maintenant une autre manière d'importer. Mais avant de présenter cette manière, il faut bien comprendre l'importance de ce import *spam* ; lorsque vous faites `import spam`, vous avez une parfaite isolation des espaces de nommage ; le seul moyen d'accéder à un attribut dans l'espace de nommage de *spam*, c'est d'utiliser la notation explicite *spam* point cet attribut. Maintenant, regardons la différence avec l'importation qui consiste à écrire `from spam import x`.


Maintenant, je vais toujours créer un entier 1 dans mon espace des objets, et une variable *x* dans *spam* qui référence 1. Par contre, l'exécution de `from spam import x` va créer mon objet module et une variable *x* dans l'espace de nommage de *egg* qui va référencer le même entier que le *x* qui est dans l'espace de nommage de *spam*. Donc on voit la différence fondamentale avec tout à l'heure, c'est que maintenant, j'ai une **variable locale** dans *egg*, *x*, qui référence l'objet référencé par la variable *x* qui est dans le module *spam*. Et je n'ai plus de variable *spam* qui me permet d'accéder à mon module. Lorsque je fais `print(x)`, je vais donc accéder à mon *x* local ; ce *x* local référence l'entier 1. Si je fais `x = 3`, je crée un nouvel objet 3, et ma variable *x* locale va maintenant référencer ce nouvel objet 3. Cette notation a donc permis d'importer, dans mon espace de nommage, un attribut du module. Lorsque je fais `print(x)`, je vais donc bien voir 3. Donc ici, j'aimerais faire un petit résumé.

La manière de vous présenter les espaces de nommage séparés des modules est une vue abstraite. En fait, il faut bien comprendre que **l'espace de nommage, c'est un dictionnaire**, c'est donc un objet, qui est un **attribut du module**. Donc chaque module a un attribut qui est son espace de nommage. Je l'ai représenté de manière séparée pour pouvoir isoler plus facilement le **mécanisme de référencement**, mais gardez bien en tête que les espaces de nommage sont des attributs des modules. Maintenant, regardons la différence entre faire un `import spam` et faire un `from spam import x`. Résumons ces différences de comportement.

Lorsque vous faites `import spam`, vous avez une isolation parfaite des espaces de nommage. Vous pouvez accéder à tous les attributs de *spam* mais avec la notation explicite `spam.attribut` donc vous n'avez absolument aucun risque d'erreur. Lorsque vous faites un `from spam import x`, vous allez importer dans votre espace de nommage un nom *x* qui va référencer un objet qui est défini dans le module *spam*. Vous avez donc un risque de collision, puisque *x* va importer une variable dans votre espace de nommage ; si vous avez déjà la variable *x* définie dans votre espace de nommage, vous allez donc avoir une **collision de variables**. Et vous n'avez pas accès aux autres attributs de *spam* puisque cet import ne permet que d'accéder à l'objet référencé par *x* dans le module *spam*.

Nous avons donc vu que nous avons deux mécanismes d'importation des modules, `import module`, qui va importer le module avec une parfaite isolation des espaces de nommage, donc c'est totalement sûr. Et `from module import attribut` qui va importer uniquement l'attribut dans notre espace de nommage local avec un risque de collision. Le principal intérêt d'utiliser la notation `from module import attribut` est juste d'avoir une notation un petit peu plus courte pour éviter d'avoir en permanence à manipuler *spam* point par exemple *x*. En pratique, c'est quelque chose d'utile mais on ne l'utilise que lorsqu'on utilise systématiquement une fonction définie dans un autre module. D'une manière générale, il est préférable d'utiliser simplement la notation *import le module*. Je tiens également à vous faire remarquer que lorsque vous faites *from module import attribut*, vous n'avez pas de référence vers l'objet module. Donc vous pourriez croire que cet import va vous coûter moins de mémoire. En fait, ça ne change absolument rien, puisque l'objet module va quand même être créé, et va quand même être maintenu en mémoire tant que votre programme est en cours d'exécution. Donc ces deux méthodes d'importation n'ont aucun impact ou n'ont aucune différence en terme d'occupation de mémoire.

À bientôt !
