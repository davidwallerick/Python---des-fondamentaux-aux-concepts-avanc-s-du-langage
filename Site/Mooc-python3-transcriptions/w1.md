
# MOOC INRIA / UCA : Python 3 : des fondamentaux aux concepts avancés du langage
## Arnaud Legout et Thierry Parmentelat 

## Transcriptions des videos de la semaine 1



# W1-S1 : Organisation du MOOC



Bonjour à tous,

je suis Thierry Parmentelat et avec Arnaud Legout je vous souhaite la bienvenue sur ce cours consacré à Python 3. Donc cette première
semaine nous verrons des généralités sur le langage Python nous verrons également les outils ou comment utiliser les outils qu'on va
utiliser issus de l'écosystème Python. Et puis on verra très très mollement un début de cours en fin de semaine.

Aujourd'hui je vais vous parler du contenu du cours et de l'organisation du matériel pédagogique et donc de savoir un petit peu comment utiliser le MOOC. En terme de contenus, je précise que c'est un mooc qui est une 2ème édition d'un cours que l'on a déjà donné sur Python 2 à l'époque entre 2014 et 2016. Entre-temps l'éco-système python a largement basculé du côté de python 3 c'est pourquoi on a décidé de le revoir et notre référence ici sera python 3.6 C'est-à-dire c'est la version que l'on a utilisée pour filmer les vidéos

Nous avons organisé le cours en 2 grandes parties vous allez avoir d'abord **un tronc commun** qui durera 6 semaines dans lesquelles on couvrira les fondamentaux -  je vais en dire un mot -  et puis de manière optionnelle à partir de la semaine 7 nous avons un certain nombre d'**approfondissements, des options**. Je vais donner également un peu plus de détail. Alors en terme de tronc commun nous avons comme objectif de voir les fondamentaux du langage c'est-à-dire que nous allons parler des types de base, les fonctions les structures de contrôle les modules, les espaces de nommage la programmation objet : tout ça fait partie du tronc commun. Et pendant tout le cours on insistera sur les traits marquants de Python qui sont: le fait que c'est un langage très lisible le fait que tout est objet... On insistera bien sur la notion de liaison lexicale mais aussi de typage dynamique pour que vous ayez une bonne compréhension du code et puis on évoquera aussi des traits particulièrement caractéristiques que sont les itérations, les espaces de nommage ce genre de choses...

Alors maintenant en ce qui concerne les **modules optionnels** on va vous proposer 3 directions pour approfondir le cours. Une première semaine dans laquelle on verra les outils dits de **data science**, une deuxième semaine où on parlera de **programmation asynchrone** : c'est un sujet très innovant et très intéressant je vous invite à le regarder si vous êtes intéressé ; Et en dernière semaine on reviendra sur les **sujets avancés** c'est à dire en l'occurrence des sujets du style métaclasses, décorateurs, des techniques de programmation qui sont particulièrement avancées qu'on a jugé bon de ne pas mettre dans le tronc commun. J'indique quand même que pour les deux premières semaines qui sont là on pourrait sans problème faire un MOOC sur chacun de ces sujets donc... il s'agira vraiment d'une toute petite introduction,  on cherche à gratter la surface du sujet on cherche surtout à ce que vous sachiez que ça existe pour vous donner les moyens d'approfondir tous ces sujets de votre côté si nécessaire.

Que vous suiviez ou pas les modules optionnels à l'issue du tronc commun vous aurez le bagage qui vous permettra d'écrire du code propre, évidemment, mais on aimerait bien également vous donner les moyens de  **lire du code**.
On insiste sur le fait que c'est comme un petit peu une langue étrangère. Si vous ne lisez pas de code vous n'apprendrez pas les différents paradigmes et idiomes, c'est pour cette raison qu'on vous apprend parfois des choses qui sont au-delà de ce dont vous avez besoin mais ça vous permet de lire du code étranger ; et puis on aimerait bien également que vous ayez un bagage suffisant pour bien choisir et bien utiliser toutes les librairies tierces dont vous pourriez avoir besoin parce c'est quand même un des avantages de python, c'est de pouvoir utiliser un code qui fait à peu près n'importe quoi, régler n'importe quel problème je veux dire :).

En terme d'organisation du cours on va proposer chaque semaine évidemment un certain nombre de vidéos en gros, c'est de l'ordre de 6 à 8, il va y avoir un certain nombre de compléments. Alors, la raison c'est qu'en 5 ou 6 minutes de vidéos c'est extrêmement difficile d'aller au fond du sujet, on va vous proposer d'approfondir. Il y aura pour presque toutes les séquences des 6 semaines du tronc commun un quiz par séquence, c'est ça qui entrera en ligne de compte pour l'attestation. Et enfin vous aurez des exercices auto-évalués et je vous montrerai dans une vidéo comment ça fonctionne : le principe c'est qu'on vous propose un sujet vous établissez votre solution et vous avez un retour immédiat en ligne pour savoir si votre solution correspond à ce qui était demandé.

Nous avons également classé tous les matériaux en gros, à titre indicatif en **3 niveaux de difficulté** qui sont basique, intermédiaire, avancé donc c'est vraiment à prendre à titre indicatif le but du jeu c'est vous permettre de choisir en bonne connaissance de cause votre propre cursus en fonction de vos intérêts et aussi de vos attentes en terme de complexité.

Je ne décrirai pas dans cette vidéo les modalités de délivrance des attestations, je vous invite à vous référer à un complément ce qui nous permettra chaque année de le mettre à jour. Par contre j'insiste sur le fait que vous n'êtes pas seul dans ce cours, il y a un très grand nombre d'étudiants avec vous donc je vous invite à utiliser le forum de discussion : c'est un endroit où on trouve beaucoup d'intérêts vous allez forcément trouver quelqu'un qui a eu soit le même problème que vous, soit la même préoccupation soit qui vous aidera à installer sur Windows un outil particulier... réponse que nous n'aurions pas forcément. D'ailleurs donc je vous invite surtout à utiliser ce forum sans aucune forme de limitation c'est vraiment un endroit très ouvert.

Enfin en termes de langues je dois vous dire que, évidemment tout le cours est en français les exercices sont en français tous les supports que nous avons écrits sont en français, mais nous allons nous référer de très nombreuses fois à des documents en anglais pour la raison que le langage est écrit en anglais, la documentation officielle est écrite en anglais, la quasi intégralité du code existant est écrite en anglais donc c'est pratiquement inévitable et je dois nous excuser également parce que à l'occasion nous avons décidé de garder le terme original anglais dans une phrase quand on parlera de séquence 'unpacking' par exemple pour la raison qu'en fait c'est quasiment impossible à traduire ! Donc si vous étiez amené à faire une recherche sur internet sur une traduction que nous vous aurions faite vous risqueriez d'avoir des difficultés pour trouver ... C'est beaucoup plus raisonnable que vous ayez dès le départ le terme anglais, en fait.


A bientôt !




# W1-S2 : Pourquoi Python ?



Après la vidéo sur l'organisation du cours, et avant que l'on rentre à proprement parler dans la technique, je vais vous expliquer pourquoi Python est un langage qui est très agréable à utiliser et qui peut servir à tout un tas d'applications. Python est un langage qui a énormément de bonnes propriétés, parmi lesquelles la principale, il me semble, c'est le fait que c'est un langage qui est très lisible. Je vais essayer de vous en convaincre. On va regarder la comparaison avec un certain nombre d'autres langages généralistes, et je vais commencer par C++, à titre strictement indicatif, j'essaie juste de faire un point.

Si je compare la façon de faire une boucle sur une liste en **C++**, ça pourrait ressembler à ça. En Python, vous allez voir que le code est déjà beaucoup plus court, il est beaucoup moins touffu. Vous remarquez qu'il n'y a pratiquement aucun sucre syntaxique. Il n'y a pas de begin, de end, d'accolades, de choses comme ça. En fait, le langage a fait le parti pris d'avoir une syntaxe qui est orientée sur la présentation. Donc là, les deux phrases print et manage font partie du même bloc, L'œil humain le capte tout de suite, on n'a pas besoin de rajouter des accolades ou des choses de ce genre. Ça, c'est la première chose qui est importante à noter, Python a une syntaxe qui est articulée sur la présentation.

Je fais une deuxième comparaison, cette fois-ci, c'est avec **Java**. Alors, j'avoue que j'ai pris un exemple qui est totalement pathologique, un programme simple qui fait "Hello, world!" que vous trouvez dans tous les livres de programmation. En Java, ça ressemble à ce que vous voyez ici, c'est assez long, comme vous pouvez le remarquer, il y a beaucoup de bavardage, beaucoup de boilerplate. En Python, on se retrouve avec un programme qui fait une seule ligne. Évidemment, à nouveau, c'est un exemple qui est pathologique, mais il est très important parce qu'il illustre le fait que certains langages comme Java ont une approche qui est dogmatique, en Java, on a décidé qu'il fallait absolument que tout soit dans une classe, très bien, du coup, dans un certain nombre de situations, on se retrouve à devoir faire des choses qui sont de cet ordre. Python, à l'inverse de ça, est un langage qui est totalement pragmatique, on aura l'occasion de revenir là-dessus.

Je fais une troisième comparaison avec **JavaScript**. Cette fois-ci, j'ai pris le code qui calcule la liste des carrés d'un certain ensemble de choses. Donc vous voyez, de nouveau, en Python, un code qui est plus petit, plus ramassé, qui est simplement plus lisible. J'en resterai là sur la comparaison avec les autres langages.

Bon, j'admets volontiers que le choix des exemples est tout à fait arbitraire mais je voulais faire principalement deux points qui me semblent très importants. Dans un premier temps, la facilité d'accès a été considérée comme un but. **Python, c'est un langage qui est très lisible**, il est apparu au concepteur très important de faire un langage avec lequel on pouvait facilement échanger soit pour lire le code de quelqu'un d'autre, soit pour travailler avec quelqu'un d'autre. Donc ce n'est pas arrivé par hasard si le langage est aussi lisible, c'est vraiment un choix qui a été délibéré dès le départ. Et le deuxième point, c'est que les choix de conception sont vraiment guidés totalement par le **pragmatisme**, par opposition à ce qu'on a pu voir tout à l'heure avec Java, il n'y a, à aucun moment, dans la conception de Python, des choix qui auraient été faits en disant: il faut que telle ou telle propriété soit vraie. Non, ce n'est pas comme ça que ça fonctionne on se dit: on rencontre un problème, quelle est la meilleure façon de régler ce problème ? Donnons-nous les moyens de trouver la solution la plus élégante pour que l'utilisateur ait le langage le plus agréable et le plus à même de résoudre ses problèmes.

Sans transition, voici un **rapide historique des versions du langage**. Ça vous étonnera peut-être mais Python est un langage qui est assez ancien, qui a déjà maintenant 25 ans. Inutile de dire que, il y a 25 ans, le langage ne ressemblait pas exactement à ce qu'on peut utiliser aujourd'hui mais, voilà, c'est un langage qui a pas mal d'heures de vol derrière lui. Il y a eu une grosse rupture de compatibilité entre la version 2 et la version 3, évidemment. Tout le monde est d'accord pour dire que ça a été assez douloureux mais c'était quelque chose qui était nécessaire compte tenu de, principalement, la façon dont étaient gérées les chaînes de caractères, les encodages, on aura beaucoup l'occasion de parler de ça pendant le cours. Depuis la version 3, évidemment, les choses sont redevenues totalement compatibles. Et donc, vous avez un langage qui a une grosse histoire, qui n'a eu qu'une seule rupture de compatibilité en 25 ans, ce qui, si vous le comparez à d'autres langages, est tout à fait raisonnable.

Et donc, ça me donne l'occasion de parler d'une autre bonne propriété de Python qui est sa **stabilité**. Stabilité du langage parce que la version 2.7, qui donc est la dernière version 2 qui a été réalisée, est maintenue, alors qu'elle était censée être devenue obsolète en 2010, puisque c'est quand on a sorti la version 3, mais elle a quand même été maintenue jusqu'en 2020. Donc c'est un langage, comme tous les langages évidemment mainstream, qui tient à cœur de rester compatible pendant une très longue durée. C'est ce qui a été fait. Je prends cette occasion pour vous parler de la librairie standard. La **librairie standard**, c'est l'ensemble des utilitaires qui sont packagés avec Python, ça fait partie du langage au sens où ça fait partie de l'installation du langage, et surtout, c'est maintenu au même titre que le langage. Donc, si vous utilisez un morceau de la librairie standard, vous êtes tout à fait certains que, sur la longue durée, si c'est un sujet qui vous intéresse, votre librairie, elle sera maintenue et vous pourrez l'utiliser de manière pérenne.

Je signale aussi rapidement que Python est un **langage portable**, ce qui signifie qu'il va fonctionner à l'identique sur Windows, Mac, Linux. On le trouve même sur des devices comme Raspberry Pi. Donc c'est un atout assez intéressant. Il y a naturellement une très grosse base de code qui est disponible en Python, outre les grands domaines que j'ai déjà signalés, vous pouvez écrire un site web, c'est extrêmement pratique. Mais, au delà de ça, vous pouvez trouver une librairie pour faire n'importe quoi, si vous avez besoin de causer à votre porte de garage, il y a certainement quelque chose qui a été écrit quelque part pour le faire.

Une autre critique que j'entends assez fréquemment au sujet de Python, c'est le fait que **ça n'est pas performant**. En fait, la plupart du temps, les problèmes qui ont besoin de grosses quantités de cycles ont été réglés en wrappant du code compilé, typiquement écrit en C/C++, avec une interface Python, c'est le cas par exemple de **NumPy**. Ce qui fait qu'à la fin du compte, avec Python, vous retrouvez un langage où vous avez des types de base très puissants, donc les dictionnaires, dont on va parler, les ensembles, y compris les tableaux numpy. Vous avez la gestion automatique de la mémoire, ce qui vous permet de ne pas avoir à libérer, vous avez un Garbage Collector qui va faire le travail pour vous. Vous avez un langage interprété et avec l'addition des notebooks Jupyter dont on va parler, vous vous retrouvez avec un système de développement qui vous permet d'atteindre une vitesse de développement extrêmement rapide.

Je finirai en vous disant un mot de **la licence et de la gouvernance**. Les droits sont détenus par la **PSF, la Python Software Foundation**, qui est une organisation à but non lucratif. L'avantage de ça, c'est que la licence vous permet de faire de Python à peu près ce que vous voulez, y compris à des fins commerciales. En terme d'évolutions, parce qu'il y a encore des évolutions aujourd'hui, vous verrez par exemple lorsqu'on parlera de programmation asynchrone, qu'il y a vraiment des choses encore très innovantes qui sont ajoutées, c'est un langage qui est très vivant. La façon dont ça se passe, c'est qu'il y a un débat de nature démocratique qui se passe autour des différentes propositions qui sont faites, et la décision, en dernier recours, revient au créateur du langage, qui s'appelle **Guido van Rossum**, qui s'est intitulé lui-même le dictateur à vie bénévole du langage. C'est la façon dont les évolutions sont faites et c'est certainement pour cette raison que la cohérence du langage a pu être préservée pendant une durée aussi longue.

Donc j'espère vous avoir convaincus que vous avez fait le bon choix en vous inscrivant à ce MOOC. Dans la prochaine vidéo, je vous montrerai comment on utilise les outils Python et les notebooks, et c'est pour cette raison que je vous conseille d'installer les outils Python. Ils ne sont pas totalement indispensables pour suivre le MOOC, mais si vous voulez pouvoir manipuler sur votre ordinateur, c'est bien que vous installiez Python et IPython. Il y aura des compléments à ce sujet.


À bientôt !


# W1-S3 : Interpréteur et IDLE 


Dans cette vidéo, nous allons voir comment utiliser les outils standards Python. On va utiliser deux familles d'outils dans les vidéos, il va y avoir un environnement de développement et puis il va y avoir l'interpréteur Python de base. Je vais commencer par vous montrer l'environnement de développement.

Nous avons choisi d'utiliser **IDLE** parce qu'il fait partie de la librairie standard. Vous pouvez bien entendu utiliser de votre côté PyCharm, Spyder, Emacs ou ce que vous avez l'habitude d'utiliser mais, comme on utilise IDLE dans les vidéos, c'est quand même important que vous ayez quelques très rapides notions. De toute façon, on utilise très, très, très peu de choses. Je vais lancer IDLE sur ma machine. Vous pouvez le trouver sur Windows dans le menu Démarrer, enfin, il s'est installé avec Python quelque part.

La première chose que je voulais vous montrer, c'est de bien vérifier le numéro de Python. Je vous répète que nos vidéos ont été faites avec 3.6, on utilise très souvent les f-strings donc si vous utilisez 3.5, il y aura un certain nombre d'exemples qui ne vont pas marcher exactement à l'identique. Voilà. Ce sur quoi je tombe lorsque j'ai appelé IDLE, c'est un interpréteur interactif dans lequel je peux taper simplement des phrases comme sur une calculette. Je peux faire des choses simples comme affecter une variable à une valeur, je peux imprimer cette variable, toutes ces choses, bien sûr, on y reviendra dans les semaines qui viennent.

Je vais vous montrer comment je pourrais implémenter une petite fonction polynômiale. Je vous ai dit que la syntaxe était orientée par la présentation, je mets une indentation, enfin, plus exactement, l'outil me l'a mise déjà tout seul. Et je vais faire, par exemple, 2x carré + 4 fois x + 10 J'ai fait une petite erreur, ça me donne l'occasion de vous montrer comment je peux rectifier, je monte dans l'historique, j'appuie sur Entrée, ça me recopie le bloc de code que je viens de faire et je corrige mon erreur qui est tout simplement d'avoir oublié un multiplié. Donc j'ai défini une fonction polynôme. Je peux l'appeler. Je vous ai déjà montré comment on modifiait le code donc ça, ça ne sera pas nécessaire de le faire. Je vais appeler une fonction qui n'existe pas, je me trompe, j'ai oublié un e, ce qu'il se passe avec Python, c'est qu'il va lever ce qu'on appelle une exception. Il vous indique assez clairement que j'ai utilisé un nom qui n'était pas le bon, c'est pratiquement toujours de cette façon que ça se présente lorsque vous faites une erreur, vous pouvez avoir des erreurs de syntaxe, vous pouvez avoir des erreurs qui sont des exceptions. Avec l'expérience, vous allez apprendre assez vite à comprendre comment vous dépatouiller des erreurs que vous faites.

Je vais vous montrer maintenant comment est-ce qu'on peut avoir un petit peu d'aide, avec des fonctionnalités qui sont natives en Python. Pour faire ça, j'en profite pour vous montrer également comment on peut **importer du code**, donc là, en l'occurrence, j'importe le module mathématique. À nouveau, on expliquera tout ça en long, en large et en travers, dans les semaines qui viennent mais il me faut bien un petit peu de matière. Vous pouvez sur un module utiliser une fonction en Python qui s'appelle dir pour obtenir la liste, le contenu du module en réalité. Par exemple, dans le module math, j'ai un certain nombre de fonctions comme les tangentes, les cosinus, les exponentielles, ce genre de choses. Je peux, par exemple, obtenir de l'aide aussi sur un symbole en faisant help de, en l'occurrence, je vais faire **math.ceil** Tout ça repose sur le système d'aide en ligne. En Python, on va vous montrer comment on peut rajouter, à l'intérieur du code, la documentation qui est associée aux différentes fonctions, en l'occurrence, voilà la documentation de ceiling. Donc tout ça, c'est très bien, on utilisera cet interpréteur assez fréquemment dans le cours mais bien entendu, on ne peut pas se permettre de retaper à chaque fois tout le code et donc, on va avoir envie d'utiliser des fichiers. Je vais vous montrer comment ça se présente avec IDLE. Je crée tout simplement un nouveau fichier. Je vais commencer par mettre **un commentaire**, en Python, les commentaires commencent par des dièses, tout ce qui est après un dièse sur une ligne est considéré comme un commentaire. Je vais définir l'incontournable fonction factorielle. Alors, je vais aussi vous montrer un truc qui s'appelle docstring. C'est là exactement que va se situer la documentation en ligne que je viens de vous montrer avec help. Si je mets, je ne vais pas y passer deux heures, le factoriel, voilà, et maintenant, je peux rentrer mon code Python et je dis que si n est plus petit que 1 alors je retourne 1, et sinon, je retourne, n fois factoriel de n moins 1 Bon voilà, j'ai une petite fonction Python toute simple. Je vais, bien entendu, la sauver avec pomme + S ou save, enfin, comme d'habitude. On me demande, naturellement, un nom de fichier. Je sauve. Et maintenant, pour communiquer avec l'interpréteur, l'autre morceau d'IDLE si vous préférez, je vais utiliser une fonction qui s'appelle Run module que je peux invoquer aussi avec F5, et on fera pratiquement toujours F5. En l'occurrence, je vais faire Run module comme ceci. Ce qu'il va se passer maintenant, c'est que le contenu du module a été transmis à l'interpréteur qui, pour me faciliter la vie, s'est en fait remis à zéro. Ça veut dire que les symboles que j'avais définis tout à l'heure, vous vous souvenez que j'avais un symbole qui s'appelait polynome, j'avais un symbole qui s'appelait a, ils ont été remis à zéro, je suis reparti d'un interpréteur vide. Donc si maintenant, j'essaie d'évaluer polynome de 10, on me dit que la fonction n'existe pas. Par contre, je peux évaluer factoriel qui se trouve dans le module que je viens de passer à l'interpréteur. C'est cette boucle qui va nous permettre, en gros, de travailler en mode développement. C'est que vous êtes dans un fichier et vous faites des modifications, vous les passez à l'interpréteur qui les évalue, vous repassez dans le fichier pour faire des modifications, vous les évaluez, voilà ! C'est le principe qu'il y a derrière IDLE.

Je vais maintenant quitter IDLE. Je vais à présent vous montrer **comment on utilise l'interpréteur Python**. Donc, l'interpréteur Python, c'est le petit moteur qui fait tourner vos programmes Python, c'est ce dont vous avez besoin pour faire tourner les programmes chez un client ou chez un utilisateur, il n'y aura besoin de rien d'autre mais il y aura besoin d'un interpréteur Python. La façon dont ça fonctionne, je vais vous montrer. Je lance un terminal. Sous Windows, vous utilisez cmd pour lancer un terminal. Je me place dans l'endroit où on a sauvé factoriel tout à l'heure. Et je vais lancer le programme factoriel sauf que le programme factoriel aujourd'hui, il n'a rien dedans, tout à l'heure, on a simplement écrit une fonction. Donc je vais l'éditer pour lui rajouter quelque chose qui produise effectivement une sortie, pour qu'on y voie quelque chose. Voilà. Et donc, l'interpréteur Python, ça va se lancer exactement comme ça. D'abord, je vous montre le numéro de version, de nouveau pour vous montrer ça, 3.6 mais pour le lancer sur un programme tout fait, vous donnez simplement le nom du programme, vous voyez que c'est extrêmement simple.

Alors, maintenant, nous allons utiliser, nous, dans les vidéos, un utilitaire qui s'appelle **IPython** qui offre une fonctionnalité à peu près voisine simplement un petit peu plus agréable. Ça se présente de cette façon-là. Je lance IPython. Vous avez pour commencer une aide en ligne que vous pouvez joindre avec le point d'interrogation, je vous encourage à jeter un coup d'œil. Ce qu'on va faire avec IPython, dans l'immédiat, ça va être de définir une autre fonction, alors, on va changer, on va prendre fibonacci. Alors, fibonacci, c'est une fonction qui renvoie 1 si l'entrée est inférieure ou égale à 1, et sinon, c'est fibonacci de n moins 1 plus fibonacci de n moins 2. Alors, évidemment, une façon extrêmement inefficace d'implémenter fibonacci, ça n'a pas d'importance, ce n'est pas du tout ce que je veux vous montrer. Dans IPython, vous avez la complétion, si je fais tabulation alors, je n'ai qu'un seul symbole, je tombe là-dessus, vous avez également l'aide en ligne. Je fais par exemple fibonacci, non, pas fibonacci, on va prendre plutôt le module math comme tout à l'heure. Avec la complétion, je peux avoir une liste des fonctions du module, je vais choisir ceiling comme tout à l'heure. Je peux avoir l'aide en ligne en tapant point d'interrogation à la fin. Je peux bien entendu appeler ça. Et pour modifier le code dans les historiques, vous utilisez les flèches pour monter et vous éditez, c'est relativement simple, vous éditez le texte, simplement, vous devez aller à la fin de la ligne pour le valider. Vous voyez, c'est une fonctionnalité extrêmement simple d'édition et de complétion qui est disponible sous IPython, qui est à nouveau l'outil qu'on utilisera la plupart du temps dans les vidéos. Voici qui conclut la présentation des outils Python.

Et je vous retrouve dans une vidéo suivante pour vous expliquer comment utiliser les notebooks. À bientôt !


# W1-S4 : Les Notebooks 


Dans cette vidéo, je vais vous montrer comment utiliser les notebooks. Par contraste avec ce qu'on a fait dans la vidéo précédente, les notebooks que j'utilise ici sont hébergés dans la plateforme, donc vous n'avez rien à installer pour les utiliser, alors que la dernière fois, on avait utilisé IDLE, Python, des choses que vous aviez au préalable installées sur votre machine.

**Un notebook, c'est quoi ?** C'est un mélange entre du texte et du code. Je sélectionne la première cellule de mon notebook, qui est ici. Avec majuscule entrée, je descends dans le document de cellule en cellule. Tant que je suis sur des zones de texte, ça n'a pas beaucoup d'intérêt ni d'importance ; par contre, lorsque j'arrive sur une cellule de code comme celle-ci, vous voyez le In crochets, au moment où je vais appuyer sur majuscule entrée, ce qu'il va se passer, c'est que je vais envoyer ce code à l'interpréteur qui va me renvoyer un résultat. On va écrire dans le notebook 1 entre les crochets pour dire que c'est la première cellule qui a été évaluée. Et donc, de cette façon, je peux lire le document du début à la fin en évaluant le code au fur et à mesure. Je peux aussi le modifier. Par exemple, au lieu de calculer racine de 3, je peux avoir envie de calculer racine de 25 ; je modifie la cellule, je la réévalue avec shift entrée, je repasse le code à l'interpréteur qui va me donner le résultat. Ça vous donne un document qui est complètement malléable, vous pouvez le modifier au fur et à mesure.

Avec le numéro qui est entre crochets, vous pouvez suivre également dans quel ordre vous avez évalué les cellules parce que vous n'êtes pas totalement obligés, du coup, de les évaluer dans l'ordre ; bien entendu, c'est conseillé mais au bout d'un moment, on finit par ne plus très bien savoir où on en est. Si je descends, je vais tomber sur la partie qui m'explique comment réinitialiser l'interpréteur. De la même façon qu'on l'a fait avec IDLE, on peut avoir envie de remettre l'interpréteur à zéro parce qu'on a fait vraiment trop de modifications ; dans ce cas-là, ce que vous pouvez faire c'est un **Kernel Restart** ou, encore mieux, un **Kernel Restart and clear output**, ça veut dire: je vais redémarrer mon noyau et je vais remettre à zéro tous les affichages, ce qui correspond à peu près à ce qu'on veut.

L'autre point important, c'est que **vous travaillez sur une copie**, c'est-à-dire qu'au moment où vous rentrez la première fois dans ce notebook, ça va vous copier la version du cours, et toutes les modifications que vous faites, elles sont à vous, bien entendu. Vous pouvez les sauver. Je vous conseille de les sauver régulièrement. Ils sont sauvés de toutes les façons automatiquement pour vous. Vous avez la possibilité enfin de revenir à la version du cours en faisant **Fichier Reset from original**. Ce que je vais faire, c'est d'aller rechercher la version du cours, la version du prof, et vous allez écraser ce que vous aviez fait avant, donc faites attention si vous aviez du code auquel vous teniez, parce qu'il va être, bien entendu, écrasé.

L'autre point que je voulais vous montrer, c'était que vous aviez la possibilité aussi de **télécharger le contenu du notebook** au format Python en faisant tout simplement Download as Python. Ce que ça ferait, c'est d'aller récupérer un document qui va être très gros parce qu'il y a plein de commentaires, tous les textes sont insérés sous forme de commentaires, il ne restera au format Python que, bien entendu, les cellules qui sont des cellules de code. Enfin, vous avez la possibilité d'ajouter des cellules ; ça, c'est facile, lorsque vous arrivez tout en bas, le plus simple, pour **rajouter une cellule**, c'est de faire **Insérer**, tout simplement, pour rajouter du code.

Et sur cette base-là, vous avez à peu près tous les outils qui vous permettent de... Non, je voulais vous montrer autre chose, c'est que vous pouvez également partager une photocopie instantanée de votre notebook, c'est-à-dire vous prenez le contenu du notebook, vous en faites une page HTML que vous pouvez exposer aux autres étudiants dans le forum. Je vais vous montrer comment ça se passe, vous faites **Fichier Share static version**. Le système va vous créer une URL, que vous pouvez copier dans le clipboard, la mettre dans le forum et si un autre étudiant clique sur cette URL, ce qu'il va voir, c'est tout simplement votre notebook dans une version read only, il n'aura pas la possibilité de modifier mais il pourra lire le code que vous avez que vous avez écrit.

Maintenant, je voudrais montrer, pour finir, **les exercices auto-évalués** ; il y en a un certain nombre dans le cours. La façon dont ça se présente, c'est, à l'intérieur d'un notebook, on va vous donner un énoncé ; là, par exemple, je vais vous demander d'écrire une fonction qui implémente le polynôme 2x2 - 4. La façon que vous avez de l'utiliser, c'est toujours de faire shift entrée pour évaluer toutes les cellules de code, donc celle-ci en particulier, la première est très importante parce qu'elle charge le contenu de l'exercice. Avec ce genre de cellule, je vous montre le résultat qui est attendu, on vous dit par exemple qu'avec une entrée de -2, vous devriez avoir une fonction qui sort 4. Et là, quand vous entrez, vous avez une zone dans laquelle vous êtes invités à rentrer votre code, je vais même faire une fonction qui est exprès fausse, je vais oublier de mettre le return ; j'évalue ma cellule, ce qui a pour effet de définir une fonction, et maintenant, avec la cellule qui est correction, je vais obtenir un retour qui me dit pour toutes les entrées qui sont prévues pour l'exercice, la valeur attendue et la valeur que vous avez, vous, obtenue avec votre fonction, en l'occurrence, puisque j'ai oublié le return, ça n'est pas correct ; je peux retourner dans la cellule de code, j'évalue une nouvelle version de ma fonction, et maintenant, lorsque je demande la correction, cette fois-ci, vous pouvez constater que cette fois-ci, c'est bon. Voilà le mécanisme général pour les exercices auto-évalués.


Et voilà qui conclut la vidéo sur l'utilisation des notebooks.

À bientôt !


# W1-S5 : Notions de variable, d'objet et de typage dynamique


Bonjour, je suis Arnaud Legout et nous allons passer les prochaines semaines de ce MOOC ensemble.

Dans cette vidéo, nous allons découvrir les notions d'**objet**, de **variable** et de **typage dynamique**. Pourquoi est-ce que ces notions sont tellement importantes en Python ? Parce qu'en Python, tout est un objet. Par conséquent, dans vos programmes, vous aurez à manipuler de nombreux objets. Et le moyen en Python de manipuler ces objets, c'est de leur donner un nom par l'intermédiaire de **variables**. On dit que les variables référencent les objets.

Regardons maintenant cette notion d'**objet**. Dans un programme informatique, un objet est un morceau de code qui va contenir des données. Mais il va également contenir un ensemble de mécanismes qui permettent de manipuler ces données et que l'on appelle méthodes. **Les objets ont tous un type**. Le type est le comportement par défaut qui va être défini pour ces objets. Par conséquent, le type va permettre de définir les données et les méthodes qui vont être associées à cet objet.
Prenons l'analogie d'une chaîne de montage de voitures. Lorsque vous avez une usine, votre usine va construire des voitures, et c'est cette usine qui va définir un ensemble de comportements que toutes les voitures qui vont sortir de la chaîne de montage vont avoir. Donc par exemple, la puissance du moteur, le fait que votre voiture va avoir des clignotants, des accélérateurs, vont être déterminés par votre chaîne de montage. On peut donc dire que la chaîne de montage détermine le type des voitures qui vont sortir de cette chaîne et que la voiture est l'objet qui sort de cette chaîne de montage.
Revenons maintenant à nos programmes informatiques, à nos objets informatiques. Je vais représenter l'ensemble des objets que l'on a dans la mémoire de l'ordinateur. Maintenant, créons un objet, créons notre premier objet python. Pour cela, nous allons créer un objet de type chaîne de caractères, nous reviendrons largement sur ce type d'objet dans la suite. Pour créer un objet chaîne de caractères vous mettez deux apostrophes et entre les apostrophes, vous mettez la chaîne de caractères que vous voulez créer. Lorsque vous appuyez sur le retour chariot, l'interpréteur Python va créer cet objet chaîne de caractères. Nous voyons que cet objet a des données associées c'est le mot "spam" et cet objet a également un ensemble de méthodes comme par exemple la méthode upper(). D'où viennent les méthodes de la chaîne de caractères puisque nous n'avons rien défini nous-mêmes ? En fait, toutes les méthodes de la chaîne de caractères viennent grâce à son type le type "chaîne de caractères".
Maintenant, nous pouvons appeler les **méthodes** sur ces objets. Pour appeler une méthode sur un objet, c'est très simple, il suffit d'utiliser la notation "point". Pour cela, nous allons mettre l'objet "point" la méthode que l'on veut appeler. et n'oublions pas de mettre les parenthèses ouvrante et fermante qui permettent de déclencher l'exécution de la méthode upper() sur l'objet "spam".

Maintenant que nous avons vu cette notion d'objet, regardons comment **nommer les objets**. On dit **les référencer**. Pour cela, on va affecter un objet à un **nom de variable** particulier avec une notation que l'on appelle la **notation d'affectation**. Donc supposons que nous voulions nommer l'entier 1, nous allons écrire note "égale" 1, ce qui veut dire que la variable de nom "note" va maintenant référencer l'objet 1. On pourra ainsi manipuler cet objet par l'intermédiaire de ce nom de variable. Un nom de variable en Python peut être défini par n'importe quelle lettre en minuscule, n'importe quelle lettre en majuscule, les entiers allant de 0 à 9 et également le caractère tiret bas que l'on appelle également "underscore". Un nom de variable peut commencer par une lettre, ça peut également commencer par l'underscore mais ça ne peut pas commencer par un chiffre. Un nom de variable prend en compte la casse, c'est-à-dire qu'un nom en minuscule et un nom en majuscule vont représenter deux variables différentes. Pour finir, il est très important en Python de donner des noms de variable qui sont explicites. Par exemple, moyenne_age_francais est un bon nom de variable, meilleur que moy_age_f et bien meilleur que simplement la variable x. Il est très important de donner de donner des bons noms de variable puisque ça participe à la documentation automatique de votre code. Et nous verrons dans les prochaines vidéos et les semaines suivantes que Python offre de nombreux mécanismes pour faciliter ce nommage explicite des objets que l'on manipule.

Maintenant que nous avons vu les notions d'objet et de variable, parlons de la dernière notion importante de cette vidéo, qui est le **typage dynamique**. Je vous représente ici l'espace des objets comme nous avons vu précédemment qui va contenir tous les objets que nous avons dans l'ordinateur, et également l'espace des variables qui représente les variables qui vont référencer les objets dans notre ordinateur. Nous verrons dans la suite et dans les semaines qui viennent que cet espace des variables, on appelle ça en fait un **espace de nommage**. Supposons maintenant que je fasse *a* égale 3 ce qui veut dire que ma variable *a* va référencer l'entier 3. Lorsque je fais un retour chariot, Python va exécuter 3 opérations. La première opération va consister à créer l'entier 3. Donc c'est un objet qui est créé dans l'espace des objets. Puis il va créer une variable *a* dans l'espace des variables. Et pour finir, il va créer une référence entre cette variable *a* et l'entier 3. Maintenant, supposons que je fasse *a* égale *spam*. Python va effectuer la même suite d'opérations et il va créer un objet de type chaîne de caractères qui s'appelle *spam*, puis il va créer une variable *a* mais la variable *a* existe déjà
En fait, qu'est-ce que ça veut dire le typage dynamique ? Ça veut dire qu'en Python le type n'est pas lié à la variable qui référence l'objet mais est lié à l'objet. En fait, **Python est un langage que l'on appelle un langage à typage fort**, ça veut dire que le typage est lié aux objets et que l'objet va garder le même type durant toute l'exécution du programme. Par contre, la variable, elle, peut référencer des objets qui vont être de type différent en cours d'exécution. Pour finir, si je fais *del* de *a*, ça va me permettre de supprimer la variable *a* de mon espace des variables. Si mon objet n'a plus de référence, on a un mécanisme en Python qui s'appelle un mécanisme de **garbage collector** qui va libérer la mémoire de l'ordinateur une fois que les objets ne sont plus référencés.

Dans cette vidéo, nous avons introduit les notions d'objet, de variable et de typage dynamique. Ce sont des notions clé en Python parce que comme nous l'avons vu en Python tout est un objet, et par conséquent, pour pouvoir manipuler ces objets, il faut être capable de leur donner un nom, et on leur donne ce nom par le mécanisme de référencement qui consiste à donner un nom de variable qui est égale à un objet.

À bientôt !



# W1-S6 : Les types numériques


Nous allons voir dans cette vidéo Les **4 types numériques** qui existent en Python. Nous avons les **entiers** qui représentent les nombres entiers, les **floats** qui représentent les nombres décimaux, les **complexes** qui représentent les nombres complexes, et finalement les **bools**, qui représentent les booléens qui sont, on le verra, un sous-ensemble des entiers.

Ouvrons un interpréteur Python pour commencer à jouer avec les types numériques. Pour créer un entier en Python, c'est très simple, il suffit de taper cet entier dans l'interpréteur. Donc par exemple si je fais 1 retour chariot, je crée un nouvel objet entier. Sauf que cet objet a été créé et je n'ai aucun moyen de le manipuler puisque je ne lui ai pas donné de nom. Nous avons vu dans la précédente vidéo qu'on pouvait nommer les objets grâce à un mécanisme de référencement par l'intermédiaire d'une variable. Donc je vais écrire i égale 1 et je crée un objet de type entier référencé par la variable i.

Je peux vérifier son type avec **la fonction built-in type()** qui me permet de vérifier le type des objets référencés par les variables donc je vois bien que c'est un objet de type entier. Les entiers se manipulent comme dans une calculatrice en Python, donc je peux tout à fait écrire 1 plus 3 pour additionner deux entiers, je peux également les multiplier, les diviser, les soustraire. Je peux réaffecter une variable avec le résultat d'une opération. Donc par exemple i égale i fois 5 alors je vais faire i + 5. J'ai mon entier qui vaut 1, je lui ajoute 5, maintenant il vaut 6. Je peux le vérifier avec la fonction **built-in print()** qui me permet d'afficher le contenu d'un entier.

Vous avez pu remarquer que j'utilise soit print, soit le retour chariot. En fait, ces deux opérations sont très similaires ; elles ont une toute petite différence pour les chaînes de caractères, nous reviendrons dessus dans une prochaine vidéo.

Les **entiers** en Python ont la caractéristique d'être des objets de précision illimitée. Ça, c'est quelque chose de très important en Python, regardez. Je crée un entier qui est extrêmement grand je vais l'affecter à ma variable i. J'ai donc un entier très grand et je vais pouvoir multiplier cet entier par lui-même. Et bien, Python ne va avoir aucune perte de précision et va me créer un nouvel entier. Je peux même élever cet entier par exemple à la puissance 5, on élève un entier à une puissance avec le signe double étoile, et je vois donc que je crée un nouvel entier extrêmement grand. Donc, ça, c'est pour le premier type numérique, le type int.

Le deuxième type numérique en Python, c'est le type **float** qui manipule les nombres décimaux. Donc regardons un exemple, j'écris f égale 4 point 3 Ça représente le nombre décimal 4,3. Donc la virgule se représente par un point. Les floats, en Python, ont une précision qui est limitée par contre, ils sont en général codés sur 15 chiffres significatifs et encodés sur 53 bits. Cela peut dépendre, évidemment, de la plateforme sur laquelle on fait tourner notre interpréteur Python.

Ensuite, j'ai les **nombres complexes** qui se représentent de la manière suivante: donc un nombre complexe, c'est deux nombres float mis l'un à côté de l'autre donc je vais mettre la partie réelle, 4, plus 5 J, donc ça représente un nombre complexe qui vaut 4 plus 5J, 5 étant la partie imaginaire donc on représente la partie imaginaire en Python avec un J. Ensuite je peux additionner n'importe quels types numériques et Python va se charger de faire la conversion pour nous. Évidemment, lors de la conversion, je peux avoir une perte de précision, donc regardons cela.

J'ai un entier et j'ai un float ; je peux additionner cet entier et ce float, mais Python va convertir le résultat en float. Je vais donc avoir une perte de précision et perdre un certain nombre de chiffres significatifs que j'avais avec mon nombre entier. Ensuite, si j'additionne un entier, plus un float, plus un nombre complexe, Python va convertir cela en nombre complexe et donc là encore une fois, j'ai une perte de précision au niveau de mon entier. Je peux également convertir les entiers en floats ou les floats en entiers, en utilisant la fonction built-in int() par exemple, pour convertir un float vers un entier donc l'opération, c'est **la troncation** ; et je peux convertir un entier en float de la manière suivante. Je peux également faire la même chose avec la fonction built-in complex() pour convertir par exemple un float en complexe, donc on voit que j'obtiens le nombre 4 + 0 J. Pour résumer, regardons les différentes opérations que l'on peut faire sur les types numériques: je peux faire une addition, je peux faire une soustraction, et donc je peux obtenir un nombre négatif, je peux faire une multiplication, une division, qui en Python a la caractéristique d'être une division naturelle, donc 3 divisé par 6 va me donner 0,5, je peux forcer la division entière avec un signe double barre oblique, et je peux obtenir le reste de cette division entière avec le signe pourcentage. Et puis pour finir, je peux élever un nombre à une puissance avec le signe double étoile, et prendre la valeur absolue d'un nombre avec la fonction **built-in abs()**.

Maintenant que nous avons vu les entiers, les floats et les complexes, regardons le dernier type numérique qui est le **type booléen**. Alors le booléen est un peu particulier parce qu'un booléen n'est pas un nombre le booléen est représenté soit pas True, qui représente vrai, soit par False, qui représente faux. Notez bien que j'écris True et False avec un T majuscule et avec un F majuscule. Cependant, ce type booléen est un sous-ensemble des entiers, et il est codé en fait comme un entier, False étant l'entier 0, et True étant l'entier 1. Regardons un exemple d'application de ce booléen, je vais faire une simple comparaison: est-ce que 1 est plus petit que 2 ? Je vois que c'est vrai. Est-ce que 1 est plus grand que 5 ? Je vois que c'est faux. Nous reviendrons bien évidemment sur ces expressions dans la suite.

À bientôt !
