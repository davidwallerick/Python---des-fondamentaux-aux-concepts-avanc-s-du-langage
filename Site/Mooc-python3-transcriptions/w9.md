# MOOC INRIA / UCA : Python 3 : des fondamentaux aux concepts avancés du langage## Arnaud Legout et Thierry Parmentelat ## Transcriptions des videos de la semaine 9 : Sujets avancés# W9-S1 Méthodes statiques et de classeBonjour !Nous abordons la dernière semaine de ce MOOC. Vous avez, maintenant, de profondes connaissances en Python. Mais il nous reste à aborder quelques sujets avancés. Notre but n'est pas de vous faire une couverture exhaustive de ces sujets ; il nous faudrait pour cela un nouveau MOOC, mais de vous les faire découvrir, pour que vous puissiez ainsi les développer vous-même, et ainsi, améliorer votre panorama de techniques de programmation.Lorsque nous avons introduit la notion de **classe**, nous avons présenté la notion de **méthode**. Une **méthode** est conçue pour travailler sur les attributs des instances. Cependant, nous avons vu qu'il y avait une asymétrie entre la manière d'appeler cette méthode depuis une classe, et la manière d'appeler cette méthode depuis une instance. Lorsqu'on appelle une méthode depuis une classe, il s'agit d'une fonction tout à fait classique. Mais, lorsqu'on appelle depuis une instance, il s'agit de ce qu'on appelle une méthode **bound**. ça veut dire que l'interpréteur Python va, automatiquement, passer à cette méthode, comme premier argument, l'instance qui l'appelle. C'est exactement le comportement que l'on veut dans le cas classique, puisque, en fait, en général, on veut travailler sur les attributs des instances. Cependant, on pourrait imaginer vouloir travailler sur autre chose que les attributs des instances, par exemple, des attributs de classe. Et là, on se rend compte qu'on est confronté à un problème. Comme on a une asymétrie entre la manière d'appeler une méthode depuis une instance et depuis une classe, si on ne travaille plus sur les attributs de l'instance, comme l'interpréteur va, automatiquement, passer l'instance comme premier argument, on aura un comportement non symétrique, et, par conséquent, on ne pourra pas appeler de manière indifférente cette méthode, depuis une classe ou depuis une instance.Dans cette vidéo, on va présenter deux techniques pour résoudre ce problème, qu'on appelle les **méthodes statiques** et les **méthodes de classe**. Nous allons essayer de résoudre le problème suivant : nous allons essayer de compter le nombre d'instances qui ont été créées par une classe. Donc ça c'est quelque chose qui semble assez facile à faire, puisqu'on peut, tout à fait, rajouter un compteur dans la classe, qui va compter le nombre de fois qu'on fait des instances. Regardons cela.Je vais créer une classe `Phrase` qui va définir un compteur, un compteur d'instance qu'on initialise à 0. Et, ensuite, dans le constructeur, dans l'initialisateur de mon instance que j'appelle `__init__`, je vais simplement incrémenter mon compteur d'instances. Donc j'ajoute 1, à chaque fois que je crée une instance. Je vous rappelle que pour accéder à un un attribut d'une classe, il faut utiliser la notation d'attribut : `Phrase.attribut`. Maintenant, exécutons ce morceau de code J'exécute, j'évalue avec F5, je retourne dans mon interpréteur, et, maintenant, je vais créer une instance. Voilà. Puis une deuxième instance. Et, maintenant, je vais regarder mon compteur d'instances. Et, donc, on voit qu'il est à 2. Pour l'instant, tout fonctionne parfaitement. Je n'ai absolument aucun problème pour accéder à mon compteur d'instances. Seulement, on se dit bien qu'en fait, plutôt que d'y accéder par, directement, l'attribut ça serait mieux d'avoir une méthode. Donc, je vais rajouter une méthode à ma classe, qui va simplement me retourner le nombre d'instances. Je vais appeler cette méthode `num` et cette méthode va faire un `return` de `Phrase.nb_i`. J'évalue ce code. Je recrée, de nouveau, deux instances. Et, maintenant, je vais appeler `Phrase.num()`. Et là, on voit que ça fonctionne, tout à fait.Pourquoi ça fonctionne? Vous avez remarqué, qu'à `num`, je n'ai pas passé de paramètre `self`. C'est parce qu'en fait, une méthode appelée sur une classe est une fonction classique. Donc Python ne va pas lui passer l'instance comme premier argument. Vérifions ça. Si je regarde, voilà, quel type d'objet, c'est une fonction classique. Mais, si maintenant, je crée une nouvelle instance de `Phrase`, et que maintenant, j'appelle ma méthode sur l'instance, que va-t-il se passer? J'ai une exception. C'est tout à fait normal. Je vous rappelle qu'une méthode appelée sur une instance, c'est une méthode *bound*, par conséquent, Python va lui passer, automatiquement, le premier argument. Et ici, on est confronté à ce fameux problème, cette asymétrie entre appel d'une méthode sur une classe - c'est une fonction classique - et appel d'une méthode sur une instance - c'est une méthode *bound* à laquelle on passe, obligatoirement, le premier argument. Or, on imagine bien, que dans ce cas-là, pour simplement compter le nombre d'instances que l'on a dans notre classe, on aimerait bien pouvoir avoir une méthode qu'on puisse appeler, indifféremment, de la classe ou depuis l'instance.En Python, c'est possible. Il suffit de déclarer cette méthode comme une **méthode statique**. Comment est-ce qu'on fait ça? Nous allons voir que c'est extrêmement simple. Il suffit de déclarer cette méthode avec un **décorateur** qui s'appelle `@staticmethod`. Cette notion de décorateur, nous reviendrons dessus, dans une prochaine vidéo, mais, pour l'instant, sachez simplement que cette notation `@staticmethod` me permet de transformer une méthode en **méthode statique**. Ça veut dire quoi, une **méthode statique**? Ça veut dire que c'est une méthode que je pourrai, maintenant, appeler, indifféremment, depuis une classe ou depuis une instance. Si j'appelle ma méthode depuis une classe, ça sera une fonction classique. Si je l'appelle depuis une instance, ce sera, de nouveau, une fonction classique, et non plus, une méthode *bound*. Exécutons ce code. Je l'évalue.Je vais, maintenant, recréer une instance et je vais appeler cette méthode `num()`, depuis ma classe. Je vois bien que j'ai une instance. J'appelle cette méthode `num()` depuis mon instance. Je vois bien que j'ai une instance. Une sous-classe d'une classe qui a une méthode statique hérite, automatiquement, de cette méthode statique. Par contre, si on surcharge cette méthode statique, dans la sous-classe, il faudra, évidemment, la redéfinir comme méthode statique. Regardons cela.Je vais définir une sous-classe de ma classe `Phrase` que je vais appeler `class PhraseSansCasse` qui hérite de `Phrase`. Et, ensuite, voilà, je définis une méthode toute simple qui ne fait rien de particulier. Donc, si j'exécute ce code-là, et que je crée une instance de ma classe `Phrase`, je peux, maintenant, faire un `Phrase.num()`. Je vais donc voir, effectivement, que j'ai une instance. Et je peux faire un `PhraseSansCasse.num()` et je peux, effectivement, appeler ma méthode statique, directement, depuis une sous-classe. Maintenant, regardons ce qui se passe, si jamais, je redéfinis cette méthode statique depuis ma `PhraseSansCasse`. Donc ici, je vais simplement redéfinir une nouvelle méthode `num()`, donc, je surcharge ma méthode `num()` qui est définie dans ma super classe. Et ici, je vais faire un retour, alors, un retour un tout petit peu plus sympa, avec une *f-string*. Voilà qui va simplement afficher `PhraseSansCasse` et ici je vais mettre un `{Phrase.nb_i}`. Voilà, tout simplement. Donc j'ai bien rajouté mon argument `Phrase.nb_i` depuis ma méthode `num()` dans `PhraseSansCasse`. Comme cette méthode a été redéfinie depuis `PhraseSansCasse`, il faut que je la redéfinisse comme méthode statique, sinon ça redeviendra une méthode normale. `@staticmethod`. Voilà.Donc maintenant,j'exécute ce code. Je vais redéfinir une instance de `p`. Je vais appeler `num()` depuis `Phrase`, je vois bien afficher 1. Je peux appeler `num()` depuis `PhraseSansCasse`, je vois bien afficher ce nouvel affichage. Donc ça fonctionne tout à fait normalement. Si j'avais créé une instance de `PhraseSansCasse` et cette méthode `num()` de `PhraseSansCasse` qui aurait été appelée, j'aurais pu l'appeler, de manière indifférente, sur une instance de `PhraseSansCasse`, et également sur une instance de `Phrase`, et, dans ce cas-là, ça aurait été la méthode de `Phrase` qui aurait été appelée. Donc, je suis l'arbre d'héritage, ce que nous connaissons, maintenant, parfaitement.Seulement, ici, on se rend compte d'une limitation de cette technique de programmation. En fait, j'ai deux classes différentes : j'ai `Phrase` et `PhraseSansCasse`, et, en fait, je retourne simplement le nombre d'instances que j'ai dans `Phrase`. Donc, le nombre de fois que la méthode `__init__` a été appelée dans `Phrase`. Comme `PhraseSansCasse` hérite de `Phrase`, le compteur dans `__init__` est incrémenté, à chaque fois que je crée une instance de `PhraseSansCasse`. Mais, je n'ai donc aucune distinction entre les instances de `Phrase` et les instances de `PhraseSansCasse`. Toutes les instances correspondent au même et unique compteur. Donc, en fait, si jamais je voulais créer de multiples compteurs, je pourrais tout à fait le faire. Ici, je pourrais rajouter un nouveau compteur, `nb_i` qui est égal à 0, et ici, rajouter une méthode `__init__(self)` qui va simplement me faire un, dans ce cas-là, je vais rajouter un `PhraseSansCasse.nb_i +=1`. Voilà. Donc là, maintenant, j'ai un compteur `PhraseSansCasse.nb_i` que j'incrémente à 1.Alors, maintenant, si je regarde ça, en fait, ce n'est toujours pas très satisfaisant. Pourquoi ce n'est pas satisfaisant? Parce que lorsque je vais appeler ma méthode `num()`, à aucun moment, je vais être capable de lui dire mais de quelque classe je l'appelle. En fait, pour ça, il faudrait que j'ai une manière de passer, à ma méthode `num()`, qui appelle la méthode `num()`. Et ça, je peux le faire, grâce à un autre type de méthode qu'on appelle les **méthodes de classe**. Donc, une **méthode de classe**, à la différence d'une **méthode statique**, va créer, en fait, une méthode *bound*. Sauf que cette fois, cette méthode ne sera pas liée à l'instance, mais sera liée à la classe qui l'appelle. Par conséquence, cette méthode de classe, que je l'appelle depuis une instance ou depuis une classe, passera, automatiquement, la classe comme premier argument de la méthode. Regardons cette implémentation.Ici, au lieu de faire `@staticmethod`, je vais faire `@classmethod`, et, à ma méthode `num()`, je vais passer un argument classe (`cls`), puisque ma méthode est maintenant définie comme une méthode *bound* à la classe. Et donc, ici, au lieu de lui passer `Phrase`, je vais directement lui passer la classe (`cls`). Si c'est une méthode appelée depuis la classe `PhraseSansCasse` ou depuis une instance de `PhraseSansCasse`, c'est le compteur de `PhraseSansCasse` qui sera appelé. Si la méthode est appelée depuis une instance de `Phrase` ou depuis directement la classe `Phrase`, ce sera le compteur de `Phrase` qui sera appelé. Et donc, je vais faire la même chose, depuis ma méthode surchargée, ici, je vais lui passer `cls`. Donc, je n'oublie pas de la définir comme `@classmethod`. Et ici, au lieu de passer `Phrase`, je vais passer `cls`. Encore une fois, de nouveau, je vais, automatiquement, utiliser le bon compteur. Donc regardons cela. J'évalue ce code.Et maintenant, je vais créer différentes instances. Donc je crée `p` une instance de `Phrase`. Voilà. Je crée, malgré tout, une deuxième instance de `Phrase` que je ne référence pas. Et je vais créer une instance de `PhraseSansCasse`. Donc maintenant, regardons les différents appels de `num()`. Je fais `p.num()` de `Phrase` ; donc, par conséquent, ma méthode de classe va prendre la classe `Phrase` comme argument et va donc appeler le compteur `Phrase.nb_i`. `nb_i` vaut 2, à ce moment-là. Si j'appelle ma méthode de classe directement depuis `Phrase` (`Phrase.num()`), je vois encore le compteur à 2 et donc, là, on peut également vérifier que `num()` est bien une méthode *bound* sur la classe et que `p.num()` est également une méthode *bound* sur la classe. Maintenant, j'appelle cette méthode depuis mon instance de `PhraseSansCasse`, je vais voir que mon compteur est bien à 1 et que j'appelle bien la méthode que je dois appeler, la méthode de `PhraseSansCasse`. Encore une fois, c'est une méthode *bound* à la classe. Je vais donc regarder le compteur de `PhraseSansCasse`. Et si maintenant, je l'appelle directement depuis ma classe `PhraseSansCasse` (`PhraseSansCasse.num()`), je vois, de nouveau, que c'est le bon compteur qui est appelé.Dans cette vidéo, nous venons de voir les notions de **méthodes statiques** et de **méthodes de classe**. Une **méthode statique** est une méthode que l'on peut appeler, indifféremment, depuis une classe ou depuis une instance, et ça a créé une méthode qui se comporte comme une fonction tout à fait classique. Et une **méthode de classe**, c'est une méthode qui s'appelle, indifféremment, depuis une classe ou depuis une instance, mais qui va être *bound* à la classe; par conséquent, l'interpréteur va, automatiquement, passer la classe comme premier argument.À bientôt !# W9-S2 Les décorateursLorsque l'on développe des fonctions, il arrive que l'on ait un même besoin sur plusieurs fonctions. Par exemple, calculer un temps d'exécution, valider des arguments, ou compter le nombre d'appels que l'on fait de ces fonctions. Dès maintenant, vous savez tout à fait implémenter ce type de fonctionnalité. Le problème que l'on aurait, c'est qu'on dupliquerait beaucoup de code puisqu'il faudrait écrire un code spécifique pour chaque fonction, alors que ce code fait essentiellement la même chose. Il existe, en Python, une technique que l'on appelle le **décorateur**.Un **décorateur** est une manière de dire, explicitement, que l'on modifie le comportement d'une fonction. Ça permet également de factoriser un code que l'on applique à différents types de fonctions. Essentiellement, un décorateur permet d'exécuter du code, avant l'appel d'une fonction, après l'appel d'une fonction, et éventuellement de garder des informations entre plusieurs appels successifs d'une fonction. Mais, nous allons voir qu'un décorateur est plus général que ça et qu'on peut imaginer bien d'autres applications. Regardons, maintenant, le fonctionnement d'un décorateur.Regardons comment est-ce que l'on note un décorateur, en Python. Nous en avons déjà parlé, lorsque nous avons parlé des fonctions statiques et de classe. Nous avons une notation `@` qui permet de dire que l'on applique le décorateur à notre fonction `f`. L'intérêt principal de cette notation, c'est de rendre explicite le fait que l'on décore cette fonction. Cependant, un décorateur ne fait rien de magique. C'est simplement un raccourci vers la syntaxe suivante : on crée toujours notre fonction, et le *@decorateur* va simplement dire à l'interpréteur Python qu'il faut faire un `f=decorateur(f)` ; c'est essentiellement ce que fait un décorateur. Nous voyons que c'est assez simple.Ça, évidemment, ça vous rappelle ce que nous avons déjà vu, dans le contexte des méthodes statiques et des méthodes de classe. Donc reprenons notre exemple. Nous avons une classe `C` qui définit une fonction `f` que l'on décore comme méthode de classe, une fonction `g` que l'on décore comme méthode statique. En fait, nous venons de le voir, ces notations décoration sont tout à fait équivalentes à faire la chose suivante : déclarons, à nouveau, notre classe `C` avec notre méthode `f` et notre méthode `g`, et en décrivant, plus loin, que `f=classmethod(f)` et `g=staticmethod(g)`. Nous voyons la supériorité de cette notation.Alors, vous allez dire mais qu'est-ce qu'il y a de supérieur puisque c'est un tout petit raccourci à cette syntaxe? En fait, c'est très important de pouvoir spécifier, lorsque l'on déclare une fonction, que le comportement de la fonction est modifié. En effet, déclarer une méthode comme statique ou de classe est une modification fondamentale du comportement de la fonction. Avec la notation de décorateurs, vous pouvez vraiment lier cette modification de comportement au moment de la déclaration de la fonction. Donc, on voit bien que - ici, j'ai mis des petits pointillés mais les déclarations `classmethod`, `staticmethod` auraient pu être faites très loin de la déclaration effective des méthodes. Avec l'annotation décorateur, on est obligé de mettre le `@` juste avant la déclaration de la fonction. Donc maintenant, c'est tout à fait explicite.Alors donc, revenons sur cette notion de décorateurs : `@decorateur` au-dessus d'une fonction consiste à faire `f=decorateur(f)`. Le point clé, c'est que `f`, maintenant, lorsque j'appelle ma fonction `f`, ça n'est plus la fonction `f` originale. Mais, en fait, la fonction que je vais appeler, c'est le résultat de `decorateur(f)`. Donc, pour expliquer cette notion de résultat de `decorateur(f)`, il faut que j'introduise une notion que l'on appelle un **callable**.Qu'est-ce-qu'un **callable** ? Un **callable**, c'est un objet que l'on peut appeler avec la notation `O()`, `O` étant le nom de l'objet, et ensuite, on rajoute des parenthèses juste après. En fait, ça correspond exactement à ce que vous connaissez comme étant une fonction. Une fonction, évidemment, est *callable* mais également une instance dont la classe implémente la méthode `__call__`.Alors maintenant, qu'est-ce que c'est un décorateur, une fois qu'on a cette notion de *callable* en tête? Un décorateur, en fait, c'est un callable qui prend comme argument une fonction et qui retourne, de nouveau, un *callable*. Donc, en fait, dans `f = decorateur(f)`, `decorateur`, c'est un *callable*, on voit bien, je peux l'appeler, avec des parenthèses, en lui passant l'objet fonction en tant qu'argument. Et le résultat de cet appel de `decorateur(f)` doit me retourner un *callable*. C'est-à-dire un objet que je peux, de nouveau, appeler. Ça n'est pas surprenant, puisque après je vais appeler ma fonction `f`, tout à fait normalement. Il faut donc après que l'objet retourné par `decorateur(f)` puisse, de nouveau, être appelé. Donc, `f = decorateur(f)`, `decorateur(f)` va me retourner un objet `O` et cet objet `O` doit être *callable* et, en fait, lorsque j'appelle `f(a, b)` et bien, en fait, ça appelera, en réalité, l'objet `O(a, b)`. Ça passera mes arguments `a` et `b` à mon nouvel objet *callable*.Donc, à quoi sert un décorateur ? Nous l'avons expliqué en introduction. Ça sert essentiellement à ajouter une couche de logique autour de l'appel d'une fonction éventuellement, garder de l'état entre deux appels d'une fonction, avec une notation qui est explicite ; donc c'est vraiment ça l'intérêt marquant. C'est que maintenant, on va modifier explicitement le comportement d'une fonction avec cette notation `@decorateur`. Évidemment, lorsqu'on définit un décorateur, il faut définir un nom de décorateur qui explique, clairement, ce qu'on est en train de faire à la fonction. Donc, pour cela, regardons un exemple.Imaginons que je veuille écrire un décorateur, qui s'appelle `NbAppel`, dont le but est de compter le nombre d'appels que je fais sur ma fonction. Donc je vais l'écrire `@NbAppel` et que va faire ce décorateur ? On l'a vu, c'est totalement équivalent à faire `def f(a, b) : f = NbAppel(f)`. Donc maintenant, regardons l'implémentation de ce décorateur. Ici, je vais vous montrer l'implémentation d'un décorateur sous forme de classe, et nous verrons, dans une prochaine vidéo, l'implémentation d'un décorateur sous forme de fonction en utilisant le concept de **clôture**. Mais, pour l'instant, regardons l'implémentation sous forme de classe.Donc, je vais définir, dans une classe `NbAppel`, une méthode `__init__` qui va simplement définir un compteur appel que j'initialise à 0, et ensuite, on voit qu'à `__init__`, je prends comme argument `f`, `f` étant la fonction que je veux décorer. Et, dans mon instance de `NbAppel`, je vais garder un lien vers la fonction originale. Ça, en général, c'est ce qu'on veut faire, puisque après, lorsqu'on décore une fonction, très souvent, on veut appeler cette fonction qui a été décorée.Ensuite, j'ai défini une méthode `__call__`. Effectivement, il faut que mon décorateur soit un *callable*. Donc, pour qu'une instance de classe soit callable, il faut définir une méthode `__call__`. Et on voit qu'à ma méthode `__call__`, je lui passe deux arguments `*t, **d`. En fait, nous avons vu, précédemment, que lorsque l'on avait cette notation `*` ça voulait dire qu'on pouvait appeler notre objet avec n'importe quel type d'argument : arguments ordonnés, arguments nommés, n'importe quel type d'arguments. Donc, en fait, c'est une tout à fait générique. Et donc, dans notre méthode `__call__`, lorsqu'on va appeler notre instance, on va incrémenter le compteur, le compteur d'appels. On va définir une chaîne de caractères qui va simplement afficher `self.f.__name__`, `__name__` va contenir le nom de la fonction originale, et, ensuite, on va afficher le nombre d'appels. On va dire essentiellement : "ma fonction `f` a été appelée tant de fois" Et, pour finir, on va retourner `self.f(*t, **d)` donc `f`, c'est la fonction originale, et on va lui passer `*t, **d` donc on va faire de l'*unpacking* de tuple et l'*unpacking* de dictionnaire. C'est-à-dire que ma fonction va lui passer n'importe quel type d'argument. Donc cet appel est tout à fait générique.Donc, pour résumer, `f = NbAppel(f)`. `f`, en fait, maintenant, n'est plus une fonction, mais c'est une instance de `NbAppel` et chaque instance de `NbAppel` va avoir son propre compteur, ce qui veut dire que mon décorateur je peux l'appliquer à n'importe quelle fonction. Chaque application décorateur va créer une nouvelle instance et `f(NbAppel)` va, en fait, appeler la méthode `__call__` sur cette instance. Et ensuite, on voit que ma méthode `__call__` va simplement me retourner, après avoir incrémenté le compteur, un appel de ma fonction originale. Essentiellement, mon décorateur va compter le nombre d'appels, et ensuite, exécuter la fonction, tout à fait normalement. Donc maintenant, regardons cela.J'appelle ma fonction avec deux arguments : 1 et 2. Je vois que j'ai `f` qui a été appelée une fois. Je rappelle ma fonction avec des arguments différents, et je vois que `f` a été appelée deux fois. Et, je vous le rappelle, comme mon décorateur a une signature qui est générique, j'ai passé `* **`, donc je peux l'appeler sur n'importe quel type de fonction. Je peux réappliquer mon décorateur à une nouvelle fonction. Donc, comme je réapplique mon décorateur à une nouvelle fonction, ça va créer une nouvelle instance, avec son propre compteur. Et donc maintenant, je vais pouvoir appeler ma fonction `g`, et je vais avoir un nouveau compteur spécifique à ma fonction `g`.Nous venons de voir la notion de **décorateur**. Les **décorateurs** permettent d'ajouter une couche de logique autour de l'appel des fonctions, avec, et c'est un point clé des décorateurs, avec une notation explicite, liée à la déclaration de la fonction. Les décorateurs représentent, sans doute, une des techniques de programmation de Python avancées les plus utiles et les plus fréquentes. Parce que c'est très courant de devoir modifier le comportement d'une fonction. Et, avec ce concept de décorateur, vous avez ainsi un outil de programmation qui vous permet de factoriser vos modifications. Les décorations sont devenues tellement populaires, en Python, que ça a été étendu au concept de classe. D'ailleurs, nous aborderons ce sujet dans les compléments.À bientôt !# W9-S3 Les clôtures de fonctionsNous avons vu, dans une précédente vidéo, la notion de **décorateur**, et nous avons montré que nous pouvions implémenter un décorateur sous forme d'une classe. Cependant, vous savez qu'un décorateur, c'est un *callable* qui retourne un *callable*. Ça veut donc dire qu'on pourrait tout à fait implémenter un décorateur sous forme d'une fonction qui retourne une fonction. Pour cela, on utilise une technique qui s'appelle la **clôture**.Avant d'expliquer cette technique, il faut que je vous explique ce qu'est une **variable libre**, en Python. En Python, nous disons qu'une variable est **libre**, lorsqu'elle n'est ni locale, ni globale. Essentiellement, une variable libre, c'est une variable qui est contenue dans une fonction englobante. Et, on dit qu'en Python, on a une **clôture** ou qu'une fonction est une **clôture**, lorsqu'on a une fonction qui référence des variables libres.Ouvrons maintenant un éditeur IDLE pour jouer avec cette notion de **clôture**.Regardons un exemple. Je vais définir, dans mon éditeur, une variable `y` qui est égale à 3, et une fonction, que je vais appeler `incremente`, qui prend un argument `x`. Et ensuite, ma fonction va simplement faire un `return x+y`. Donc, nous voyons qu'ici, nous avons une fonction tout à fait classique, qui n'a rien de particulier. En fait, cette fonction n'est pas ce qu'on appelle, en Python, une **clôture**, puisqu'elle ne référence pas de variable libre, parce que je n'ai pas de variable libre.Donc maintenant, regardons une vraie implémentation de **clôture**. Donc, je vais définir une fonction, mais, au lieu de l'appeler directement `incremente`, je vais appeler une fonction que je vais appeler `plus_n` qui prend un argument `y`. Je vous rappelle que les paramètres d'une fonction sont des variables locales de cette fonction. Et ensuite, je vais définir ma fonction `incremente` qui va retourner `x` plus `y`. Et après, lorsque j'appelle ma fonction `plus_n`, cette fonction va retourner `incremente`.Donc ici, regardons ce que j'ai. J'ai une fonction qui s'appelle `plus_n` qui a un paramètre `y`. Cette fonction définit une fonction `incremente` qui prend un paramètre `x` et qui va retourner `x+y`. `y` est une variable libre, donc ma fonction `incremente` est une clôture, et ma fonction `plus_n` retourne `incremente`. Regardons comment ça se manipule en pratique.Donc je vais définir une variable `plus3` qui est égale à `plus_n(3)`. Donc qu'est-ce que ça va faire ? Ça va appeler ma fonction `plus_n`, ça lui passe 3 comme argument, et ça va retourner ma fonction `incremente`. Sauf que ma fonction `incremente`, elle va garder un lien vers cette variable libre `y`. Donc, ça veut dire que ma fonction `incremente`, à chaque fois que je l'appellerai, elle va retourner `x+3`, `y` étant la référence vers cet entier 3. Donc, j'exécute ça.Et maintenant, je fais un `plus3(10)`. Et regardons le résultat. Je vois bien apparaître 13. Donc, pour ceux qui aiment voir les détails d'implémentation, cette fonction `plus3` a un attribut, qu'on appelle `__closure__`. Voilà et donc, cet attribut garde une référence vers toutes les variables libres. Donc, en fait, c'est un tuple qui garde les références vers les variables libres. Et si je prends le premier élément, et que j'appelle l'argument `cell_contents`, je vais bien voir la référence vers l'entier 3.Regardons, maintenant, comment implémenter un décorateur, en utilisant cette notion de clôture. Imaginons que je veuille écrire un décorateur qui vous permet de calculer le temps d'exécution d'une fonction. Donc, je vais d'abord importer le module `time`, puis ensuite, je vais définir une fonction que j'appelle `timer`. `timer`, c'est mon décorateur. `timer` prend un argument : c'est la fonction `f` que je vais décorer. Ensuite, `timer` définit une fonction `wrapper`, donc ça va être ma clôture, qui prend une signature `*args, **dargs`, dont je vous rappelle que cette signature `* **` me permet d'accepter n'importe quelle combinaison d'arguments. C'est donc un décorateur qui pourra décorer absolument n'importe quelle fonction. Ensuite, je définis une variable `start` qui prend le temps à l'appel de `wrapper`. Dans la variable `res`, je mets le résultat d'appel de ma fonction. Donc, j'exécute ma fonction et je prends sa valeur de retour, dans la variable `res`. Je l'appelle avec la signature `* **` qui permet, encore une fois, de pouvoir passer n'importe quelle combinaison d'arguments à ma fonction. Donc, c'est un décorateur tout à fait général. Et ensuite, je vais afficher, avec une *f-string*, le temps d'exécution qui est, essentiellement, le temps maintenant `time.time() - start`. Et ensuite, je retourne la valeur de retour de ma fonction. Et puis, mon décorateur `timer` va retourner `wrapper` puisque, je vous rappelle, qu'un décorateur doit retourner un *callable*. Le *callable*, que je retourne, c'est `wrapper`. Donc maintenant, je décore ma fonction avec `@timer` et ma fonction, c'est une fonction que j'appelle `sum_poly5` qui va simplement calculer la somme des puissances 5 des entiers allant de zéro à n-1. Et donc, je mets ça dans une expression génératrice. Et je calcule la somme de cette expression génératrice. Je vous rappelle, au passage, que l'avantage de cette syntaxe, c'est que je ne crée aucune structure de données temporaire. Et maintenant, j'appelle `sum_poly5` sur un million, et je vois que le temps d'exécution s'affiche : j'ai bien 0,47 seconde.Maintenant, j'ai une limitation avec cette notation de décorateur. En fait, la limitation de ma clôture, c'est qu'une clôture ne me permet pas de modifier les variables libres. En effet, si jamais je fais une affectation localement d'une variable libre, cette variable va devenir une variable locale. Or, ça peut poser un problème parce que je peux tout à fait vouloir modifier des variables libres. Prenons un exemple simple. Par exemple, pour maintenir un compteur qui compte le nombre d'appels d'une fonction. Alors comment est-ce que je peux faire ça ? En fait, je vais vous présenter, dans la suite, deux techniques qui permettent de garder un compteur lorsque j'appelle un décorateur. Regardons ça.La première technique utilise l'instruction `nonlocal` que nous avons déjà vue lorsqu'on a introduit les fonctions, et la deuxième technique utilise ce qu'on appelle un **attribut de fonction**. Je vais maintenant vous présenter chacune de ces techniques. Commençons par regarder l'instruction `nonlocal`. Donc pour ça, je vais définir un décorateur qui va compter le nombre d'appels que je fais à une fonction. Donc, je définis un décorateur que j'appelle `trace_call` qui prend comme argument ma fonction à décorer. Je vais maintenir un compteur dans mon décorateur que j'appelle `called`, que j'initialise à 0, et ensuite, je définis mon *wrapper*, encore une fois, `wrapper` générique qui accepte des arguments `**`. Dans mon *wrapper*, je dis que `called` est une variable `nonlocal`. Je vous rappelle que l'instruction `nonlocal` permet de dire que maintenant `called`, ça n'est plus une variable locale à `wrapper`, c'est la variable libre `called`, définie dans `trace_call`. Et dont, nonlocal me permet de modifier cette variable libre. Ensuite donc, je vais faire called = called+1, C'est donc le called de la variable libre que je vais modifier. Et ensuite, j'affiche simplement le résultat, donc je veux dire : "j'ai tant d'appels de ma fonction `f`". Je retourne le vrai appel de ma fonction `f` donc, ça veut que `wrapper` retourne l'appel de cette fonction, donc la fonction va être appelée, je vais avoir sa valeur de retour. Et pour finir, mon décorateur retournera le *wrapper*, puisque il doit retourner un *callable*.Donc maintenant, faisons un `trace_call` d'une fonction toute simple, donc ma fonction ne fait rien de spécifique. Mais, c'est juste pour tracer le nombre d'appels de cette fonction. J'appelle `my_func`, et je vois que mon décorateur incrémente le compteur `called`, et m'affiche que j'ai un appel de ma fonction `my_func`. Je rappelle une deuxième fois `my_func`, mon compteur est incrémenté de nouveau, et je vois que j'ai deux appels de ma fonction `my_func`. Une clé de cette notion de décorateur, c'est qu'à chaque fois que je vais redécorer une nouvelle fonction avec `trace_call`, je vais créer un nouveau compteur `called`, et je vais créer un nouveau `wrapper`, à chaque fois.Donc maintenant, regardons une deuxième manière de modifier une variable libre. C'est avec, ce qu'on appelle, un attribut de fonction. Donc je vous montre cette deuxième manière. Je définis toujours mon décorateur `trace_call`, et je définis un *wrapper*, toujours mon *wrapper* générique. Mais maintenant, dans mon *wrapper*, je vais écrire `wrapper.called = wrapper.called + 1`. Donc ici, au moment de l'appel, on voit que je n'ai pas d'attribut `called` dans mon *wrapper*. Donc, cette instruction ne devrait pas fonctionner. Vous allez voir, dans quelques instants, pourquoi ça fonctionne. Donc, pour l'instant, gardez simplement en tête que j'ai modifié un attribut, sur mon objet fonction lui-même, sur mon objet *wrapper*. Les fonctions étant des objets mutables, on peut leur rajouter des attributs et les modifier. Donc maintenant, j'affiche `wrapper.called` appels de `f`, et je retourne l'appel de ma fonction normale.Mais maintenant, la clé de fonctionnement de cet attribut de fonction, c'est que, après la définition de ma fonction, je définis un attribut `called` sur `wrapper`. Donc pourquoi ça fonctionne ? Ça fonctionne parce que, tant que je n'ai pas appelé `wrapper`, le bloc de code de ma fonction n'est pas appelé. Par conséquent, je n'appelle pas `wrapper.called = wrapper.called + 1`. Donc, au moment de l'appel de ce *wrapper*, l'attribut `called` aura déjà été créé. Et donc ensuite mon décorateur retourne `wrapper`.Donc maintenant, je décore, comme précédemment, ma fonction avec `trace_call`. Et je peux appeler ma fonction une fois, et je peux l'appeler deux fois, et je vois bien que j'ai le compteur d'appels qui est incrémenté. Alors maintenant la question qu'on peut se poser c'est : comment garder les métadonnées de ma fonction décorée ? En effet, vous n'avez peut-être pas noté ce point, qui est un point important, c'est que maintenant, votre variable `f` ne référence plus la fonction originale, mais référence un nouvel objet qui s'appelle `wrapper`. Donc, ça veut dire que le nom de cet objet fonction est différent de la fonction originale, et que tout ce qui est *docstring*, par exemple, est également différent. Donc, je vais vous montrer cet exemple.Je redéfinis mon décorateur `trace_call` avec un décorateur qui est implémenté avec une technique d'attribut de fonction. Et maintenant, dans ma fonction, je définis une *docstring*, documentation pour `my_func`. Maintenant, regardons ce qui se passe si j'appelle `help` sur `my_func`. En fait, `help` sur `my_func`, `my_func`, maintenant, référence l'objet `wrapper`, donc, en fait, ça n'est plus l'objet `my_func` qui est référencé mais l'objet `wrapper`. Donc `help` va me dire, voici l'aide de `wrapper` et comme l'objet `wrapper` n'a pas la *docstring* de `my_func`, je ne vois pas cette *docstring* apparaître. Donc ça, c'est un petit peu gênant parce que, d'un point de vue technique de programmation, on aimerait que mon décorateur puisse modifier ma fonction mais, de manière complètement transparente. Donc, si j'appelle `help` sur ma fonction, que ma fonction soit bien la fonction originale. Or, ça n'est pas le cas.En fait, il existe une technique très simple pour garder les métadonnées de la fonction décorée, dans le *wrapper*. Il existe un module `functools` qui a un décorateur qui s'appelle `wraps`. Donc, pour garder les métadonnées, vous n'avez qu'à faire `from functools import wraps` et décorer votre *wrapper* avec `wraps(f)`, `f` étant évidemment la fonction à décorer. Ainsi, ce décorateur va modifier le *wrapper* pour qu'il ait, comme nom, le nom de la fonction `f` et qu'il ait, comme *docstring*, la *docstring* originale de la fonction `f`. Donc maintenant, je décore ma fonction tout à fait normalement, avec sa *docstring* documentation pour `my_func`. Et maintenant, si j'appelle `help` sur `my_func`, regardons ce qu'on observe. On observe que j'ai bien le bon nom de fonction, `my_func`, et que j'ai bien la bonne *docstring*. Donc, d'une manière générale, lorsque vous écrivez un décorateur avec une technique de fonction, n'oubliez pas d'utiliser `wraps`, qui vous permet de garder les bonnes métadonnées.Nous venons de voir une nouvelle manière d'implémenter des **décorateurs** avec la notion de décorateur implémenté sous forme de fonction. Nous avions vu des décorateurs implémentés sous forme de classe, maintenant, nous avons vu des décorateurs implémentés sous forme de fonction. Vous pouvez vous dire qu'en fait, ces deux méthodes sont totalement équivalentes, donc je pourrais les utiliser de manière interchangeable. En fait, elles ne sont pas totalement équivalentes, et surtout, lorsque vous faites de la programmation avancée, c'est important de maîtriser un large éventail de techniques de programmation. Les **clôtures de fonction** participent à améliorer votre panorama de techniques de programmation.À bientôt !# W9-S4 Les métaclassesDans cette vidéo, nous allons parler du sujet des **métaclasses**. La **métaclasse** est l'objet qui va créer toutes les classes en Python. C'est, par conséquent, très important de comprendre ce mécanisme pour améliorer votre compréhension du langage. En pratique, à quoi peuvent servir les métaclasses ? En fait, elles permettent de modifier les objets classe au moment de leur création. Donc, vous pouvez, par exemple, valider des noms de méthodes, dynamiquement. Vous pouvez, également, générer automatiquement des méthodes, créer des propriétés ou des descripteurs, de manière automatique. En fait, dès que vous utilisez des grosses librairies, il est probable que les métaclasses soient à la manœuvre. Par conséquent, c'est important de comprendre cette notion. Et même, si vous n’implémentez pas vous-même des métaclasses, la compréhension de ce mécanisme de création des objets permettra d'améliorer, de manière importante, votre compréhension du langage. Regardons maintenant cette notion de métaclasse.Dans cette vidéo, nous allons aborder trois notions importantes. Et ces notions sont importantes parce qu'en Python, tout est un objet, mais tous les objets n'ont pas exactement les mêmes propriétés. En fait, dans cette vidéo, nous allons détailler les propriétés de trois objets particuliers : les **métaclasses**, les **classes** et les **instances**. Commençons par nous poser une première question : quelle est la super-classe de toutes les classes en Python ? Nous avons déjà vu, lorsqu'on a parlé des classes, que `object` était la super-classe dont on héritait, automatiquement, lorsqu'on définissait une classe. Alors, regardons cela.Je définis une classe `C` et je regarde quelle est la super-classe de cette classe. Je vois que c'est `object`. Ça, ce n'est pas une surprise, c'est quelque chose que nous avons déjà vu. Et regardons quelle est la super-classe de `object`. Je vois que la super-classe de `object`, c'est rien donc, ce qui nous confirme bien qu'il n'y a rien  au dessus d'`object` dans l'arbre d'héritage. `object` est la super-classe de toutes les classes. Donc, je vais classer `object` dans la catégorie classe mais, avec une propriété un peu particulière, c'est la super-classe de toutes les classes. Confirmons cela en regardant les types *builtins*.Quelle est la super-classe de `int` ? C'est `object`. Quelle est la super-classe de `dict` ? C'est `object`. Et, quelle est la super-classe de `str` ? C'est également `object`. Donc, on voit que, que je définisse une classe moi-même avec l'instruction `class` ou que je prenne un type *builtins*, ils ont tous pour super-classe la classe `object`.Alors, quelle différence, maintenant, j'ai entre une classe et une instance ? Une classe a pour type l'objet `type`, et une instance a pour type sa classe. J'ai également deux autres différences avec les classes que je vous présente rapidement : c'est que les classes peuvent avoir des sous-classes, pas les instances, et que les classes peuvent avoir des instances, pas les instances. Donc, revenons sur cette notion de type.Le type d'une classe est l'objet `type`. Donc, je définis une classe `C` et je regarde quel est le type de l'instance de C. Le type de l'instance de `C`, c'est sa classe `C`. Donc `i`, je le classe dans la catégorie instance. Quel est le type de la classe `C` ? C'est `type`. Donc, `C` est clairement une classe. Je le classe dans la catégorie des classes. Ensuite, je vais regarder avec les types *builtins*. Quel est le type de `1` ? C'est `int`. Donc `1`, c'est une instance. Quel est le type de `int` ? C'est `type`. Donc `int`, je le classe dans la catégorie classe. Quel est le type de la chaîne de caractères `'a'` ? C'est `str`. Donc `'a'`, la chaîne de caractères `'a'`, c'est une instance. Et quel est le type de `str` ? C'est `type`. Donc `str`, je le classe dans la catégorie classe.De nouveau, vous voyez que Python ne fait aucune différence entre les types *builtins* et les classes que vous avez définies vous-même. Toutes les classes ou tous les types *builtins* héritent de `type`. En fait, vous n'avez pas de différence, en Python, entre un type *builtins* et une classe que vous implémentez. Ce sont des objets qui se comportent exactement de la même manière. Alors, on peut se demander mais pourquoi est-ce que `type` est le type de toutes les classes, en Python ? En fait, ça veut dire quoi être le type d'une classe ? Le type d'une classe est l'objet qui instancie cette classe, donc qui va créer l'objet classe. `type` est l'objet qui instancie toutes les classes, en Python. Et, par définition, un objet qui instancie toutes les classes, c'est ce qu'on appelle une **métaclasse**. Donc une métaclasse, ça n'est rien d'autre que ça. C'est un objet qui va instancier les classes. Et, en Python, on a une seule métaclasse, c'est l'objet `type`.Donc, maintenant, si je reprends mon affichage, je vois que j'ai une seule métaclasse, en Python, c'est `type`. J'ai un certain nombre de classes : j'ai toutes les classes *builtins*, plus toutes les classes que je vais créer moi, et `object` qui un objet un peu particulier mais qui est la super-classe de toutes les classes. Et ensuite, j'ai mes instances. Une propriété importante du type de la métaclasse, c'est qu'en fait le type d'une classe, c'est également le type de sa super-classe. Donc regardons ça.Je crée ma classe `C`, et je crée une classe `D`, qui hérite de `C`. Quel est le type de `object`, la super-classe de `C` ? C'est `type`. Quel est le type de `C` ? C'est encore `type`. Et quel est le type de `D`, la sous-classe de `C` ? C'est encore `type`. Comme je vous l'expliquais, le type d'une classe c'est le type de sa super-classe.Alors maintenant, vous avez bien compris qu'on avait deux primitives un peu particulières : on a `type`, et on a `object`. Il faut comprendre que ces objets sont créés, automatiquement, lorsqu'on démarre l'interpréteur. Ce sont les premiers objets créés. Et qu'après, tout le reste hérite ou est créé par ces deux primitives. Donc regardons quel est le lien entre `type` et `object` ? En fait, si on regarde quel est le type d'`object`, c'est `type`. Ça n'est pas une surprise. `type`, c'est la super-classe de toutes les classes. `object` est une classe. Donc, `type` a créé `object`. Quelle est la super-classe de `type` ? Là encore, ça n'est pas une surprise. `object` est la super-classe de toutes les classes. `type` est une classe, une métaclasse, mais c'est une classe. `type` hérite de `object`.Et pour finir, quel est le type de `type` ? Ça c'est quelque chose qui peut être un peu perturbant. On voit que c'est `type`. Donc ça veut dire que `type` est son propre type. En fait, c'est une convention qui a été prise en Python. `type`, c'est le premier objet qui est créé par l'interpréteur. Mais, comme on dit que `type` est la super-classe de toutes les classes et bien, en fait, c'est même la super-classe d'elle-même. C'est une notation conventionnelle.Donc, pour résumer ce que nous avons vu : nous avons deux primitives : `type` et `object`. Ce sont les deux objets qui sont créés au démarrage de l'interpréteur. Maintenant, `type` hérite de quoi ? `type` hérite d'`object`. Donc, en rouge, on a la relation d'héritage, et, en vert, on a la notion d'instanciation. `object` a été instancié par `type`, donc `type` est la super-classe, une autre manière de le dire, ou le type d'`object`, c'est `type`. Et `type` est également sa propre métaclasse. C'est `type` qui instancie `type`.Maintenant, je crée une classe `B`. Ma classe `B` va hériter d'`object` et va être instanciée par `type`. Si je crée une classe `C`, qui hérite de `B`, `C` hérite de `B`, et est instanciée par `type`. Et ensuite, si je crée une instance de `C`, mon instance de `C` est instanciée par la classe `C`. La question qu'on peut se poser maintenant c'est : est-ce qu'on peut créer nos propres métaclasses, en Python ? Et la réponse est clairement oui. Seulement, il y a deux manières de créer des métaclasses, en Python. La première manière d'écrire une métaclasse est de l'écrire en `C`. L'avantage d'écrire votre métaclasse en `C`, c'est que vous avez un contrôle total sur l'allocation de la mémoire. Vous pouvez donc faire absolument ce que vous voulez. Seulement, c'est un sujet extrêmement complexe, qui dépasse, de loin, le cadre de ce MOOC, nous n'en parlerons pas plus.Une deuxième manière d'implémenter des métaclasses, qui est une manière plus courante, c'est d'écrire vos métaclasses directement en Python. Vous n'aurez pas accès au mécanisme d'allocation de mémoire, mais, par contre, vous pourrez toujours modifier votre objet classe au moment de sa création. Comment est-ce qu'on fait pour écrire une métaclasse en Python ? Il suffit de créer une classe qui hérite de l'objet `type`. Encore une fois, en faisant ça, vous aurez contrôle sur la pré-instanciation de la classe, et sur l'initialisation de l'objet classe. Regardons ça un peu plus en détail.Comment est-ce que la métaclasse crée l'objet ? On va revenir sur ce processus de création de l'objet classe dans l'interpréteur Python. À gauche, je vais vous montrer le code que l'on écrit dans du code Python classique, et, à droite, ce que fait l'interpréteur. Donc vous créez une classe `C` qui contient une liste et deux méthodes : `__init__` et `reset_x`. Que va faire l'interpréteur, au moment de l'importation de ce code et au moment de la création de l'objet classe ?  Donc l'interpréteur, lorsque vous définissez une classe, va déjà garder le nom de la classe `C` ; il va s'en souvenir, et ensuite, il va exécuter le bloc de code de la classe. Donc il va créer la variable `lst` et l'objet liste, les fonctions ou les méthodes `__init__` et `reset_x`, et créer les objets correspondants, et les noms correspondant à ces objets. Et ensuite, il va créer un espace de nommage qui va être un dictionnaire qui va avoir, comme nom, chaque objet défini dans la classe, et, comme valeur, chaque objet qui a été créé. Et pour finir, l'interpréteur va appeler la fonction *builtins* `type`. Donc il va dire `C`, le nom de la classe, égal à `type` de le nom de la classe, la super-classe ou les super-classes dans un tuple, et ensuite, l'espace de nommage. Voilà. Donc, c'est essentiellement les différentes étapes que va parcourir l'interpréteur.En pratique, c'est un tout petit peu plus compliqué que ça. Mais ici, je vous présente ce que nous avons besoin de savoir, dans le cadre de cette vidéo. Donc que va faire l'appel de `type` ? En fait, l'appel de `type` va appeler la méthode `__call__` sur la super-classe `type`. Et, en fait, cet appel `__call__`, qu'est-ce qu'il va faire ? Il va appeler une méthode `new` qui va créer, à proprement dit, l'objet classe et une méthode `__init__` qui va instancier cet objet classe une fois qu'il a été créé. Donc `new`, c'est la méthode qui est responsable de la création de cet objet classe, et `__init__`, c'est la méthode qui est responsable de l'instanciation de cet objet classe. Donc, on voit qu'on peut avoir un petit peu de confusion entre le rôle respectif de `new` et de `__init__`. Et on peut même se demander, mais en pratique, qu'est-ce qu'il faut que j'implémente ? Est-ce qu'il faut que j'implémente `new` ? Est-ce qu'il faut que j'implémente `__init__` ? En pratique, on implémente très souvent `new` parce que c'est la méthode qui donne le plus de flexibilité, même si elle est un tout petit peu plus compliquée à mettre en œuvre.Donc regardons maintenant un exemple d'implémentation de métaclasse. Je vais créer une métaclasse que j'appelle `LowerAttrMetaclass` qui hérite de `type`. Pour créer une métaclasse, il faut obligatoirement hériter de type. Et quel va être le rôle de cette métaclasse ? Cette métaclasse va avoir deux rôles. Le premier rôle, ça va être de dire que toutes les classes qui sont instanciées par cette métaclasse vont automatiquement hériter d'une autre classe. Le deuxième rôle, c'est que cette métaclasse va valider la syntaxe des méthodes. Et donc, si j'ai des méthodes qui ont une mauvaise capitalisation, elle va automatiquement les mettre en minuscule. En pratique, ce n'est pas forcément quelque chose qu'on ferait. Mais, en pratique, on pourrait tout à fait valider la correcte syntaxe des méthodes, en fonction d'une certaine convention de nommage, établie par une librairie ou par un *framework*. Donc regardons maintenant l'écriture de cette métaclasse.Je crée une méthode `new` donc c'est la méthode qui va créer ma classe, qui prend comme arguments : la classe, le nom de la classe, les super-classes, et le dictionnaire, l'espace de nommage. Donc on voit que lorsque je crée une classe, j'ai accès à tout. J'ai accès au nom de la classe que je peux modifier. J'ai accès aux super-classes, bases, que je peux modifier. Et j'ai accès à l'espace de nommage de ma classe que je peux également modifier. Avant que l'objet classe soit créé. Et maintenant, je crée un dictionnaire `lowercase_attr`. Je vais parcourir mon espace de nommage avec `items()`. Et qu'est-ce que je vais faire ? Je vais regarder si mon nom de méthode ne commence pas par un double underscore. Je vous rappelle que les méthodes qui commencent par un double underscore sont, en général, réservées par le langage. Je vais mettre, dans `lowercase_attr`, le nom de ma méthode, en minuscules. Voilà donc c'est essentiellement ce que je fais. Je parcours tous les noms de méthodes qui ne sont pas des méthodes spéciales. Et si mon nom de méthode a des capitalisations un peu hasardeuses, je vais tout mettre en minuscules et je vais mettre ça dans un dictionnaire. Sinon, d'ailleurs si c'est une méthode spéciale, je récupère mon nom tel quel. Et ensuite, comme super-classe, je vais mettre, par défaut, une super-classe qui s'appelle `BaseOfAll`. Donc, c'est mon *framework* qui va dire, lorsque j'utilise ma métaclasse, j'utilise une super-classe qui est `BaseOfAll`. Et ensuite, je retourne `type.__new__` donc, comme vous créez une métaclasse pour que le processus de création de l'objet soit effectif, il faut obligatoirement appeler `__new__` sur la métaclasse `type`. Sinon, l'objet n'est pas créé. Mais, on voit qu'à `__new__`, je lui passe : un nouveau `bases` qui est `BaseofAll`, et je lui passe un nouveau dictionnaire, un nouvel espace de nommage qui est le `lowercase_attr`. Donc j'ai été capable de modifier l'arbre d'héritage. Mais également, l'espace de nommage de ma classe avant la création de cet objet. Ensuite, j'ai défini ma classe `BaseOfAll` qui définit une méthode `common_func` qui sera utilisable par toutes classes qui utilisent la métaclasse `LowerCaseAttrMetaclass`. Et ensuite, je définis ma classe `C`, et pour dire que ma classe `C` a pour métaclasse cette fameuse métaclasse, il faut que j'utilise le *keyword* particulier, `metaclass =` le nom de ma métaclasse. C'est la syntaxe que j'utilise, pour utiliser une métaclasse différente de `type`, dans une classe que j'écris moi-même. Et ensuite, ma classe va définir une fonction avec une capitalisation très hasardeuse, avec des majuscules placées de manière un peu bizarre, et ma fonction retourne simplement une chaîne de caractères.Regardons maintenant ce qui se passe lorsque j'exécute ce code-là. Je vais créer une instance de `C`, et je vois que maintenant, sur mon instance, je peux appeler une méthode qui a un nom avec une capitalisation correcte et que mon instance de `C` a également accès à `common_func` qui est une méthode qui a été définie dans la super-classe de toutes les classes qui utilisent cette métaclasse.Pour résumer, refaisons un petit diagramme. J'ai mes deux primitives de base : `type` et `object`. `type` hérite de `object` et `object` est instancié par `type` et `type` est instancié par lui-même. Je crée une métaclasse `M`. Ma métaclasse va hériter de `type`, mais va également être instanciée par `type`. Et ensuite, je définis une classe `C` qui hérite de `object` et qui est instanciée par ma métaclasse. Et pour finir, mon instance de `C` est instanciée par ma classe `C`.Dans cette vidéo, nous avons vu la notion de **métaclasse**. C'est clairement un sujet avancé, mais qui est très intéressant pour comprendre les mécanismes de création d'objets en Python. De plus, nous avons vu qu'en créant vos propres métaclasses, vous pouvez ajouter toute une couche de logique au processus de création des autres classes. Donc, vous pouvez créer des librairies qui peuvent effectuer tout un tas d'opérations comme, par exemple, la validation d'arguments ou alors la création de propriétés ou de descripteurs automatiques.À bientôt !# W9-S5 property et descripteursSi vous connaissez d'autres langages comme Java ou C++, vous êtes, sans doute, familier avec les notions de *getters* et de *setters*. Les *getters* et les *setters* sont des méthodes qui nous permettent de contrôler l'accès à des attributs, lorsque l'on les modifie ou lorsqu'on y accède. Ces *getters* et ces *setters* ont, cependant, un inconvénient majeur : c'est qu'ils ajoutent une complexité lors de l'accès à nos attributs. Et surtout, vous devez les implémenter pour tous vos attributs. Prenons un exemple.Supposons que vous ayez un objet avec un attribut `x`. Et que vous décidiez, à un moment de développement de votre code, de changer la manière d'accéder à cet attribut. Et bien, en fait, vous allez devoir modifier l'appel à cet attribut par un *getter* ou par un *setter*. Si vous avez écrit une librairie, et que d'autres personnes utilisent vos attributs, ils vont devoir entièrement modifier leur code. C'est donc quelque chose qui est très pénible. Alors, c'est vrai que les bons IDEs vous permettent de gérer ce type de refactorisation. Mais si vous utilisez du code de quelqu'un d'autre, qui a fait ce type de modification, ce sera extrêmement pénible. C'est pourquoi, en Java ou en C++, on vous recommande d'utiliser, systématiquement, des *getters* et *setters* pour n'avoir à subir ces opérations coûteuses et désagréables à faire.En Python, nous allons voir que vous n'avez pas besoin d'implémenter des *getters* et *setters* pour ajouter une couche de logique autour de l'accès ou de la modification d'un attribut. On utilise pour ça deux techniques qu'on appelle **property** et **descripteurs**. C'est ce que nous allons voir dans cette vidéo.Commençons par implémenter une classe qu'on va appeler `Maison` et qui va contrôler, par exemple, la température que l'on veut mettre dans notre maison. Donc, on va définir une classe, voilà, toute simple, que j'ai appelée `Maison`. Et dans ma classe, je vais définir ma méthode `__init__`, qui prend `self` et une température, et qui va simplement faire un `self._temperature = t`. Ensuite, je vais définir une méthode `get_temperature` qui prend `self` et qui va juste me faire un `return self._temperature`. Et je vais définir une méthode `set_temperature`, qui va juste me prendre `self` et une température à modifier, et qui va faire une petite validation. Donc, je vais faire un `if 5 < t and t < 25` (je vais un tout petit peu améliorer la présentation), voilà donc j'ai `t` qui est compris entre 5 et 25 degrés, je fais un `self._temperature = t` et je fais un `return`, donc, je mets ma température. Sinon, je fais un `raise` d'une exception, que je vais appeler `TemperatureError`, que je n'ai pas, évidemment, encore définie, mais que je vais définir juste après. Et puis ici, voilà, je définis une classe `TemperatureError` qui hérite d'`Exception`, et qui va juste faire `pass`, voilà. Donc, c'est une classe tout à fait normale.Donc là, qu'est-ce qu'on a ? On a notre classe `Maison`. Lorsqu'on crée notre instance de classe `Maison`, on va définir une température `t`. Et ensuite, avec `get_temperature`, j'ai accès à la température, et avec `set_temperature`, je peux mettre une température, et j'ai une validation de ma température. Donc là, j'ai utilisé les *getters* et les *setters* de manière tout à fait standard. J'exécute ce code. Et maintenant, je vais créer une instance de `Maison`, `m = Maison`(à 18 degrés). Et maintenant, je vais faire un `print(m.get_temperature())`. Voilà. Tout simplement. Donc je vois bien apparaître le 18. Et ensuite, je peux faire un `m.set_temperature(22)`. Je regarde ma température qui a bien été modifiée. Et pour finir, je peux faire un `m.set_temperature(28)`. Je dépasse ma plage autorisée, j'ai donc une exception `TemperatureError` qui est lancée. Voilà. Comportement normal. Donc on a implémenté ce *getter* et ce *setter*, mais, on voit bien que dans la manipulation de ces attributs, à chaque fois, je dois écrire `get_temperature`, `set_temperature`. C'est un petit peu pénible.En fait, en Python, je peux définir ce que j'appelle une **property**. C'est quoi une **property** ? C'est dire à ma classe que je définis un attribut tout à fait classique et que cet attribut va correspondre à une couche de logique particulière. Je cherchais le mot attribut. Je vais donc définir un attribut. Regardons comment ça s'implémente. Je définis `temperature`, donc, c'est mon attribut normal. Et je vais dire que, maintenant, c'est une *property*, qui va prendre, comme *getter*, `get_temperature`, et, comme *setter*, `set_temperature`, tout simplement. Donc maintenant, je n'ai rien modifié à mon code, j'ai juste défini une *property*, qui dit que, maintenant, j'ai un attribut `temperature` qui correspond à cette *property*. Lorsque je vais accéder à cet attribut, je vais appeler, automatiquement, la méthode `get`. Lorsque je vais changer la valeur de cet attribut, je vais, automatiquement, appeler la méthode `set`.Donc maintenant, l'intérêt de ça, c'est que si jamais j'ai d'autres attributs dans ma classe, je n'ai pas besoin de faire des *getters* et des *setters*. Je peux directement manipuler ces attributs, et si, plus tard, je décide de rajouter une couche de logique, je n'aurai qu'à implémenter deux méthodes, et à définir une *property* sur cet attribut. Vous noterez également, et c'est un point très important, que mes attributs, ici, utilisent tous un underscore. En effet, il ne faut pas que, dans vos *getters* et vos *setters*, vous utilisiez le même attribut sinon vous auriez un appel récursif à votre méthode. Donc maintenant, j'exécute ce code.Et maintenant, regardons comment manipuler ça. Je vais, simplement, créer une nouvelle instance de `Maison`, et je peux, directement, faire un `m.temperature` pour regarder la température actuelle. Et je peux faire un `m.temperature = 22`. Je vais donc voir ma température qui a été modifiée. Et si jamais, je fais un `m.temperature = 28`, je repasse, évidemment, dans ma couche de logique, et j'ai mon d'exception `TemperatureError`.Le mécanisme de **propriété** que nous venons de voir repose sur un autre mécanisme qu'on appelle **descripteur** qui est plus général que les **propriétés** et plus puissant. Regardons comment implémenter un **descripteur**.Un descripteur, en fait, c'est une classe, tout à fait normale, une classe Python sur laquelle on va définir une méthode spéciale, qui s'appelle `__get__`. Si notre classe a, au moins, cette méthode on va dire que cette classe est un descripteur et elle peut avoir encore deux autres méthodes utilisées par le protocole des descripteurs qui sont les méthodes `__set__` et `__delete__`. Donc regardons cela.Je vais créer une classe `Temperature` qui va définir une méthode `__get__` qui prend comme arguments `self`, `inst`, et `instype`. Je vais revenir, dans quelques instants, sur la signification de ces paramètres. Et je vais retourner `inst._temperature`. Voilà. Donc, j'ai une classe `Temperature` qui définit une méthode `__get__`. C'est donc, par définition, un descripteur. En tout cas, c'est une classe qui respecte le protocole des descripteurs. Ma méthode `__get__` prend trois paramètres : `self`, c'est l'instance du descripteur ; j'ai donc un accès vers cette instance de descripteur, ce qui me permet, par exemple, de stocker des attributs dans cette instance. `inst`, c'est l'instance de l'objet sur lequel on a mis le descripteur ; on va voir ça, dans quelques instants. Et `instype`, c'est la classe qui a créé cette instance sur laquelle on a mis le descripteur. On va revoir ça, dans quelques instants.Maintenant, je vais définir une méthode `__set__` qui prend des arguments `self`, `inst` et `t`. Et, dans ma méthode `__set__`, je vais faire une petite validation, comme ce que j'avais dans l'exemple précédent. Est-ce que `t` est compris entre 5 et 25 ? S'il est compris entre 5 et 25, je vais faire `inst._temperature = t`, c'est-à-dire que je modifie ma température, et ensuite, je retourne. Et ici, je fais simplement un `raise TemperatureError()`. Donc, vous remarquez que ça correspond à un *if else* ; j'ai mis un `return` pour éviter d'avoir à écrire le *else*. On aurait pu l'écrire de manière différente. Et ensuite, je définis ma classe `TemperatureError` qui est mon exception, qui hérite de `Exception`, voilà, et qui fait simplement `pass`. J'ai défini, maintenant, mon exception en plus. Et pour finir, je définis ma classe `Maison`. Donc, c'est la classe que j'avais tout à l'heure, sur laquelle je vais définir mon descripteur. Donc, dans ma classe `Maison`, je définis la méthode `__init__` qui prend `self` et une température, une température pour initialiser mon instance, au moment où je la crée. Et ma méthode `__init__` va simplement faire un `self.temperature = t`. Et ensuite, pour mettre un descripteur dans ma classe `Maison`, je n'ai qu'à écrire `temperature = Temperature()`. C'est-à-dire que mon attribut `temperature` est, en fait, une instance du descripteur `Temperature`.Donc, que va faire Python, maintenant ? À chaque fois que je vais accéder à cet attribut `temperature`, on va, automatiquement, appeler la méthode `__get__`. À chaque fois que je vais modifier cet attribut `temperature`, on va, automatiquement, appeler la méthode `__set__`. Vous remarquez également une chose importante : c'est qu'ici j'utilise `_temperature` avec un underscore et ici également. Attention de ne pas utiliser l'attribut `temperature` sinon ça ferait un appel récursif, et dans ce cas-là, votre programme ne fonctionnerait pas correctement. Par contre, à l'intérieur de ma classe `Maison`, je peux effectivement utiliser l'attribut `temperature` directement. Donc directement, utiliser mon descripteur. J'exécute ce code, je l'évalue.Et maintenant, je vais créer une instance de `Maison`, que j'initialise à 18 degrés. Et je vais regarder quelle est la température dans `Maison`. Je vois qu'il s'affiche bien 18 degrés. Je peux, maintenant, modifier ma température et la mettre à 22 degrés. Je regarde, de nouveau, quelle est la température dans `Maison`. Maintenant, c'est 22 degrés. Évidemment, comme j'appelle la méthode `__set__` j'ai tout mon mécanisme de validation qui entre en jeu. Et si ma température sort de l'intervalle autorisé, je vais avoir une exception, mon exception `TemperatureError`.En conclusion, nous avons vu qu'il était possible, en Python, d'ajouter une couche de logique autour de l'accès ou de la modification des attributs. On utilise, pour ça, les **property** ou alors un mécanisme plus général sur lequel reposent les property : les **descripteurs**. Vous verrez qu'en pratique, les property sont très souvent largement suffisantes, mais, dans les cas les plus complexes et les plus sophistiqués, vous avez toujours la possibilité d'implémenter vos propres descripteurs.À bientôt !# W9-S6 Protocole d'accès aux attributsNous avons vu, dans une précédente vidéo, les notions de **property** et de **descripteurs**. Nous avons vu qu'il s'agissait d'un mécanisme puissant pour contrôler l'accès et la modification d'un attribut particulier. Dans cette vidéo, nous allons voir une autre mécanique qui repose sur trois méthodes, qui s'appellent `__getattribute__`, `__setattr__`, et `__getattr__` qui permettent de contrôler l'accès et la modification de n'importe quel attribut, en Python. Nous allons voir, également, que ces méthodes implémentent un mécanisme subtil et complexe et que, surtout, leurs noms ont été très mal choisis, ce qui est souvent source de confusion. Nous allons revenir sur ça, dans quelques instants.Donc commençons par regarder la méthode `__getattribute__`. Si vous implémentez la méthode `__getattribute__` sur votre classe, vous aurez la certitude que tous les accès à des attributs, sur votre instance, passeront par cette méthode `__getattribute__`. Donc que votre attribut existe dans votre instance ou qu'il n'existe pas, vous allez passer par `__getattribute__`. Par contre, toute la logique de recherche des attributs et, en particulier, les mécanismes des descripteurs sont implémentés dans la méthode `__getattribute__` de l'objet `object`. Donc si vous voulez garder cette mécanique de recherche des attributs et garder la mécanique des descripteurs, vous serez obligés d'appeler `object.__getattribute__()` dans votre surcharge de `__getattribute__`.Regardons maintenant une deuxième méthode qui s'appelle `__setattr__`. `__setattr__` est la méthode, si vous l'implémentez dans votre classe, qui sera systématiquement appelée lorsque vous modifiez un attribut, que cet attribut existe et que vous vouliez le modifier. Toute la mécanique de modification des attributs est implémentée dans, encore une fois, la méthode `__setattr__` de l'objet `object`. Donc si vous voulez modifier votre attribut et si vous voulez garder la mécanique des descripteurs, vous serez obligés d'appeler `object.__setattr__()` dans votre implémentation de `__setattr__`. Nous remarquons d'ailleurs ici que ce nom `__setattr__` est étrange. On se serait attendu à ce que cette méthode s'appelle `__setattribute__`, parce qu'en fait, cette méthode est vraiment la méthode symétrique de `__getattribute__`. Mais pour des raisons historiques, elle s'est appelée `__setattr__` ce qui est un petit peu troublant, mais qui est l'implémentation que l'on a en Python.Regardons maintenant la dernière méthode qui est la méthode `__getattr__`, qui est elle, une méthode très différente de `__getattribute__` et de `__setattr__`, contrairement à ce que son nom pourrait laisser entendre. En fait, `__getattr__` est, en quelque sorte, une méthode de la dernière chance. Si vous n'implémentez pas `__getattribute__` dans votre classe, et si l'attribut auquel vous essayez d'accéder n'existe pas dans l'espace de nommage ou le long de l'arbre d'héritage, la méthode `__getattr__` va être appelée en dernier ressort. Donc, c'est la dernière méthode qui est appelée, avant d'avoir une exception `AttributeError`.Encore une fois, vous avez trois méthodes : `__getattribute__`, `__setattr__`, `__setattr__` est la méthode symétrique de `__getattribute__`, et vous avez une méthode qui s'appelle `__getattr__` qui est, en quelque sorte, la méthode de la dernière chance, qui n'est appelée que si cet attribut n'a pas été défini et si l'attribut n'est pas défini le long de l'arbre d'héritage.Ouvrons maintenant un éditeur IDLE pour commencer à jouer avec ces différentes méthodes. Reprenons l'exemple du descripteur `Temperature` que nous avions dans une précédente vidéo. Donc ici, vous voyez que j'ai mon descripteur : j'ai défini mes deux méthodes `__get__` et `__set__`. À ce propos, voyez que j'ai un petit peu de code, donc, n'hésitez pas à mettre cette vidéo en pause et à prendre le temps de, tranquillement, taper le code qui est dans mon éditeur IDLE.Donc, on voit que j'ai mon descripteur `Temperature` qui définit une méthode `__get__`, dans laquelle je vais afficher un print de `'desc __get__'`, ça veut dire que je rentre dans la méthode `__get__` de mon descripteur. Et j'ai une méthode `__set__` dans laquelle je fais simplement un `print 'desc de __set__'` et j'affiche l'argument que je vais affecter à mon attribut descripteur lorsque je veux modifier. Je n'ai pas de logique dans mon descripteur `__set__` parce qu'ici l'intérêt est uniquement de tracer les différents appels de méthodes. Puis ensuite, j'ai ma classe `Maison`, qui définit sa méthode `__init__`, tout à fait normale, qu'on a déjà vu précédemment, et j'ai implémenté les deux méthodes spéciales `__getattribute__` et `__setattr__`. Vous remarquez que je n'ai pas implémenté `__getattr__`, qui est une méthode un petit peu différente, et je vous laisserai expérimenter cette méthode, à titre d'exercice.Donc la méthode `__getattribute__`, je vous rappelle, est appelée systématiquement. Dans cette méthode, je vais afficher que je suis bien dans `__getattribute__`, et je vais afficher l'attribut auquel je suis en train d'accéder. Et ensuite, dans `__setattr__`, ma méthode `__setattr__` prend trois arguments : `self`, `a`, et `v`. `a` est l'attribut que je vais modifier, `v` est la valeur que je veux affecter à mon attribut. Donc ma méthode `__setattr__` va, encore une fois, juste faire un affichage que j'appelle `__setattr__`, il va afficher cet attribut est maintenant égal à cette valeur. Donc ça va me permettre de tracer ces différents appels et je définis bien `temperature` comme un descripteur, c'est une instance de la classe `Temperature` qui est un descripteur. Donc, j'exécute ce code.Et maintenant, je vais créer une instance de ma `Maison`. Donc, je vais écrire `m = Maison(18)`. Regardons ce qui va se passer lorsque je fais un retour chariot. Lorsque je fais un retour chariot, je vais appeler un `self.temperature` ; ça veut donc dire que je vais changer la valeur de l'attribut `temperature`, `temperature` étant un descripteur. Et, on voit que j'ai trois méthodes qui sont appelées. `__setattr__`, avec l'attribut `temperature` 18, c'est normal ; `__setattr__` est appelée systématiquement dès que je modifie un attribut de ma classe. Il se trouve que cet attribut est un descripteur. Dans ma méthode `__setattr__`, vous remarquez que j'ai appelé la méthode `object.__setattr__`, donc je vais rentrer dans la logique des descripteurs et je vais donc appeler mon descripteur `desc __set__ 18`. Dans mon descripteur, je fais, dans `__set__`, ici, je modifie, dans mon instance, l'attribut `_temperature`, ça va donc repasser par la méthode `__setattr__` avec `_temperature` et ça va le mettre à 18. On voit toute cette logique un petit peu sophistiquée. Je passe dans le `__setattr__` avec `temperature`, c'est un descripteur, je passe dans l'appel `__set__` du descripteur, et l'appel `__set__` du descripteur modifie un attribut de mon instance, je repasse donc dans `__setattr__` avec l'attribut `_temperature`.Maintenant, essayons d'accéder à cet attribut `temperature`. Et pour ça, je vais utiliser la complétion, je vais faire `m.temp` tab (tabulation) et nous voyons que deux méthodes sont appelées. `__getattribute__` est appelée pour l'attribut `dict`, et `__getattribute__` est appelée pour l'attribut `class`. Mais quel rapport avec mon mécanisme ? En fait, simplement, j'ai fait un `m.temp` complétion. IDLE pour savoir quelle complétion faire va interroger les espaces de nommage. Donc, il commence par interroger l'espace de nommage de mon instance, c'est l'attribut `dict`. Il ne trouve pas l'attribut dedans, il continue à remonter l'arbre d'héritage, il arrive dans `class`. Et dans `class`, ensuite, il va interroger les différents espaces de nommage, mais le reste n'est pas instrumenté donc on ne voit pas les différents appels. Mais, en fait, IDLE, lorsqu'on fait une complétion, va remonter l'arbre d'héritage, jusqu'à trouver mon attribut.Donc, maintenant, je fais un `m.temperature`. Voyons les différents appels qui sont effectués. Je vois la méthode `__getattribute__` qui est appelée pour l'attribut `temperature`. Normal, tous les appels d'attributs passent par `__getatttribute__`. Il se trouve que `__getattribute__` est un descripteur. Or, dans ma méthode `__getattribute__`, j'ai bien fait un `return` de `object.__getattribute__`. Donc, j'appelle bien la méthode `__getattribute__` sur `object` qui contient la logique des descripteurs. Cette méthode va détecter que c'est un descripteur, va appeler la méthode `desc.__get__`. Et, dans le `__get__`, qu'est-ce que je fais? Je fais un `inst._temperature`, j'appelle donc l'attribut `_temperature` sur mon instance. Donc, je vois bien, ici, l'appel de `__getattribute__` pour cet attribut `_temperature`.Continuons à jouer un petit peu avec ces descripteurs. Maintenant, je vais affecter une valeur, par exemple 22, à mon attribut `temperature`. Voilà. Je l'exécute et je vois que je vais passer par `__setattr__` `temperature` égale 22. Ensuite, je détecte que c'est un descripteur, je passe dans la logique des descripteurs. Mon descripteur va modifier `_temperature`, je repasse dans `__setattr__` pour `_temperature`.Maintenant, regardons un attribut qui n'existe pas, dans mon espace de nommage : `m.x`. `x` est un attribut sur mon instance, je passe dans `__getattribute__`, `__getattribute__` appelle le `__getattribute__` d'`object` qui est ici, qui va implémenter toute la logique qui est utilisée lorsque je ne trouve pas un attribut. Je ne trouve pas mon attribut, j'ai donc une exception `AttributeError`.Si, maintenant, je fais un `m.x = 10`, je vois que j'appelle `__setattr__`, je n'ai pas la logique des descripteurs, c'est normal puisque `x` n'est pas implémenté comme un descripteur. Et ensuite, je peux bien accéder à mon attribut, et ça va repasser par `__getattribute__` et j'obtiens la valeur.Nous venons de voir les méthodes `__getattribute__`, `__setattr__` et `__getattr__`. Nous avons bien insisté sur le fait que les méthodes `__getattribute__` et `__setattr__` sont des méthodes symétriques. Dans ce sens, `__setattr__` n'a pas été très bien nommée, cela aurait mieux de l'appeller `__setattribute__` mais bon, c'est comme ça. Nous avons vu que `__getattr__` est une méthode un petit peu différente, qui est, entre guillemets, "la méthode de la dernière chance" qui sera appelée uniquement si un attribut n'existe pas.Cette vidéo conclut ce MOOC sur Python. Thierry et moi espérons que vous avez apprécié ce MOOC et que nous vous avons convaincu que Python est un excellent langage pour aborder tout un tas de problèmes. Si vous avez suivi tout ce MOOC, ce que nous supposons si vous arrivez à cette vidéo, vous avez maintenant une profonde connaissance de Python qui vous permettra d'aborder les sujets les plus complexes. Cependant, n'oubliez jamais que seule la pratique vous permettra de devenir un expert de ce langage.Merci encore de votre confiance. Au revoir ! 