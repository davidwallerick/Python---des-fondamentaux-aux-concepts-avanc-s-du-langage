# MOOC INRIA / UCA : Python 3 : des fondamentaux aux concepts avancés du langage

## Arnaud Legout et Thierry Parmentelat 

## Transcriptions des videos de la semaine 6 : Conception des classes

# W6-S1 Classes, instances et méthodes

Bonjour !

La programmation objet est un paradigme de programmation qui est puissant et souple, mais qui vient au prix d'un effort de conception supplémentaire. Cependant, comme en Python tout est un objet, vous pouvez très rapidement tirer pleinement parti de ce paradigme de programmation. Avant de pouvoir le maîtriser, il faut connaître un certain nombre de notions comme la notion de **classe**, d'**instance**, de **méthode**, la notion de **méthode spéciale** et la notion d'**héritage**. Dans cette semaine, nous allons couvrir ces différentes notions. Nous allons également vous expliquer comment, en exploitant ce paradigme de programmation objet, vous pouvez créer vos propres **itérateurs**, vos propres **exceptions** et également vos propres **context managers**.

Nous avons vu, dans une précédente vidéo, en introduction de ce mooc, la notion de **programmation objet** et la notion de **classe**. Nous allons dans cette vidéo revenir sur ces différents concepts.

Vous savez qu'en Python tout est un objet, les entiers, les listes, les chaînes de caractères, les fonctions, les modules, absolument tout. Et les caractéristiques de chaque objet sont définies par leur type. En Python, les types *built-in* sont très puissants mais ils ne peuvent pas couvrir tous vos besoins. C'est pourquoi vous avez le concept de classe.
Une **classe**, en Python, vous permet de définir vos propres types, c'est-à-dire que vous allez pouvoir créer un modèle pour des objets que vous pouvez produire qui auront leurs propres caractéristiques. Comme en Python tout est un objet, les classes également sont des objets. La classe est la définition des caractéristiques que vous allez écrire dans votre module, et lorsque le module sera importé, l'objet classe sera créé. Vous aurez ainsi ce qu'on appelle une usine à instances ; à chaque fois que vous appellerez votre classe, votre classe va créer de nouvelles instances. Et vous allez avoir une relation particulière entre l'instance et sa classe. En fait, on dit que l'on a une relation d'héritage entre l'instance et la classe. Ce qui veut dire que l'instance va pouvoir hériter, observer tous les attributs qui sont définis dans la classe. Cette relation d'héritage est en fait liée à la notion d'espace de nommage. Une classe a son propre espace de nommage. Et une instance a son propre espace de nommage. Lorsque vous recherchez un attribut dans une instance, vous allez le chercher dans l'espace de nommage de l'instance. Si vous ne le trouvez pas dans l'instance, vous allez remonter l'arbre d'héritage et le chercher dans l'espace de nommage de sa classe. C'est cette recherche d'attribut dans les espaces de nommage de l'instance et de la classe que l'on appelle arbre d'héritage.

Ouvrons maintenant un éditeur IDLE pour jouer avec ces notions d'instance, de classe et d'arbre d'héritage.

Commençons par créer une classe. Pour créer une classe, je vous rappelle qu'on utilise l'instruction `class` suivie du nom de la classe. Ici, je vais créer une classe qui s'appelle `Phrase`. Et ensuite, dans ma classe, je vais créer un attribut qui s'appelle `ma_phrase` et qui va référencer une chaîne de caractères qui vaut `"je fais un mooc sur python"`. J'ai créé ma classe, je la sauvegarde avec Ctrl-S, je l'évalue avec F5.

Maintenant, regardons cet objet `Phrase`. J'ai un objet `Phrase` ; on voit bien que cet objet a été créé ; et maintenant, à partir de ma classe `Phrase`, je vais pouvoir produire des instances ; je vous rappelle qu'une classe, c'est une usine à instances. Donc je vais définir une instance `p` qui va être une instance de ma `Phrase` ; donc pour produire l'instance, il faut que je mette des parenthèses après le nom de la classe, donc j'appelle ma classe comme une fonction. J'exécute et je regarde ce que référence `p` ; `p` est en fait également un objet. Je vois que ma classe et que mon instance sont toutes les deux des objets.

Je peux accéder aux espaces de nommage de ces objets avec un attribut particulier qui s'appelle `__dict__` ; donc je peux vous montrer ça avec `__dict__`, je vois l'espace de nommage mais je vous rappelle qu'en pratique nous n'utilisons pas ces méthodes spéciales directement à la main, nous avons toujours des fonctions *built-in* ou des opérateurs pour y accéder, et en fait, la fonction *built-in* qui me permet d'accéder à ce dictionnaire, c'est `vars`. C'est ce que j'utiliserai par la suite.

Regardons cet espace de nommage. Je vois dans mon espace de nommage un certain nombre d'attributs, l'attribut `module` qui référence `main` donc ça veut dire que ma classe est dans le module `main`, et je vois également un attribut `ma_phrase`, que j'ai défini dans la classe, qui référence la chaîne de caractères `"je fais un mooc sur python"`. Donc ça, c'est l'espace de nommage. Vous pouvez remarquer également que l'espace de nommage de ma classe a un objet un peu particulier qui s'appelle un **mappingproxy** ; vous devez savoir que la manière dont sont implémentés les espaces de nommage en Python sont vraiment des détails d'implémentation. Donc nous n'avons pas vraiment à nous soucier des caractéristiques de cet objet. Sachez simplement que le mappingproxy pour une classe est une sorte de dictionnaire qui ne peut être qu'en lecture seule, on ne peut pas le modifier directement. Cependant, une classe est malgré tout un objet mutable ; ça veut simplement dire qu'on ne peut pas modifier le dictionnaire à la main et en fait, ce choix a été fait pour des raisons de stabilité et de performance.

Maintenant regardons l'espace de nommage de mon instance. Je vais faire un `vars` de `p`, `p` étant mon instance, et je vois que mon espace de nommage est vide. Donc lorsque je crée une instance, l'instance est créée avec un espace de nommage vide mais je vous rappelle que l'on a une relation d'héritage entre l'instance et la classe ; ça veut dire que si je cherche un attribut à partir de mon instance et que je ne le trouve pas dans l'espace de nommage de l'instance, je vais aller le chercher dans l'espace de nommage de la classe. Regardons cela. Je vais faire un `p.ma_phrase` alors, je recommence, voilà ; et je vais donc chercher l'attribut `ma_phrase` dans mon instance. Or, on a vu que l'espace de nommage de mon instance était vide. Pourtant, j'arrive à y accéder. En fait, je cherche l'attribut dans l'instance, je remonte l'arbre d'héritage, je le trouve dans la classe. Et donc si je regarde si j'ai bien `ma_phrase` directement dans ma classe, évidemment, je l'ai ; on l'a vu dans l'espace de nommage et on l'a défini à la main. Donc ici, il n'y a aucune surprise.

Les classes et les instances sont des objets mutables. Et la résolution des attributs le long de l'arbre d'héritage est faite de manière dynamique en fonction de l'état des espaces de nommage au moment où on fait la résolution de l'attribut. Regardons un exemple. Je vais définir dans ma classe `Phrase` directement ici, je vais définir un nouvel attribut `mots` qui est égal à l'attribut `ma_phrase.split`. En fait, `ma_phrase.split` va prendre la chaîne de caractères, va la découper en mots et l'attribut `mots` dans la classe `Phrase` va simplement référencer cette liste. Exécutons cela et regardons maintenant la valeur de cet attribut `mots`. On voit qu'il s'agit effectivement d'une liste. Maintenant, essayons de chercher cet attribut `mots` dans l'instance ; je vous rappelle que l'espace de nommage de mon instance est vide ; je n'ai donc aucun attribut ; mais cependant, je peux quand même accéder à cet attribut `mots` qui a été rajouté dans la classe après la création de l'objet instance. Regardons cela. Je vois effectivement que je peux accéder à cet attribut `mots` depuis mon instance.

Maintenant, si je vérifie mes espaces de nommage dans ma classe, et dans mon instance, je vois bien que dans ma classe, j'ai bien un attribut `ma_phrase` qui référence la chaîne de caractères `"je fais un mooc sur python"` et que j'ai un attribut `mots` qui référence une liste `['je', 'fais', 'un', 'mooc', 'sur', 'python']`. Et de nouveau, si je regarde l'espace de nommage de mon instance, il est bien vide ; ça confirme bien que j'ai bien cette résolution d'attribut qui est faite de manière dynamique le long de l'arbre d'héritage.

Pour résumer ce que nous avons vu jusqu'à maintenant, les classes et les instances sont toutes les deux des objets, des objets mutables, qui ont leur propre espace de nommage et qui ont une relation d'héritage ; on recherche les attributs de l'instance, on remonte dans la classe. Cependant, il nous manque un mécanisme majeur pour faire de vraies classes. Lorsque vous définissez une classe, vous définissez en particulier des comportements dont vont hériter vos instances. Or, pour l'instant, nous n'avons défini aucun comportement, nous avons uniquement un seul attribut. Alors, comment est-ce que l'on implémente des comportements dans les classes ? En fait, on implémente ça par l'intermédiaire de **méthodes**. En fait, les **méthodes**, ce sont simplement des fonctions que l'on définit dans les classes. Et ces fonctions ont une caractéristique particulière, c'est qu'elles sont capables de travailler sur les attributs de l'instance. Regardons cela.

Je vais revenir sur ma classe, je vais prendre ma chaîne de caractères et je vais simplement définir une variable `s` qui est égale à cette chaîne de caractères. Ensuite, dans ma classe, je vais définir une méthode. Comment je définis une méthode ? Comme une fonction. J'utilise l'instruction `def` et ensuite je vais avoir un nom de fonction que je vais appeler `initia` pour initialisation, qui prend un argument `self` et qui prend un argument `ma_phrase`. Et ensuite, dans ma méthode, je vais définir `self.ma_phrase = ma_phrase`.

Regardons ce que fait exactement cette fonction, que l'on appelle une méthode quand elle est définie dans une classe. J'évalue ce code. Alors maintenant, qu'est-ce que c'est exactement, cette méthode ? Vous remarquez que cette méthode prend deux arguments, un argument `self`, un argument `ma_phrase`. Et qu'ensuite, je fais un `self.ma_phrase = ma_phrase`. En fait, lorsque vous appelez une méthode sur une instance, la référence de l'instance sur laquelle vous appelez cette méthode va être automatiquement passée comme premier argument. Donc ma variable `self` va référencer mon instance. Et ensuite, à ma méthode, je peux lui passer d'autres arguments comme par exemple `ma_phrase`. Maintenant, comme `self` est une référence de mon instance, lorsque ma méthode va s'exécuter, `self.ma_phrase` va dire: crée un attribut `ma_phrase` dans mon instance et fais-lui référencer l'objet qui est passé en deuxième argument donc, probablement, une chaîne de caractères dans ce cas-là. Regardons maintenant l'évaluation de ce code.

Maintenant, je vais définir une instance de `Phrase` ; et je vais appeler la méthode sur mon instance. Donc je vais faire `initia` de et je vais lui passer une phrase qui est ma chaîne de caractères `s` que j'ai définie juste ici. Voilà, je l'ai définie ici pour éviter d'avoir besoin de la retaper. J'exécute ma méthode. Maintenant, regardons ce qu'il s'est passé sur mon instance. Regardons maintenant l'espace de nommage de mon instance. Je vous rappelle que, après l'avoir créée, mon instance est totalement vide. Et maintenant, j'ai un attribut `ma_phrase` qui est: `"je fais un mooc sur python"`. Donc nous voyons bien que l'appel de cette méthode `initia` a permis de créer un attribut `ma_phrase` dans mon instance qui référence l'argument que j'ai passé à ma méthode `initia`.

Maintenant, on peut se demander comment est-ce que Python fait pour passer automatiquement l'instance ? En fait, c'est un mécanisme défini par Python qui s'appelle un mécanisme de **fonction bound**. Regardons ce que cela veut dire. Sur `Phrase`, vous avez un attribut qui s'appelle `initia` qui se trouve être en fait une fonction tout à fait classique. C'est une fonction qu'on a définie avec `def` qui est une fonction classique. Par contre, si j'appelle `initia` sur mon instance, nous allons voir qu'en fait c'est un autre type d'objet qui s'appelle un objet **bound**. Ça veut dire quoi, un objet bound ? Ça veut dire que c'est une fonction qui est liée à l'instance et lors de l'appel, Python va automatiquement passer l'instance comme premier argument comme je l'ai expliqué. Donc c'est le fait qu'on appelle cette fonction sur l'instance qui crée cet objet particulier et qui indique à Python qu'on doit lui passer l'instance comme premier argument. Donc en fait, lorsque vous faites un `p.initia(s)`, c'est totalement équivalent à faire un `Phrase.initia(p, s)`. En fait, Python va faire automatiquement cette conversion pour vous.

Dans cette vidéo, nous avons vu les notions de **classe** et d'**instance** ; nous avons vu que les classes et les instances sont des objets mutables, qui ont leur propre espace de nommage mais qui ont surtout une relation d'**héritage**. Nous avons également vu la notion de **méthode bound** qui permet à Python de passer automatiquement l'instance lorsqu'on appelle une méthode sur une instance.

À bientôt !


# W6-S2 Méthodes spéciales

Nous avons vu dans la précédente vidéo que nous pouvions définir des **méthodes** sur les **classes**. C'est quelque chose de tout à fait classique, les classes définissent en général un certain nombre de méthodes que l'on utilise pour manipuler les attributs des instances. Cependant, je vous avais également expliqué que, en Python, une caractéristique des classes, c'est qu'on peut créer nos objets qui se manipulent exactement comme des types *built-in*. Regardons une illustration de ça.

Vous pouvez tout à fait créer une classe `Phrase` que vous allez initialiser comme vous initialiseriez, par exemple, une liste, directement à la construction de l'instance. Vous pourriez également obtenir le nombre de mots directement avec la fonction *built-in* `len`, faire un test d'appartenance directement avec l'instruction `in`, accéder par exemple au troisième mot avec la notation crochets comme on le ferait avec une liste, faire un print directement sur votre instance pour afficher par exemple la liste des mots affichés en colonne, ou alors, si vous avez deux objets `Phrase`, pouvoir les concaténer simplement avec une addition. Toutes ces opérations peuvent être implémentées sur votre propre classe `Phrase`. La manière d'implémenter cela en Python est par l'intermédiaire de ce que l'on appelle des **méthodes spéciales**.

Les **méthodes spéciales** commencent toutes par un double underscore et finissent toutes par un double underscore, et sont appelées automatiquement lorsque l'on utilise par exemple une fonction *built-in*, un opérateur comme une addition ou alors une instruction comme le test d'appartenance avec `in`. Notamment, le test d'appartenance correspond à la méthode qui s'écrit `__contains__`. Dans cette vidéo, nous allons vous montrer comment vous pouvez exploiter ces méthodes spéciales pour implémenter, pour votre propre objet `Phrase`, des comportements qui soient des comportements exactement les mêmes qu'avec les objets *built-in*.

Reprenons la classe `Phrase` que nous avons définie dans la précédente vidéo. Vous pouvez mettre la vidéo en pause quelques instants pour avoir le temps de la taper dans votre éditeur IDLE. Maintenant que nous avons notre classe `Phrase` avec la méthode `initia`, définissons une deuxième méthode, une méthode que je vais appeler `nb_lettres` qui va prendre `self` ; je vous rappelle que ma méthode prend obligatoirement comme premier argument un argument qui va référencer mon instance qu'on nomme conventionnellement `self` ; et qui va simplement faire un `return len(self.ma_phrase)` ; donc ça va juste retourner le nombre de caractères que j'ai dans ma chaîne de caractères `ma_phrase`.

Donc maintenant que j'ai fait ça, j'aimerais commencer à implémenter le premier comportement que l'on implémente pour toutes nos classes qui est l'initialisation de notre instance. Donc regardons comment cela fonctionne. Jusqu'à maintenant, lorsque j'évaluais ma `Phrase` et que je voulais initialiser mon instance, j'avais créé une instance de `Phrase` et ensuite, je devais appeler la méthode `initia` et lui passer une chaîne de caractères. On voit bien que c'est un comportement qui est très peu commode puisque c'est tout à fait naturel lorsque l'on crée une instance, que mon instance puisse être initialisée avec un certain nombre d'attributs déjà prédéfinis. Donc la manière de le faire, en Python, c'est de définir une **méthode spéciale** qui s'appelle `__init__`. Tout simplement. Je n'ai rien à changer à ma méthode `initia`, et cette méthode `__init__` va être appelée automatiquement lorsque je crée mon instance. Regardons cela. Je le sauvegarde avec Ctrl-S, je l'évalue avec F5.

Et maintenant, je vais faire un `p=Phrase("je fais un mooc sur python")`. J'évalue ce code et je vois que maintenant ma phrase `p` contient dès maintenant un attribut `ma_phrase` qui est initialisé à `"je fais un mooc sur python"`. Donc mon initialisateur, qu'on appelle parfois par abus de langage un constructeur mais qui n'est pas vraiment un constructeur, qui est juste quelque chose qui initialise mon instance une fois qu'elle a été créée, me permet de créer des attributs automatiquement avec une certaine valeur par défaut lorsque je crée mon instance. Donc ça, c'est le premier comportement que j'ai implémenté avec cette méthode spéciale `__init__`.

Maintenant, je me dis que j'aimerais bien par exemple afficher le nombre de mots que j'ai dans ma phrase. Pour faire ça, il faudrait d'abord que j'implémente dans mon initialiseur un attribut qui va par exemple contenir la liste des mots. Je vais appeler ça `self.mots` qui est égal à `ma_phrase.split`. En fait, lorsque je vais créer mon instance, je vais avoir un attribut `ma_phrase` dans mon instance qui référence la chaîne de caractères, et je vais avoir un attribut `mots` qui va référencer une liste qui contient chaque mot. Ensuite, si je veux obtenir le nombre de mots avec la fonction *built-in* `len` exactement comme je le ferais avec un type *built-in*, donc en faisant un `len(p)`, je peux implémenter cela en définissant une méthode spéciale qui va s'appeler `__len__`, et je lui passe évidemment `self` puisque toutes mes méthodes doivent prendre obligatoirement `self` comme premier argument. Et que va faire ma méthode `__len__` ? Ma méthode `__len__`, elle est supposée retourner un entier qui va correspondre au nombre de mots. Donc je vais simplement faire un `len(self.mots)`.

Regardons maintenant l'exécution de ce code. Je l'évalue avec F5. Je retourne dans mon interpréteur. J'initialise mon instance avec `p`. Et maintenant, je peux directement faire un `len(p)` et je vois que j'ai 6 mots dans ma phrase. Donc je vois que je commence à construire, avec les méthodes spéciales, une classe qui produit des instances qui se comportent comme des types *built-in*. Maintenant, un autre comportement que je pourrais vouloir implémenter, c'est par exemple le test d'appartenance. Ça serait extrêmement pratique de pouvoir dire est-ce que, par exemple, le mot 'mooc' est dans mon instance ? Donc essayons de faire ça directement ; qu'est-ce qu'il va se passer ? Évidemment, j'ai une exception puisqu'on va me dire que ma phrase ne peut pas être itérée, donc c'est le message d'erreur qui est dans ce cas-là pas tout à fait explicite, qui veut simplement dire que je ne peux pas parcourir ma phrase pour être capable de trouver si `'mooc'`, dans ce cas-là, j'avais écrit `'moon'`, est dans mon instance.

Implémentons ce test d'appartenance. Là encore, comme je l'ai expliqué en introduction, j'ai une méthode spéciale dédiée à ça qui s'appelle `__contains__`. Donc je vais définir `__contains__` qui prend comme premier argument `self`, toujours mon instance, et comme deuxième argument le mot sur lequel je veux faire le test. Et que va faire `__contains__` ? `__contains__` doit me retourner un booléen qui vaut Vrai si mot est dans ma phrase, ou Faux s'il n'est pas dedans. Et donc pour ça, je vais simplement faire un test d'appartenance de `mot` dans `self.mots`. J'exécute ce code. Je le sauvegarde avec Ctrl-S, je l'évalue avec F5. Et maintenant, je vais me recréer une phrase. Regardons quel est le nombre de mots dans ma phrase. C'est 6. Et est-ce que `'moon'` est dans `p` ? Non. Est-ce que `'mooc'` est dans `p` ? Oui. Donc on voit que je viens d'implémenter le test d'appartenance exactement comme je le ferais avec un type *built-in* directement sur ma classe.

Maintenant, la dernière méthode que je voudrais vous montrer, qui est une méthode très courante, qu'on implémente très souvent pour les classes, c'est la méthode qui permet de supporter la fonction *built-in* `print`. Que se passe-t-il si je fais un `print(p)` ? Je vois que je vais voir l'objet, l'adresse de l'objet, ce qui a assez peu d'intérêt. Or, si je veux avoir une manière d'afficher ce que contient mon instance, qui peut être utile en cours d'exécution de mon programme mais également si je veux débugger mon programme, je dois implémenter une méthode qui s'appelle `__str__`, qui va prendre, ça ne vous surprend plus maintenant, comme premier argument `self` et qui doit retourner une chaîne de caractères. Donc je vais faire un `return '\n'.join(self.mots)`. Donc en fait, que va me retourner ma méthode `__str__` ? Simplement les mots affichés sur une colonne. J'évalue cela avec F5. Je recrée ma phrase. Et maintenant regardons est-ce que j'ai bien toujours le nombre de mots ? Oui. Est-ce que `'mooc'` est dans ma phrase ? Oui. Et que contient ma phrase ? Je fais un `print(p)` et je vois les mots s'afficher sur une colonne.

Nous venons de voir les **méthodes spéciales** et nous avons vu que ces méthodes spéciales permettent de créer vos propres classes qui se comportent comme des types *built-in*. C'est donc extrêmement souple, extrêmement puissant. Nous avons vu dans cette vidéo juste un petit sous-ensemble des méthodes spéciales qui existent, mais il existe autour d'une centaine de méthodes spéciales et vous en verrez un grand nombre dans les compléments. Il faut savoir également que ces méthodes spéciales peuvent constituer ce que l'on appelle un protocole, notamment le protocole d'itération, ou le protocole de context manager que nous aborderons dans une prochaine vidéo.

À bientôt !


# W6-S3 Héritage


Dans une précédente vidéo, nous avons vu que nous avions une relation d'**héritage** entre l'**instance** et la **classe** qui crée cette instance. C'est-à-dire que lorsque l'on cherche un attribut dans une instance, si on ne le trouve pas dans l'espace de nommage de l'instance, on remonte l'arbre d'héritage et on arrive dans la classe. Cette notion d'arbre d'héritage s'étend également aux classes. Les classes peuvent hériter d'autres classes et on peut donc avoir un arbre d'héritage qui va partir des instances, remonter aux classes, et remonter aux classes dont héritent ces classes. Regardons un exemple.

Ici, à gauche, je vous représente les objets qui sont créés, et à droite, du pseudo-code. Imaginons que l'on crée deux classes `C1` et `C2`. Et que maintenant, on crée une troisième classe `C`, qui hérite de `C1` et `C2`. Cette notion d'**héritage** est représentée par des parenthèses mises après le nom de la classe, et dans ces parenthèses, on va mettre la liste des classes dont on hérite. En fait, on va appeler la classe `C` une classe, et les classes `C1` et `C2` les super-classes de `C`. On peut également dire en regardant le problème dans l'autre sens, que `C1` et `C2` sont des classes, et que `C` est une sous-classe de `C1` et `C2`. Ensuite, si on crée des instances, `I1` et `I2`, ces instances `I1` et `I2` sont des objets qui vont hériter de la classe. Et en fait, on remarque maintenant que les instances, la classe et les super-classes forment ce que l'on appelle un arbre d'héritage. Donc, lorsque je cherche un attribut dans l'instance, si je ne le trouve pas dans l'espace de nommage de l'instance, je remonte dans sa classe ; si je ne le trouve pas dans la classe, je remonte dans les super-classes. Les super-classes étant des classes tout à fait comme les autres, elles peuvent elles-mêmes hériter d'autres classes et je peux donc avoir un arbre d'héritage qui est très grand.

Ouvrons maintenant un éditeur IDLE pour commencer à jouer avec cette notion d'héritage.

Je vous propose de reprendre l'exemple que nous avions dans la précédente vidéo, la vidéo sur les **méthodes spéciales**, et de commencer à partir de là. Mettez la vidéo en pause pour recopier ce code et nous nous retrouvons dans quelques instants.

Vous remarquez que par rapport à l'exemple précédent, j'ai rajouté une chaîne de caractères `s` qui écrit: `"Je fais un MOOC sur Python"` avec quelques lettres majuscules, nous allons voir dans quelques instants pourquoi cela est important. Maintenant, j'aimerais bien créer une classe qui ait les mêmes caractéristiques que `Phrase`, mais qui me permette de faire un test d'appartenance qui ne prend pas en compte la casse, c'est-à-dire qui ne prend pas en compte le fait que j'ai des lettres majuscules ou minuscules. Lorsque l'on dit que j'aimerais avoir une classe qui se comporte comme une autre classe, c'est exactement ce que l'on appelle une **relation d'héritage**. Donc en fait, la bonne manière de définir une nouvelle classe qui se comporte comme ma `Phrase` mais qui modifie un peu son comportement, c'est d'hériter de `Phrase`. Regardons cela.

Je vais créer une nouvelle classe que je vais appeler `PhraseSansCasse`, et qui va hériter de `Phrase`. Comment est-ce que je montre qu'une classe hérite d'une autre classe ? Simplement, je le mets entre parenthèses au moment de la déclaration de ma classe. Donc là, je définis une classe toute simple ; je ne lui définis pas encore de comportement, je vais le faire dans quelques instants. Et je peux maintenant exécuter ce code. Maintenant, définissons une instance de ma classe `PhraseSansCasse`, donc je vais l'appeler `p_no`, et je vais écrire `PhraseSansCasse(s)`, `s` étant ma chaîne de caractères qui représente `"Je fais un MOOC sur Python"`. Exécutons cela.

Et donc maintenant, vérifions est-ce que `p_no` est bien une instance de `PhraseSansCasse` ? Je peux le vérifier avec la fonction *built-in* `isinstance`. Donc je vais vérifier est-ce que `p_no` est bien une instance de `Phrase` ? Je remarque que c'est une instance de `Phrase` et est-ce que `p_no` est également une instance de `PhraseSansCasse` ? Je remarque que c'est également une instance de `PhraseSansCasse`. En fait, la fonction `isinstance` vous permet de trouver si votre objet est une instance directement d'une classe ou une instance le long de l'arbre d'héritage, c'est-à-dire que je suis une instance d'une classe ou des super-classes de la classe qui m'a instanciée.

Donc maintenant, regardons exactement cet objet `p_no` ; on voit que cet objet a été créé directement par la classe `PhraseSansCasse`. Évidemment, cettre `PhraseSansCasse` ne définissant aucune méthode, pour l'instant, elle ne sert absolument à rien. Donc maintenant, je vais commencer à définir des méthodes sur cette classe. Regardons cela. Je vais ajouter dans `PhraseSansCasse` une nouvelle méthode `__init__` qui va prendre évidemment `self` et l'attribut qu'on va utiliser pour initialiser, donc `ma_phrase` ; et qui va définir `self.mots_lower` égale, et là, je vais prendre un ensemble de tous les mots en minuscule pour les mots dans `self.mots`. Donc en fait, je crée un ensemble qui contient tous les mots en minuscule pour tous les mots qui sont pris dans la liste des mots qui a été calculée. Seulement, vous remarquez ici que j'ai une méthode `__init__` qui est définie dans `Phrase`, et j'ai une méthode `__init__` qui est définie dans `PhraseSansCasse`. Lorsque vous héritez d'une classe, vous héritez de toutes ses méthodes mais si vous redéfinissez les méthodes, on appelle ça **surcharger** une méthode ; donc ici, dans `PhraseSansCasse`, j'ai surchargé la méthode `__init__` ; la méthode `__init__` de `Phrase` ne sera pas appelée automatiquement. Le seul moyen de l'appeler automatiquement, c'est de le faire de manière explicite ; et lorsque j'ai un initialisateur, une méthode `__init__`, en général, c'est ce que je veux faire.

Regardons cela. Je vais dire: dans la classe `Phrase`, je vais appeler explicitement la méthode `__init__` en lui passant les arguments `self`, `ma_phrase`. J'ai donc forcé l'appel de la méthode `__init__` de `Phrase` avant de faire mon initialisation qui est spécifique à ma classe `PhraseSansCasse`. Maintenant, évaluons ce code ; je le sauvegarde avec Ctrl-S, je l'évalue avec F5. Et maintenant, regardons l'initialisation de mon instance. Je vais reprendre une instance `p_no = PhraseSansCasse(s)` et si je regarde mon instance, est-ce que maintenant mon instance a bien un attribut `mots_lower` ? Regardons cela. Oui. Et j'ai bien la liste des mots mis en minuscule.

Je vous rappelle que le but de ma classe `PhraseSansCasse`, c'est de faire un test d'appartenance sans prendre en compte la casse dans le test d'appartenance ; je vais le faire maintenant de la manière suivante. Je vais définir une deuxième méthode `__contains__` ; donc je vais surcharger ma méthode `__contains__` que j'avais définie dans ma super-classe ; je vais donc définir `__contains__(self, mot)` et ici, je vais simplement faire un `return` de `mot.lower() in self.mots_lower` qui est donc ma fameuse liste que j'ai créée dans ma méthode `__init__` de `PhraseSansCasse`. J'évalue ce code.

Donc remontons un petit peu pour n'avoir plus que `PhraseSansCasse`. J'évalue ce code. Je vais recréer une instance. Et maintenant, est-ce que je peux tester si est-ce que `"Mooc"` est dans mon instance `p_no` ? Je remarque qu'il est bien dedans ; pourtant, la capitalisation était différente entre le `"Mooc"` écrit M majuscule et le `"MOOC"` écrit en majuscule ; mais là, ça a bien fonctionné. Vous remarquez également que dans ma méthode `__contains__`, je n'ai pas rappelé la méthode `__contains__` de `Phrase`, simplement parce que dans ce contexte, ça n'avait pas de sens d'appeler la méthode de la super-classe.

Pour finir, j'aimerais vous montrer maintenant le comportement final de `Phrase` et de `PhraseSansCasse`. Je peux définir une instance de `Phrase` que je vais appeler `p`, qui va prendre la chaîne de caractères `s` et je vais définir mon instance, qui a déjà été définie, `p_no`, qui prend la même phrase. Donc maintenant, je peux tester est-ce que `"mooc"` est dans `p` ? `p` est une instance de `Phrase`, on prend en compte la casse, la réponse est non. Est-ce que `"mooc"` est dans `p_no` ? Je ne prends pas en compte la capitalisation. Alors, j'ai écrit `"moon"`, je vais reprendre. `"moon"` évidemment n'est pas dedans. Est-ce que `"mooc"` écrit en minuscule est dans ma phrase sans capitalisation ? Oui.

J'ai évidemment des méthodes spéciales mais j'ai également des méthodes normales, donc je peux tout à fait appeler `p.nb_lettres()` et vérifier combien j'ai de lettres dans ma phrase. Et je peux également faire `p_no.nb_lettres()`. Je peux également appeler cette méthode, cette méthode n'est pas définie dans `PhraseSansCasse` mais elle est définie dans la super-classe donc mon instance peut accéder à cette méthode traditionnelle, cette méthode normale, directement depuis l'instance de `PhraseSansCasse`.

Nous avons vu dans cette vidéo la notion d'**héritage** et d'**arbre d'héritage**. En fait, nous savons que l'instance va hériter de sa classe, et que la classe va hériter de ses super-classes et que les super-classes peuvent elles-mêmes hériter de leurs propres super-classes. Cette notion d'arbre d'héritage signifie simplement que, lorsque je cherche un attribut n'importe où le long de l'arbre d'héritage, si je ne le trouve pas dans l'objet dans lequel je le cherche, dans l'espace de nommage de l'objet dans lequel je le cherche, je vais remonter l'arbre d'héritage jusqu'à le trouver. Seulement nous avons vu en introduction que nous pouvions avoir de l'héritage multiple, c'est-à-dire qu'une classe pouvait hériter de plusieurs classes. Et dans ce cas-là, se pose la question de savoir dans quel ordre je vais faire la recherche de mes attributs dans mes super-classes. C'est ce qu'on appelle la technique de la **Method Resolution Order** ou l'ordre de résolution des attributs. C'est un sujet que nous aborderons dans une prochaine vidéo.

À bientôt !


# W6-S4 Héritage multiple et ordre de résolution des attributs

Nous avons vu dans une précédente vidéo la relation d'**héritage** entre les classes et les super-classes. D'ailleurs, lorsque vous cherchez un attribut, on appelle ça la recherche d'attribut mais également la **résolution d'attribut**, votre mécanisme de recherche va remonter l'arbre d'héritage. Nous savons également que Python supporte ce que l'on appelle l'**héritage multiple**. Ça veut dire qu'une classe peut hériter de plusieurs classes. Lorsque l'héritage est simple, la recherche ou la résolution des attributs est simple, on remonte simplement l'arbre d'héritage qui est juste constitué d'une seule ligne. Lorsque l'héritage est multiple, dans ce cas-là, l'arbre d'héritage va être plus complexe ; ça va être un graphe acyclique. Il faut donc, dans ce cas, définir une **méthode de résolution des attributs** qui va définir un parcours spécifique dans notre graphe d'héritage. C'est le sujet de cette vidéo ; nous allons expliquer les méthodes de résolution d'attribut qu'on appelle également **MRO**, pour *Method Resolution Order* en anglais.

Ouvrons maintenant un interpréteur Python pour regarder cette notion de résolution d'attribut.

Commençons par créer une classe `C` toute simple. Donc je vais définir une classe `C` qui ne fait rien. Ici, mon objectif est uniquement d'illustrer le mécanisme de résolution d'attribut et non pas le comportement des classes. Ensuite, je vais définir une instance de ma classe `C`, `c`. Alors, comment est-ce que Python fait pour savoir quelle est la classe qui a créé mon instance, et quelles sont les super-classes de ma classe ? En fait, j'ai des attributs spéciaux. Sur une instance, j'ai un attribut qui s'appelle `__class__` qui retourne une référence vers l'objet classe qui a créé cette instance. Lorsque l'on parcourt l'arbre d'héritage, Python va en premier accéder à cet attribut `__class__` de l'instance pour arriver jusqu'à la classe qui a créé cette instance. Et ensuite, les classes ont un attribut qui s'appelle `__bases__` qui est un tuple qui contient toutes les super-classes de la classe. Regardons quelle est la super-classe de `C`. On voit que l'on a un objet, on a quelque chose, on a une super-classe de `C`, ça s'appelle `object`. Alors, ça, c'est curieux parce qu'on a défini notre classe `C` sans aucune super-classe. En fait, en Python, lorsque vous créez une classe sans aucune super-classe, par défaut, votre classe héritera d'une classe particulière qui s'appelle `object`. `object` est la super-classe de toutes les classes en Python. Alors, pourquoi est-ce qu'on a besoin d'avoir cette super-classe qui est au-dessus de toutes les classes en Python ? C'est parce qu'en fait, vous avez remarqué que, quand vous avez une classe ou une instance, vous pouvez tout à fait faire un `print(c)`. Quelque chose s'affiche. Je peux faire un `print` de ma classe ; quelque chose va s'afficher également. Ça veut donc dire que la méthode `print` est supportée par ma classe pourtant, je n'ai défini aucune méthode à l'intérieur. Et bien, en fait, dans object, vous avez un certain nombre de comportements par défaut qui sont implémentés et donc, lorsque ces comportements ne sont pas surchargés dans vos classes, l'implémentation de `object` va être celle qui va être utilisée.

Donc maintenant, regardons un attribut sur ma classe qui s'appelle `mro()`. Enfin pardon, pas un attribut, une méthode sur ma classe qui s'appelle `mro()`. Là encore, je n'ai pas défini de méthode `mro` sur ma classe ; on se doute que cette méthode est définie quelque part le long de l'arbre d'héritage donc dans `object`. J'exécute et je vois que `mro` me retourne `__main__.C` et `object`. `mro` va me retourner une liste qui va m'indiquer dans quel ordre je dois résoudre mes attributs lorsque j'arrive dans ma classe. Je vais d'abord le chercher dans l'espace de nommage de `C` ; si je ne le trouve pas, je vais chercher mon attribut dans l'espace de nommage de `object`, donc c'est le chemin que je vais suivre lors de la résolution de mes attributs.

Maintenant, regardons un cas un peu plus compliqué. Je vais créer une classe `SuperA` qui ne fait rien, et une classe `SuperB` qui ne fait rien également, et je vais définir une classe `C` qui hérite de `SuperA` et de `SuperB`. Et ma classe `C` ne fait rien également. Maintenant, regardons l'ordre de résolution des attributs. Donc je vais prendre ma classe `C` et je vais appeler la méthode `mro`. Regardons cela. Je vois que l'ordre de résolution des attributs c'est ma classe `C`, ensuite ma super-classe `A`, ensuite ma super-classe `B` et ensuite `object`.

Mais maintenant, modifions un tout petit peu ma classe `C`, et au lieu de faire `SuperA, SuperB`, je vais faire un `SuperB, SuperA`. Exécutons cette classe et maintenant, regardons la `mro`. Je vois que maintenant, c'est classe `C`, ensuite, c'est `SuperB`, ensuite, c'est `SuperA` et ensuite, c'est `object`. Ça veut donc dire que l'ordre de résolution des attributs va dépendre de la manière, de l'ordre dans lequel vous définissez les super-classes d'une classe. C'est donc très important, lorsque l'on fait de l'héritage multiple, de prendre conscience de ce phénomène et de prendre en compte cela lorsque l'on définit les super-classes d'une classe.

Regardons maintenant l'algorithme utilisé par Python pour trouver ce parcours de recherche des attributs. Prenons un exemple. Je vais définir une classe `A` qui hérite de `object`, vous savez qu'une classe qui ne définit aucune super-classe hérite automatiquement de `object`, puis une classe `B` qui hérite de `A`, et puis ensuite, une classe `C` qui hérite de `A`. Pour finir, je vais définir une classe `D` qui hérite de `B` et de `C`. Ici, on a typiquement ce qu'on appelle un diagramme en diamant, qui est un diagramme particulier. Et donc regardons maintenant comment Python va définir la recherche des attributs.

On utilise l'algorithme suivant. On va parcourir les classes de bas en haut et ensuite de gauche à droite. Donc dans ce cas-là, on va parcourir `D`, `B`, `A`, `object`, puis ensuite on redescend au branchement et on va parcourir `C`, `A`, `object`. Et ensuite, si jamais on a des classes qui sont dupliquées, on enlève toutes les classes dupliquées sauf la dernière. Donc j'enlève `A` qui est présente deux fois, donc je l'enlève, sauf la dernière, et j'ai `object` qui est également présent deux fois, et j'enlève `object` sauf le dernier. Et donc si on regarde effectivement quelle est la mro calculée automatiquement par Python, c'est ce que je viens d'écrire, c'est la classe `D`, la classe `B`, la classe `C`, la classe `A` et finalement `object`.

En fait, l'algorithme réel utilisé par Python est un tout petit peu plus compliqué que ce que j'ai montré, mais ça vous donne une bonne approximation du fonctionnement de cet algorithme de recherche des attributs en Python.

Nous venons de voir la technique de résolution des attributs en Python et notamment, la méthode `mro` qui permet de définir la liste que l'on va parcourir lorsque l'on recherche des attributs. C'est très important de prendre conscience qu'on a une technique particulière de recherche des attributs en cas d'héritage multiple. Imaginez que vous ayez une classe qui hérite de deux super-classes, et que vous appeliez une méthode qui soit définie dans vos deux super-classes, si vous ne savez pas l'ordre de résolution des attributs, vous ne connaîtrez pas la méthode qui sera appelée dans l'une ou l'autre de vos super-classes. C'est donc important de comprendre cet algorithme de résolution.

À bientôt !

# W6-S5 Variables et attributs

Nous avons vu dans de précédentes vidéos la notion de **portée de variable**, notamment dans le contexte des fonctions et des modules. Nous avons également vu la notion de **recherche d'attribut** le long des **arbres d'héritage**. Tous ces mécanismes servent à savoir dans quel espace de nommage chercher nos variables ou nos attributs.

Il est probable qu'à ce moment du mooc vous n'ayez pas les idées très claires sur comment ces différents mécanismes interagissent. Le but de cette vidéo est de faire toute la lumière sur les mécanismes de référencement et d'affectation des variables et des attributs quel que soit le contexte.

Commençons par faire une distinction entre ces notions de **variable** et d'**attribut**. On dit que l'on a une **variable** lorsqu'un nom est référencé ou affecté directement. Et on dit que l'on a un **attribut** lorsque ce nom est référencé ou affecté en utilisant la notation objet point. Alors, pourquoi est-ce que je fais cette distinction entre les variables et les attributs ? C'est que la recherche de ces noms utilise des mécanismes complètement différents suivant que j'ai une variable ou suivant que j'ai un attribut. Lorsque j'ai une variable, j'utilise un mécanisme qui s'appelle la **liaison lexicale** qui est un mécanisme statique qui est défini à l'écriture de notre programme. Et lorsque j'ai un attribut, la recherche de ce nom va être faite en utilisant un mécanisme que l'on appelle la **résolution d'attribut**. Il est important de comprendre que ces mécanismes de recherche ont pour but de définir dans quel espace de nommage ce nom a été défini.

Maintenant, regardons plus spécifiquement le cas des attributs qui est un cas plus simple que le cas des variables. Lorsque je définis un attribut `x`, `objet.x= 10`, on dit définir, on peut également dire affecter, je vais dire que ce nom `x` doit être défini dans l'espace de nommage de mon objet. Et donc ce nom `x` va référencer l'entier 10 dans l'espace de nommage de `objet`. Lorsque je référence mon attribut `x`, je veux dire que je vais chercher mon attribut dans l'espace de nommage de `objet`. Mais là, j'ai deux cas différents suivant la nature de `objet`. Si jamais `objet` est un module, une référence du nom `x` dans l'objet veut dire en fait que je vais chercher `x` dans l'espace des variables globales de mon module, donc dans l'espace de nommage du module. Si maintenant `objet` est une classe ou une instance, je vais chercher mon attribut `x` le long de l'arbre d'héritage.

On voit donc que j'ai deux mécanismes un tout petit peu différents ; pour le module, je cherche dans l'espace de nommage du module, pour les instances ou les classes, je cherche dans l'espace de nommage courant donc de mon objet, et si je ne le trouve pas, je remonte l'arbre d'héritage.

Donc on a fini le cas des attributs ; vous voyez que c'est un cas qui est relativement simple et que nous avons déjà largement détaillé lorsque nous avons parlé des classes et des modules. Maintenant, regardons dans la suite le cas spécifique des variables qui est un cas un petit peu particulier. Je dis qu'une variable est définie dans un bloc de code d'une fonction, d'une classe ou d'un module, lorsqu'elle est écrite directement dans le bloc de code de la fonction, de la classe ou du module, et dans ce cas-là, lorsqu'elle est définie dans ce bloc de code, on dit qu'elle devient **locale** à ce bloc de code.

J'insiste de nouveau sur ce point important ; les variables sont liées aux espaces de nommage statiquement en fonction de là où elles sont écrites au moment de l'écriture de notre programme avec un mécanisme qu'on appelle **liaison lexicale**. La seule exception est lorsque l'on déclare notre variable comme étant `global` ou `nonlocal`, on a déjà vu ce cas lorsqu'on a parlé des fonctions.

Ce mécanisme de définition n'est pas lié juste à l'opération d'affectation, `x = 1`. On a différentes manières de faire une définition, on dit également une **liaison**, d'une variable. `x = 1`, l'affectation explicite évidemment va lier `x` à l'objet `1`. Mais j'ai également une déclaration, par exemple, de paramètres dans une fonction. La variable `a`, définie comme paramètre de ma fonction `f`, est une variable locale, liée au bloc de code de ma fonction. Lorsque je définis un nom d'une classe, la classe `C`, ou le nom d'une fonction, la fonction `f`, j'ai également un mécanisme d'affectation, de liaison. `C` est un nom qui va référencer mon objet classe ; `f` est un nom qui va référencer mon objet fonction. Dans une boucle *for*, lorsque je fais `for i in objet`, `i` est une variable qui va référencer les objets retournés par la méthode `next` sur l'itérateur de l'objet. Et également, lorsque je fais un *import*, je vais définir un nom qui va référencer un objet, soit un objet module, soit dans le cas de `import times`, un objet fonction. Et j'ai également d'autres mécanismes, je ne vais pas tous les couvrir, qui permettent de faire une liaison entre un nom de variable et un objet.

Maintenant, regardons le cas du référencement. On a bien compris que une variable est liée avec différents mécanismes, donc on définit un nom qui est lié à un objet ; maintenant, lorsque je référence ma variable, c'est par exemple lorsque je fais `print(x)`, lorsque j'utilise cette variable. Maintenant, je veux savoir, cette variable `x`, je vais la prendre dans quel espace de nommage ? Pour cela, je vais utiliser la **règle LEGB** que nous avons déjà vue. Je vais chercher ma variable localement à la fonction ; si elle n'est pas définie localement, je remonte dans les fonctions englobantes ; ensuite, je vais dans le module et finalement, je la cherche dans le module `builtins`.

Seulement, lorsqu'on rajoute le cas des classes, il y a un cas particulier supplémentaire à prendre en compte. Le bloc de code des classes est systématiquement sauté lors de la résolution des attributs. En fait, le bloc de code des classes est très particulier. Une variable définie dans le bloc de code d'une classe n'est pas accessible en dehors de la classe mais elle n'est pas non plus accessible aux méthodes de la classe. En fait, ça peut paraître très étrange de prime abord, mais il faut comprendre que ce choix architectural a été fait pour éviter d'avoir une interaction bizarre entre le mécanisme de résolution d'attribut et le mécanisme de recherche des variables. Les classes et les instances sont naturellement construites pour rechercher des attributs le long des arbres d'héritage. C'est pour ça qu'on a ce mécanisme un petit peu extrême lorsqu'on définit des variables dans les classes.

Maintenant, regardons des exemples pour illustrer ces différents cas. Je vais définir un module *spam.py* qui définit une variable globale `a` qui vaut 1, une fonction `f` qui définit une variable locale `a` qui vaut 2. Et puis je définis une classe `C` qui définit une variable, dans le bloc de code de la classe, qui vaut 3, donc c'est une variable locale à la classe. Ensuite, j'appelle ma fonction et je crée une instance de la classe. La question est: que va m'afficher `print(a)` ?

Ici, vous savez que les variables définies dans les fonctions sont locales à la fonction, et que les variables définies dans les classes ne peuvent pas être vues en dehors de la classe ; donc en fait, on a la certitude que ce que va m'afficher `print(a)`, c'est la variable globale `a` et on va donc voir l'entier 1. En fait, si j'utilise ma **règle LEGB**, `a` n'est pas définie dans une fonction, elle n'est pas définie dans des fonctions englobantes, elle est définie globalement, c'est la variable `a` qui référence 1. Et donc effectivement, je vais voir apparaître l'entier 1.

Maintenant, prenons un deuxième cas. J'ai une variable `a`, dans mon module, une classe `C` qui définit une variable locale `a` qui vaut 2, et puis, dans ma classe, j'ai une fonction `f` qui va faire un `print(a)` et un `print(C.a)`. Maintenant, je crée une instance de ma classe et j'appelle ma fonction `f` sur mon instance. Qu'est-ce qu'il va s'afficher ?

Alors, regardons le premier `print(a)`. `a` est une variable que je recherche avec la règle LEGB ; est-ce que `a` est définie localement ? Non. Est-ce qu'elle est définie dans des fonctions englobantes ? Je n'ai pas de fonction englobante. Est-ce qu'elle est définie globalement ? Oui, elle vaut 1. Donc c'est la variable globale `a` qui actuellement référence l'entier 1. On voit que dans ce mécanisme de recherche des variables, j'ai sauté le bloc de code de la classe. Ensuite, je fais un `print(C.a)`. Là, je change de mécanisme. Maintenant, j'ai une résolution d'attribut. Quelle est la nature de `C` ? Est-ce que c'est un module ou est-ce que c'est une classe ? `C` est une classe, je vais donc le chercher le long de l'arbre d'héritage. Je regarde `C.a` ; est-ce que `a` est défini dans l'espace de nommage de ma classe ? Oui. C'est l'attribut `a` qui vaut 2 ; je vais donc référencer l'entier 2. Si `a` n'avait pas été défini dans ma classe, je serais remonté le long de l'arbre d'héritage dans les super-classes ; dans ce cas-là, en fait, je n'avais que `object` comme super-classe. Regardons le résultat ; `print(a)` m'affiche bien 1, et `print(C.a)` m'affiche bien 2. Donc on voit bien que les classes sont conçues pour qu'on accède à leurs attributs avec le mécanisme de résolution d'attribut, avec la notation `C` point quelque chose.

Regardons un dernier exemple. Je définis une variable globale `a`, une classe `A` qui définit une variable locale `a` qui vaut 2, et une classe `B` qui définit une fonction `f` qui fait `print(a)`. Je crée une instance de ma classe `B` et j'appelle `f` sur mon instance. Que va m'afficher le `print(a)` ? `a` est une variable, je la recherche donc avec la règle LEGB ; est-ce que `a` est définie localement à ma fonction ? Non. Je n'ai pas de fonction englobante ; je saute tous les blocs de code des classes ; est-ce que `a` est définie globalement ? Oui, c'est la variable `a` qui référence l'entier 1, je vais donc voir apparaître l'entier 1.

Nous avons donc vu les **mécanismes de recherche de variable et d'attribut** en Python, en prenant le cas général des modules, des fonctions et des classes. Il est important de comprendre que la recherche des variables et la recherche d'attributs utilisent des mécanismes complètement différents. La recherche des variables est faite avec un mécanisme statique, qui s'appelle la **liaison lexicale**, qui est déterminée au moment de l'écriture de votre programme, tandis que la recherche d'attributs est faite de manière dynamique en fonction de l'exécution de notre programme. Tous ces mécanismes servent à trouver des noms dans des espaces de nommage.

À bientôt !


# W6-S6 Conception d'itérateurs

Nous avons vu précédemment les notions d'**itérable** et d'**itérateur**. Je vous rappelle que les itérateurs permettent de parcourir les objets de manière simple et intuitive. Rappelez-vous exactement ces différences entre itérable et itérateur, donc c'est un rappel très rapide, c'est pourquoi je vais passer rapidement dessus ; si vous avez le moindre doute, n'hésitez pas à revenir à la vidéo qui introduisait ces notions d'itérable et d'itérateur.

Un **itérable**, c'est un objet qui a une méthode `__iter__` qui retourne un itérateur ; et un **itérateur**, c'est un objet qui a une méthode `__iter__` qui retourne lui-même, et une méthode `__next__` qui, à chaque fois qu'on l'appelle, va retourner un nouvel élément jusqu'à ce qu'il n'y ait plus d'élément, et quand il n'y a plus d'élément, j'ai une *exception* qui s'appelle `StopIteration`.


Ce mécanisme est extrêmement puissant et peut être exploité par n'importe quel mécanisme d'itération en Python, les *boucles for* et les *compréhensions*, les fonctions `map` et `filter`. Nous allons voir dans cette vidéo comment implémenter des itérateurs et des itérables pour vos propres objets.


Ouvrons maintenant un éditeur IDLE pour commencer à jouer avec ces conceptions d'**itérateurs**.

Je vais vous montrer trois manières différentes de concevoir un objet qui est soit un itérateur, soit un itérable. Reprenons un exemple de notre classe `Phrase` ; je vous laisse quelques instants pour avoir le temps de le taper ; nous nous retrouvons dans quelques secondes. Donc maintenant que vous avez tapé votre classe `Phrase`, avec une méthode `__init__` qui permet d'ajouter un attribut `ma_phrase` à votre instance, et également un attribut `mots` qui est la liste des mots, nous allons voir maintenant comment est-ce qu'on peut définir cet objet pour qu'il devienne un itérateur.

Nous avons vu, dans l'introduction, qu'un itérateur est un objet qui a deux méthodes. Commençons par faire de `Phrase` un itérateur, donc qui doit avoir une méthode `__iter__` qui va prendre comme argument `self`, évidemment, toutes mes méthodes prennent comme premier argument mon instance, et qui va se retourner soi-même. Voilà, donc j'ai ma méthode `__iter__` qui retourne mon objet lui-même.

Mais mon itérateur doit avoir une deuxième méthode, une méthode que je vais appeler `__next__` et qui prend également comme premier argument `self`. Ma méthode `__next__` doit retourner, à chaque appel, un élément suivant, donc dans ce cas-là, je veux que mon itérateur itère naturellement sur les mots de ma phrase, donc je veux qu'à chaque tour de boucle, j'obtienne un nouveau mot. Donc je veux obtenir un mot suivant et puis, quand je n'ai plus de mot, je veux avoir une exception `StopIteration`. C'est la définition du **protocole d'itération**.

Regardons comment faire ça. Je vais faire `if not self.mots` donc ça veut dire que tant que j'ai des mots dans ma liste de mots, qui a été initialisée dans la méthode `__init__` de ma classe, je vais faire alors non, là, si j'ai fait `if not self.mots`, ça veut dire : si je n'ai plus de mots, je vais faire un `raise` de l'exception `StopIteration`. Si jamais j'ai des mots encore dans ma liste, je vais juste faire un `return` de `self.mots` et je vais utiliser la méthode `pop(0)`, qui me permet de retourner le premier mot de ma liste. Donc la méthode `pop` va me retourner le premier mot de la liste et l'enlever de la liste. Donc, à chaque tour, ma liste va se raccourcir ; je prends le premier mot, je l'enlève, je raccourcis ma liste. Je prends le premier mot, je l'enlève, je raccourcis ma liste jusqu'à ce que je n'aie plus de mot et que j'ai l'exception `StopIteration`.

Et voilà, j'ai terminé, j'ai implémenté ma méthode `__iter__` qui retourne l'itérateur lui-même, et ma méthode `__next__`, qui retourne le mot suivant à chaque appel de `__next__` jusqu'à ce que je n'aie plus de mot et que j'aie `StopIteration`.
Maintenant, évaluons ce code et regardons son exécution. Donc je vais définir une instance `p` qui est égale à `Phrase(s)`. Je vous rappelle que `s` est la chaîne de caractères que j'ai définie, au début dans mon module. Donc j'exécute cela et maintenant, je vais faire une compréhension `m for m in p`. Je vous rappelle que les compréhensions vont exploiter le protocole d'itération et vont donc appeler la méthode `__iter__` pour obtenir l'itérateur, appeler `__next__` pour parcourir chaque mot, jusqu'à ce que j'aie `StopIteration`. Sauf que ma classe `Phrase`, je vous rappelle, est un itérateur. Or, vous vous souvenez que la caractéristique d'un itérateur, c'est qu'on ne peut le parcourir qu'une seule fois. Si maintenant, je fais une deuxième compréhension sur ma classe `Phrase`, je vois que j'obtiens une liste vide et je peux le confirmer en faisant un` __next__(p)` ; `__next__(p)` me retourne `StopIteration`. Un itérateur ne se consomme qu'une seule fois.

Donc maintenant, essayons de définir notre classe `Phrase` non pas comme itérateur mais comme itérable, c'est-à-dire comme objet que je suis capable de parcourir de multiples fois. Regardons une manière de l'implémenter. Maintenant, ma méthode `__iter__`, au lieu de retourner l'objet lui-même, ce qui définit un itérateur, va retourner un nouvel objet qui est un objet itérateur sur `Phrase`. Je vais l'appeler `IterPhrase`. Et à cet objet, je vais lui passer ma liste de mots, uniquement ce dont j'ai besoin pour définir ces différents mots. Et maintenant, je vais définir mon objet `IterPhrase`.

C'est une nouvelle classe puisque je vous rappelle que les itérateurs sont des objets, il faut donc définir une classe pour définir ce nouvel objet itérateur, qui s'appelle `IterPhrase` et qui va définir une méthode `__init__` qui prend `self` et `mots` et qui va dire `self.mots` égale une *shallow copy* de `mots`, je vais revenir dans quelques instants sur la raison de cette *shallow copy*. Ensuite, je définis une méthode `__iter__` puisque tous les itérateurs doivent avoir une méthode `__iter__`, qui prend `self` et qui va retourner l'itérateur lui-même ; et ensuite, j'ai une méthode `__next__` qui est exactement la méthode `__next__` que j'avais précédemment.

Donc on voit que le mécanisme est très proche entre un itérateur et un itérable, c'est très, très proche sauf que l'itérateur, lorsque mon objet est itérable et que j'ai besoin d'avoir plusieurs itérateurs, il faut que je crée une nouvelle classe, un nouvel objet, qui va implémenter cette fameuse méthode `__next__`. Alors, pourquoi est-ce que dans ma méthode `__init__`, j'ai défini une shallow copy ? En fait, vous remarquez que ma méthode `__next__` va faire un *pop* sur `mots`. Ça veut dire qu'elle va modifier l'objet référencé par `mots`. Si je référençais l'objet qui est contenu dans ma classe `Phrase`, ça voudrait dire qu'une fois que mon itérateur a parcouru une fois la liste des mots, mon attribut `mots` référencerait une liste vide. Pour être sûr de pouvoir itérer de multiples fois sur ma liste de mots, il faut donc que je fasse une copie et c'est cette copie que je vais, petit à petit, réduire jusqu'à ce que je n'aie plus d'élément

Maintenant, sauvegardons ce code, exécutons-le avec F5, et créons une instance. Donc je vais reprendre, ici, ce que j'avais écrit donc je crée une instance de `Phrase` et maintenant, je vais faire une compréhension `m for m in p`. Et regardons ce qu'il se passe ; j'obtiens bien ma liste de mots. Rappelons de nouveau une compréhension et j'obtiens bien de nouveau ma liste de mots, donc on voit qu'à chaque fois que j'appelle `__iter__` sur ma classe `Phrase`, j'obtiens un nouvel objet itérateur ; je peux le vérifier de la manière suivante `__iter__(p)` j'obtiens un objet itérateur ; je rappelle `__iter__(p)`, j'obtiens un nouvel objet itérateur et je peux m'en convaincre parce que les adresses sont différentes. J'aurais également pu vérifier avec l'instruction `is` que les deux objets sont différents. Seulement ici, on se rend compte qu'en fait, écrire un itérateur, enfin, écrire un objet qui est itérable, ça demande d'écrire une deuxième classe, un deuxième objet spécifiquement itérateur.

Or, vous vous souvenez peut-être qu'on a déjà vu une notion qui s'appelle les **fonctions génératrices**. Et le but des fonctions génératrices est de produire des itérateurs. Regardons alors comment est-ce qu'on peut exploiter la puissance des fonctions génératrices pour écrire un objet qui est itérable à moindre coût.

Donc revenons sur notre classe `Phrase`. Et maintenant, dans notre classe `Phrase`, au lieu de définir une classe `IterPhrase`, je vais simplement modifier ma méthode `__iter__` pour être une fonction génératrice. Regardons comment cela pourrait fonctionner. Ma méthode `__iter__` va être une boucle *for* `for m in self.mots : yield(m)` Et c'est tout. Je ne fais rien d'autre. Donc j'efface ma classe `IterPhrase` et maintenant, j'ai défini une classe `Phrase` qui est itérable.

Qui est-ce qui va produire des itérateurs ? C'est ma méthode `__iter__`. Je vous rappelle qu'à chaque fois qu'on appelle une fonction génératrice, ça crée un nouvel objet itérateur, donc, gratuitement, ma fonction génératrice va automatiquement produire des itérateurs pour moi. Et quelle est la caractéristique de cette fonction ? C'est qu'elle va parcourir la liste des mots donc j'ai un `for m in self.mots`, et à chaque tour, à chaque appel de la méthode `__next__`, je retourne un nouvel élément de `mots`. Cette méthode également ne détruit pas ma liste de mots, elle ne la modifie pas, elle ne fait que la parcourir donc je n'ai absolument rien d'autre à faire.

Exécutons maintenant ce code ; je le sauvegarde avec Ctrl-S ; je l'évalue avec F5. Recréons une instance de `Phrase` et maintenant, parcourons avec une compréhension de liste, l'instance, je vois que je peux parcourir la liste de mots et je peux la parcourir une deuxième fois, autant de fois que je veux. Chaque appel à `__iter__` sur ma classe va créer un nouvel objet itérateur ; on voit que c'est un générateur, c'est une nouvelle fonction génératrice, qui est produite automatiquement.

Vous savez qu'en Python, cette notion d'**itération**, d'**itérateur**, d'**itérable** est centrale, et que Python favorise l'utilisation des itérateurs pour éviter de dupliquer des structures de données lorsqu'on veut les parcourir. De plus, cette notion d'itérateur vous permet d'écrire des mécanismes d'itération comme des boucles *for* ou des *compréhensions*, qui soient simples et intuitives à manipuler. Nous avons vu, qu'avec la puissance des **fonctions génératrices**, on pouvait en simplement quelques lignes de code, permettre à nos objets de devenir itérables.

À bientôt !


# W6-S7 Conception d'exceptions personnalisées


Nous avons vu dans de précédentes vidéos que le mécanisme des **exceptions**, en Python, était simple et efficace. Nous avons surtout vu que ça permettait de facilement diagnostiquer des erreurs dans notre code et que les exceptions, le mécanisme d'exception était en lui-même très performant. En conséquence, c'était tout à fait normal, dans l'exercice normal d'un programme, d'avoir de nombreuses exceptions et de les capturer, pour comprendre les particularités de l'exécution de notre code. Nous allons voir, dans cette vidéo, comment créer vos propres exceptions.

À quoi ça sert de créer ses propres exceptions ? D'abord, voir que c'est extrêmement simple à faire. Ça ne demande, essentiellement, que deux lignes de code. Mais surtout, ça vous permet d'avoir une exception qui corresponde vraiment à votre besoin. En Python, toutes les exceptions que vous créez doivent hériter de la classe `Exception` ou alors d'une de ses sous-classes. En fait, nous verrons que les exceptions créent un arbre d'héritage.

Ouvrons maintenant un éditeur IDLE pour commencer à créer nos propres exceptions.

Reprenons notre fameuse classe `Phrase` et essayons de lui ajouter un mécanisme de contrôle. Donc le mécanisme de contrôle que l'on pourrait ajouter c'est si je crée une phrase, avec une phrase, ça va fonctionner normalement ; par contre, si ma phrase est vide, c'est qu'il y a un problème. Parce que, pourquoi créer une instance, avec rien dedans ? Donc à ce moment-là, on pourrait dire si jamais je fais ça, je pourrais afficher un message. Mais, en Python, la bonne manière de faire est de, ce qu'on appelle, lancer une **exception**. Donc cette exception, encore une fois, ne veut pas dire que le programme va s'arrêter. C'est une manière de communiquer qu'on a un comportement spécifique, dans le cadre de  l'exécution de notre programme. Regardons comment faire.

Pour créer une exception, en Python, nous allons voir que c'est très simple : les exceptions sont des classes, donc, je vais définir une nouvelle classe, et je vais appeler ma classe avec un nom explicite ; les exceptions doivent toujours avoir un nom explicite. Je vais appeler ça, `PhraseVide`... et on recommande de toujours finir notre exception par le mot Error (`PhraseVideError`) pour rendre clair que c'est une erreur. Toutes les exceptions finissent par Error.

Et ensuite, mon exception doit hériter de la classe `Exception`. Qu'est-ce-que je vais mettre dans ma classe? Dans 99,9 % des cas, vous n'avez absolument rien à mettre. Vous mettez simplement `pass`, pour que votre classe soit syntaxiquement valide, mais vous n'avez pas besoin de définir des arguments. Evidemment, cette classe `Exception` est une vraie classe. Donc, vous pouvez définir ce que vous voulez dedans. Mais, dans un usage standard de classe, vous n'avez pas besoin de définir d'attributs particuliers.


Et donc, maintenant, regardons comment l'utiliser. Dans ma classe `Phrase`, je vais juste rajouter un test qui va être le suivant : je vais regarder si `not ma_phrase`, ce qui veut dire, je vais rentrer dans ce test si ma phrase est vide, alors je vais lancer mon exception `raise PhraseVideError()` et je l'appelle, donc je crée une instance de ma classe, je l'appelle avec des parenthèses, je crée une instance tout à fait normale.

Donc maintenant, exécutons ce code. Je le sauvegarde avec Ctrl+s, je l'évalue avec F5. Et maintenant, je vais créer une instance de ma classe. Donc, je vais faire `p = Phrase(s)` et regardons ce qui se passe. J'ai bien mon instance, et je regarde `p` qui contient bien mon attribut `mots` qui est une liste des mots. Maintenant, je vais créer une nouvelle instance qui est égale à `Phrase` de, et cette fois, je vais passer une chaîne de caractères vide (`Phrase('')`). C'est typiquement mon cas d'erreur. Regardons ce qui se passe. J'ai une exception qui est lancée et qui s'appelle `PhraseVideError`. Comme tous les mécanismes d'exception, j'ai exactement l'endroit où c'est produit cette exception et la cause de cette exception.

Les exceptions, en Python, peuvent prendre des arguments. Donc, regardons ça. À mon exception `PhraseVideError`, je peux passer une liste d'arguments, séparés par une virgule. Tous ces arguments vont être mis dans un tuple que je pourrai ensuite manipuler, lorsque je capturerai mon exception. Regardons ça. Ici, je vais passer un message d'erreur, par exemple, `"attention, phrase vide"`, donc je vais écrire ça de la manière suivante. Alors, on va le mettre comme ça, voilà, ça sera plus simple. J'ai perdu la fin de ma phrase donc je reviens dessus. Voilà. `"attention, phrase vide"` ou je vais juste écrire simplement, voilà, on va prendre plus simplement, pour ne pas trop décaler mon code, donc, je vais écrire `"phrase vide"`, et je vais passer un code d'erreur ; par exemple, je passe 18. C'est un code d'erreur que j'invente moi, pour vous montrer que je peux passer plusieurs arguments au moment de la création de mon instance d'exception.

Donc je reviens au début. J'évalue ce code. Je l'exécute et maintenant re-créons une instance de `Phrase` qui prend une phrase vide. Et j'exécute ça. Regardons ce qui se passe. Je vois que j'ai bien toujours mon exception `PhraseVideError`, mais je vois que, maintenant, les arguments que j'ai passés à mon instance sont affichés au moment de l'exception. Donc je vois bien que j'ai ma chaîne de caractères `"phrase vide"` et mon code d'erreur, et ces arguments sont mis dans un tuple.

Maintenant, regardons comment les manipuler. Je vais simplement rajouter un bloc *try except*. Faire un `try` de `Phrase` avec une chaîne de caractères vide (`Phrase('')`) et je vais faire un `except` de `PhraseVideError`, je vous rappelle que mon *except* doit toujours, autant que possible, capturer une exception de manière explicite, `as e`. Donc, ça veut dire que `e` va référencer l'instance de l'objet exception qui a été lancée. Et dans cet objet exception, en fait, j'ai un argument qui s'appelle `args`, qui est simplement un tuple qui va référencer le tuple que j'ai passé, enfin les arguments que j'ai passés, lorsque j'ai construit mon exception. Donc exécutons ça. J'évalue ce code. Et je vois effectivement qu'ici je vois apparaître le tuple qui contient, comme premier élément, mon message d'erreur, comme deuxième élément, par exemple, mon code d'erreur. Comme c'est un tuple, après je peux tout à fait le manipuler comme n'importe quel tuple.

Nous venons de voir comment créer vos propres exceptions, en Python. En fait, nous avons vu que c'était extrêmement simple. Essentiellement, vous avez juste besoin de définir une classe avec un nom qui finit par Error et hérite d'`Exception` et puis c'est tout. C'est donc une manière extrêmement simple de documenter les comportements spécifiques ou les comportements erronés de votre programme.

À bientôt !


# W6-S8 Conception de context manager


En programmation, il est courant de devoir faire des **opérations de finalisation**. Par exemple, quand vous avez un objet fichier dont vous n'avez plus besoin, vous devez le fermer, ou lorsque vous avez une *socket*, vous devez également la fermer. L'idée, c'est de libérer des ressources quand on n'a plus besoin de cet objet. Ces opérations de finalisation doivent être faites même si on a une exception en cours d'exécution. En fait, l'idée c'est si votre programme plante, vous finalisez vos objets, avant que le programme s'arrête définitivement. En Python, vous avez une manière de faire ça. C'est avec l'instruction `try finally`.

e fait, c'est un `try except` qui a une clause `finally` qui va s'exécuter que vous ayez une exception dans le bloc de code `try` ou que vous n'ayez pas d'exception. Vous avez la certitude que le bloc de code du `finally` s'exécutera quelque soit l'exécution du bloc de code du `try`.  

Cependant, ici, vous voyez un problème. Lorsque vous faites de la finalisation, on demande à la personne qui utilise l'objet de penser à faire un `try finally` et surtout, cette personne doit connaître les bonnes opérations de finalisation à faire. Lorsque l'on y pense, on se dit que ça serait beaucoup plus malin de laisser ces opérations de finalisation à la charge de celui qui a conçu l'objet et d'offrir un mécanisme pour dire "je n'ai plus besoin de l'objet", et qu'automatiquement ces opérations de finalisation s'exécutent. C'est exactement ce que permet un **context manager**. Nous avons d'ailleurs déjà introduit la notion de context manager, dans le cadre des fichiers. Dans cette vidéo, nous allons voir comment concevoir des context managers, pour vos propres objets.

Donc, regardons la syntaxe d'un context manager. Vous faites un `with expression as x :`, et ensuite vous avez un bloc de code. Votre expression, lorsque vous évaluez ce context manager, votre expression va retourner un objet. Et cet objet va être un objet qui implémente un protocole qu'on appelle le **protocole de context manager**. Dans ce protocole, vous avez une méthode `__enter__`. Cette méthode `__enter__` va retourner un objet qui va être référencé par la variable `x`. Donc nous voyons bien que cette méthode `__enter__` appartient à l'objet. Ensuite, vous évaluez le bloc de code. Et ensuite, en sortie du bloc de code, ou si vous avez une exception, lors de l'évaluation de ce bloc de code, vous allez, dans tous les cas, exécuter une méthode `__exit__` sur cet objet. C'est ça le protocole de context manager : ce sont ces deux méthodes, `__enter__` et `__exit__`, qui sont automatiquement exécutées lorsque vous avez l'instruction `with`.

Maintenant, ouvrons un éditeur IDLE pour commencer à jouer avec la conception des contexts managers.

Illustrons la création d'un context manager avec l'implémentation d'une classe que l'on va appeler `Timer`. L'objectif de notre classe `Timer` sera d'évaluer le temps d'exécution d'un bloc de code, qui est à l'intérieur d'une instruction `with`. Regardons comment faire ça.

Je vais d'abord importer le module `time` qui me permet d'avoir un temps, un temps courant et ensuite, je vais créer une classe que j'appelle `Timer`. Dans cette classe, je vais définir mon protocole de context manager. Il me faut, donc, une méthode `__enter__` qui va prendre comme argument `self` et qui doit faire quelque chose, avant d'entrer dans mon bloc de code, et ensuite, qui doit retourner un objet, qui sera référencé par la variable qui est après le `as`. En général, les contexts managers retournent l'objet lui-même, mais on pourrait imaginer retourner autre chose. Dans mon context, je vais retourner l'objet lui-même. Donc, je vais définir `self.start`, un attribut dans mon instance, qui est égal à `time.time()`. `time.time()` me donne le temps courant. Et ensuite, je vais faire un `return self`. C'est ce que va faire mon context manager.

Ensuite, dans ce protocole, je dois avoir une deuxième méthode qui s'appelle `__exit__`, qui est la méthode qui sera exécutée lorsque je sors du bloc de code du context manager ou si j'ai une exception. Cette méthode va prendre `self` et un attribut `*args` et ensuite, je vais définir un attribut `duree` qui est égal à `time.time() - self.start`. Donc, on voit que, quand j'arrive dans `__exit__`, je prends simplement le temps que j'avais au démarrage et je le soustrais au temps courant. Et ça va me donner le temps d'exécution. Ensuite, je vais faire un `print`, dans une *f-string*, de simplement `duree` et je vais dire que c'est en secondes. Et ensuite, ma méthode `__exit__` doit retourner un booléen: soit `False`, soit `True`. Si je retourne `False`, ça veut dire qu'en cas d'exception, mon exception va être remontée et va faire arrêter mon programme. Si je retourne `True`, ça veut dire qu'en cas d'exception, mon exception va être capturée par l'instruction `with` et, par conséquent, mon exception ne sortira pas. Je vous rappelle, que, d'une manière générale, c'est une bonne pratique de laisser remonter les exceptions, sauf si on sait précisément ce que l'on fait.

Et ensuite je vais définir une dernière méthode que je vais appeler `__str__`. Vous vous souvenez, c'est la méthode qui est appelée par la fonction *builtins* `print`, qui va juste me faire `duree = time.time() - self.start` et qui va faire un `return` d'une chaîne de caractères qui va être une *f-string* qui va contenir `"intermediaire : duree en secondes"`. Quel est l'intérêt de cette méthode `__str__` ? C'est lorsque j'appellerai `print` sur mon objet qui implémente le protocole de context manager, je vais avoir un temps intermédiaire d'exécution. Donc, ça me permet d'avoir un peu plus de fonctionnalités. Exécutons ça, évaluons le.

Et maintenant, définissons une autre instruction `with` avec cet objet. Je vous montre cela. Je vais faire un `with Timer`, donc c'est mon context manager, `as t:`. Je vous rappelle que ma variable `t` va prendre la valeur de retour de la méthode `__enter__`, c'est donc l'instance de `Timer` elle-même, que je récupère. Et dedans, je vais simplement faire une somme, avec une expression génératrice, qui est `x for x in range(10_000_000)`. Voilà. Ensuite, je vais faire un `print(t)`, pour afficher un temps intermédiaire et je vais faire une deuxième compréhension, où là, au lieu de prendre `x`, je prends `x` au carré. Et maintenant, exécutons tout ça.

Lorsque je vais rentrer dans mon bloc de code, je vais avoir l'attribut `start`, dans mon `Timer`, qui va être initialisé au temps courant. Ensuite, je vais exécuter la somme de mon expression génératrice. Ensuite, j'affiche un temps intermédiaire avec `print(t)`, ça va appeler la méthode `__str__` qui affiche le temps intermédiaire. Et ensuite, je calcule, de nouveau, une deuxième somme, et, en sortie de mon bloc de code, je vais afficher le temps d'exécution, en faisant ça. Et regardons ce qui se passe. Je vois que j'ai un temps intermédiaire qui est de 0,7 seconde, et le temps final est de 4 secondes.

Maintenant, regardons ce qui se passe en cas d'exception. Donc, je vais ajouter une exception ici : un divisé par zéro, donc une `ZeroDivisionError`. Et on va voir ce qui va se passer dans mon context manager. Donc j'exécute. J'évalue avec F5. Et on voit que j'ai bien mon temps intermédiaire qui s'affiche correctement, mon temps final qui s'affiche correctement ; évidement, mon temps final est très proche du temps intermédiaire puisque, au moment de l'exception, mon bloc d'instructions va s'arrêter et je n'aurai pas le temps d'évaluer ma dernière expression génératrice. Mais, on voit, cependant, que ma méthode `__exit__` a bien été appelée, bien que j'aie une exception.

Nous venons de voir le **mécanisme de context manager** qui vous permet d'exécuter du code avant et après un bloc de code, contenu dans une instruction `with`. Notamment, le context manager est extrêmement pratique pour implementer, dans vos propres objets, les opérations de finalisation et laisser au protocole de context manager le soin de faire ces opérations pour l'utilisateur. Nous verrons également lorsque nous parlerons des **décorateurs** que les contexts managers sont très proches dans l'esprit, mais très différents dans la forme. Nous aborderons ça dans les sujets avancés de Python.

À bientôt !
